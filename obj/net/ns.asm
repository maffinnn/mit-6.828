
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us(the user environment) running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 9e e8 00 00       	call   80e8cf <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	f3 0f 1e fb          	endbr32 
  800037:	55                   	push   %ebp
  800038:	89 e5                	mov    %esp,%ebp
  80003a:	83 ec 14             	sub    $0x14,%esp
  80003d:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800040:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800046:	50                   	push   %eax
  800047:	e8 5f a8 00 00       	call   80a8ab <thread_wakeup>
}
  80004c:	83 c4 10             	add    $0x10,%esp
  80004f:	c9                   	leave  
  800050:	c3                   	ret    

00800051 <start_timer>:
{
  800051:	55                   	push   %ebp
  800052:	89 e5                	mov    %esp,%ebp
  800054:	53                   	push   %ebx
  800055:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800058:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80005b:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  80005d:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800060:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800063:	50                   	push   %eax
  800064:	68 98 00 80 00       	push   $0x800098
  800069:	51                   	push   %ecx
  80006a:	6a 00                	push   $0x0
  80006c:	e8 b1 a8 00 00       	call   80a922 <thread_create>
	if (r < 0)
  800071:	83 c4 10             	add    $0x10,%esp
  800074:	85 c0                	test   %eax,%eax
  800076:	78 05                	js     80007d <start_timer+0x2c>
}
  800078:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80007b:	c9                   	leave  
  80007c:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  80007d:	83 ec 0c             	sub    $0xc,%esp
  800080:	50                   	push   %eax
  800081:	e8 e7 ab 00 00       	call   80ac6d <e2s>
  800086:	50                   	push   %eax
  800087:	68 a0 11 81 00       	push   $0x8111a0
  80008c:	6a 7a                	push   $0x7a
  80008e:	68 d5 12 81 00       	push   $0x8112d5
  800093:	e8 9f e8 00 00       	call   80e937 <_panic>

00800098 <net_timer>:
{
  800098:	f3 0f 1e fb          	endbr32 
  80009c:	55                   	push   %ebp
  80009d:	89 e5                	mov    %esp,%ebp
  80009f:	56                   	push   %esi
  8000a0:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  8000a1:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  8000a4:	e8 12 f5 00 00       	call   80f5bb <sys_time_msec>
  8000a9:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000ab:	e8 c2 a7 00 00       	call   80a872 <lwip_core_lock>
		t->func();
  8000b0:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000b3:	e8 bf a7 00 00       	call   80a877 <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b8:	83 ec 04             	sub    $0x4,%esp
  8000bb:	03 1e                	add    (%esi),%ebx
  8000bd:	53                   	push   %ebx
  8000be:	6a 00                	push   $0x0
  8000c0:	6a 00                	push   $0x0
  8000c2:	e8 0f aa 00 00       	call   80aad6 <thread_wait>
  8000c7:	83 c4 10             	add    $0x10,%esp
  8000ca:	eb d8                	jmp    8000a4 <net_timer+0xc>

008000cc <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000cc:	f3 0f 1e fb          	endbr32 
  8000d0:	55                   	push   %ebp
  8000d1:	89 e5                	mov    %esp,%ebp
  8000d3:	57                   	push   %edi
  8000d4:	56                   	push   %esi
  8000d5:	53                   	push   %ebx
  8000d6:	83 ec 7c             	sub    $0x7c,%esp
  8000d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000dc:	8b 7b 08             	mov    0x8(%ebx),%edi
  8000df:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000e2:	0f 87 50 01 00 00    	ja     800238 <serve_thread+0x16c>
  8000e8:	8b 03                	mov    (%ebx),%eax
  8000ea:	3e ff 24 85 80 13 81 	notrack jmp *0x811380(,%eax,4)
  8000f1:	00 

	switch (args->reqno) {
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000f2:	8b 47 04             	mov    0x4(%edi),%eax
  8000f5:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000f8:	83 ec 04             	sub    $0x4,%esp
  8000fb:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000fe:	50                   	push   %eax
  8000ff:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800102:	50                   	push   %eax
  800103:	ff 37                	pushl  (%edi)
  800105:	e8 22 0e 00 00       	call   800f2c <lwip_accept>
  80010a:	89 c6                	mov    %eax,%esi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  80010c:	83 c4 0c             	add    $0xc,%esp
  80010f:	6a 14                	push   $0x14
  800111:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800114:	50                   	push   %eax
  800115:	57                   	push   %edi
  800116:	e8 0b f1 00 00       	call   80f226 <memmove>
  80011b:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  80011e:	83 fe ff             	cmp    $0xffffffff,%esi
  800121:	0f 84 2f 01 00 00    	je     800256 <serve_thread+0x18a>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  800127:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80012a:	0f 85 48 01 00 00    	jne    800278 <serve_thread+0x1ac>
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
  800130:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800133:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  800139:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80013c:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)
	sys_page_unmap(0, (void*) args->req);
  800143:	83 ec 08             	sub    $0x8,%esp
  800146:	52                   	push   %edx
  800147:	6a 00                	push   $0x0
  800149:	e8 8e f3 00 00       	call   80f4dc <sys_page_unmap>
	free(args);
  80014e:	89 1c 24             	mov    %ebx,(%esp)
  800151:	e8 6e 05 01 00       	call   8106c4 <free>
}
  800156:	83 c4 10             	add    $0x10,%esp
  800159:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80015c:	5b                   	pop    %ebx
  80015d:	5e                   	pop    %esi
  80015e:	5f                   	pop    %edi
  80015f:	5d                   	pop    %ebp
  800160:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800161:	83 ec 04             	sub    $0x4,%esp
  800164:	ff 77 14             	pushl  0x14(%edi)
  800167:	8d 47 04             	lea    0x4(%edi),%eax
  80016a:	50                   	push   %eax
  80016b:	ff 37                	pushl  (%edi)
  80016d:	e8 70 0f 00 00       	call   8010e2 <lwip_bind>
  800172:	89 c6                	mov    %eax,%esi
		break;
  800174:	83 c4 10             	add    $0x10,%esp
  800177:	eb a5                	jmp    80011e <serve_thread+0x52>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800179:	83 ec 08             	sub    $0x8,%esp
  80017c:	ff 77 04             	pushl  0x4(%edi)
  80017f:	ff 37                	pushl  (%edi)
  800181:	e8 e7 1a 00 00       	call   801c6d <lwip_shutdown>
  800186:	89 c6                	mov    %eax,%esi
		break;
  800188:	83 c4 10             	add    $0x10,%esp
  80018b:	eb 91                	jmp    80011e <serve_thread+0x52>
		r = lwip_close(req->close.req_s);
  80018d:	83 ec 0c             	sub    $0xc,%esp
  800190:	ff 37                	pushl  (%edi)
  800192:	e8 05 10 00 00       	call   80119c <lwip_close>
  800197:	89 c6                	mov    %eax,%esi
		break;
  800199:	83 c4 10             	add    $0x10,%esp
  80019c:	eb 80                	jmp    80011e <serve_thread+0x52>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80019e:	83 ec 04             	sub    $0x4,%esp
  8001a1:	ff 77 14             	pushl  0x14(%edi)
  8001a4:	8d 47 04             	lea    0x4(%edi),%eax
  8001a7:	50                   	push   %eax
  8001a8:	ff 37                	pushl  (%edi)
  8001aa:	e8 7a 10 00 00       	call   801229 <lwip_connect>
  8001af:	89 c6                	mov    %eax,%esi
		break;
  8001b1:	83 c4 10             	add    $0x10,%esp
  8001b4:	e9 65 ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001b9:	83 ec 08             	sub    $0x8,%esp
  8001bc:	ff 77 04             	pushl  0x4(%edi)
  8001bf:	ff 37                	pushl  (%edi)
  8001c1:	e8 1d 11 00 00       	call   8012e3 <lwip_listen>
  8001c6:	89 c6                	mov    %eax,%esi
		break;
  8001c8:	83 c4 10             	add    $0x10,%esp
  8001cb:	e9 4e ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001d0:	ff 77 08             	pushl  0x8(%edi)
  8001d3:	ff 77 04             	pushl  0x4(%edi)
  8001d6:	57                   	push   %edi
  8001d7:	ff 37                	pushl  (%edi)
  8001d9:	e8 fc 13 00 00       	call   8015da <lwip_recv>
  8001de:	89 c6                	mov    %eax,%esi
		break;
  8001e0:	83 c4 10             	add    $0x10,%esp
  8001e3:	e9 36 ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001e8:	ff 77 08             	pushl  0x8(%edi)
  8001eb:	ff 77 04             	pushl  0x4(%edi)
  8001ee:	8d 47 0c             	lea    0xc(%edi),%eax
  8001f1:	50                   	push   %eax
  8001f2:	ff 37                	pushl  (%edi)
  8001f4:	e8 7b 15 00 00       	call   801774 <lwip_send>
  8001f9:	89 c6                	mov    %eax,%esi
		break;
  8001fb:	83 c4 10             	add    $0x10,%esp
  8001fe:	e9 1b ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800203:	83 ec 04             	sub    $0x4,%esp
  800206:	ff 77 08             	pushl  0x8(%edi)
  800209:	ff 77 04             	pushl  0x4(%edi)
  80020c:	ff 37                	pushl  (%edi)
  80020e:	e8 f6 15 00 00       	call   801809 <lwip_socket>
  800213:	89 c6                	mov    %eax,%esi
		break;
  800215:	83 c4 10             	add    $0x10,%esp
  800218:	e9 01 ff ff ff       	jmp    80011e <serve_thread+0x52>
		jif_input(&nif, (void *)&req->pkt);
  80021d:	83 ec 08             	sub    $0x8,%esp
  800220:	57                   	push   %edi
  800221:	68 00 b2 b3 00       	push   $0xb3b200
  800226:	e8 3d ab 00 00       	call   80ad68 <jif_input>
  80022b:	83 c4 10             	add    $0x10,%esp
		r = 0;
  80022e:	be 00 00 00 00       	mov    $0x0,%esi
  800233:	e9 ef fe ff ff       	jmp    800127 <serve_thread+0x5b>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800238:	83 ec 04             	sub    $0x4,%esp
  80023b:	57                   	push   %edi
  80023c:	ff 73 04             	pushl  0x4(%ebx)
  80023f:	68 c0 11 81 00       	push   $0x8111c0
  800244:	e8 d5 e7 00 00       	call   80ea1e <cprintf>
  800249:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80024c:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  800251:	e9 d1 fe ff ff       	jmp    800127 <serve_thread+0x5b>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800256:	ff 33                	pushl  (%ebx)
  800258:	68 e0 12 81 00       	push   $0x8112e0
  80025d:	6a 64                	push   $0x64
  80025f:	8d 7d 84             	lea    -0x7c(%ebp),%edi
  800262:	57                   	push   %edi
  800263:	e8 5f ed 00 00       	call   80efc7 <snprintf>
		perror(buf);
  800268:	89 3c 24             	mov    %edi,(%esp)
  80026b:	e8 d5 a9 00 00       	call   80ac45 <perror>
  800270:	83 c4 10             	add    $0x10,%esp
  800273:	e9 af fe ff ff       	jmp    800127 <serve_thread+0x5b>
		ipc_send(args->whom, r, 0, 0);
  800278:	6a 00                	push   $0x0
  80027a:	6a 00                	push   $0x0
  80027c:	56                   	push   %esi
  80027d:	ff 73 04             	pushl  0x4(%ebx)
  800280:	e8 9d f6 00 00       	call   80f922 <ipc_send>
  800285:	83 c4 10             	add    $0x10,%esp
  800288:	e9 a3 fe ff ff       	jmp    800130 <serve_thread+0x64>

0080028d <serve_init>:
{
  80028d:	f3 0f 1e fb          	endbr32 
  800291:	55                   	push   %ebp
  800292:	89 e5                	mov    %esp,%ebp
  800294:	56                   	push   %esi
  800295:	53                   	push   %ebx
  800296:	83 ec 10             	sub    $0x10,%esp
  800299:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  80029c:	e8 d1 a5 00 00       	call   80a872 <lwip_core_lock>
	uint32_t done = 0;
  8002a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  8002a8:	83 ec 08             	sub    $0x8,%esp
  8002ab:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8002ae:	53                   	push   %ebx
  8002af:	68 33 00 80 00       	push   $0x800033
  8002b4:	e8 91 22 00 00       	call   80254a <tcpip_init>
	lwip_core_unlock();
  8002b9:	e8 b9 a5 00 00       	call   80a877 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002be:	83 c4 0c             	add    $0xc,%esp
  8002c1:	6a ff                	push   $0xffffffff
  8002c3:	6a 00                	push   $0x0
  8002c5:	53                   	push   %ebx
  8002c6:	e8 0b a8 00 00       	call   80aad6 <thread_wait>
	lwip_core_lock();
  8002cb:	e8 a2 a5 00 00       	call   80a872 <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002d0:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002d9:	8b 45 10             	mov    0x10(%ebp),%eax
  8002dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002df:	83 c4 0c             	add    $0xc,%esp
  8002e2:	68 7f 67 80 00       	push   $0x80677f
  8002e7:	68 57 ae 80 00       	push   $0x80ae57
  8002ec:	68 14 50 81 00       	push   $0x815014
  8002f1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002f4:	50                   	push   %eax
  8002f5:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002f8:	50                   	push   %eax
  8002f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002fc:	50                   	push   %eax
  8002fd:	68 00 b2 b3 00       	push   $0xb3b200
  800302:	e8 0e 45 00 00       	call   804815 <netif_add>
  800307:	83 c4 20             	add    $0x20,%esp
  80030a:	85 c0                	test   %eax,%eax
  80030c:	0f 84 cc 00 00 00    	je     8003de <serve_init+0x151>
	netif_set_default(nif);
  800312:	83 ec 0c             	sub    $0xc,%esp
  800315:	68 00 b2 b3 00       	push   $0xb3b200
  80031a:	e8 b4 45 00 00       	call   8048d3 <netif_set_default>
	netif_set_up(nif);
  80031f:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  800326:	e8 b9 45 00 00       	call   8048e4 <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80032b:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800332:	b9 ef 12 81 00       	mov    $0x8112ef,%ecx
  800337:	ba 97 97 80 00       	mov    $0x809797,%edx
  80033c:	b8 34 50 81 00       	mov    $0x815034,%eax
  800341:	e8 0b fd ff ff       	call   800051 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800346:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80034d:	b9 f9 12 81 00       	mov    $0x8112f9,%ecx
  800352:	ba f6 58 80 00       	mov    $0x8058f6,%edx
  800357:	b8 28 50 81 00       	mov    $0x815028,%eax
  80035c:	e8 f0 fc ff ff       	call   800051 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800361:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800368:	b9 05 13 81 00       	mov    $0x811305,%ecx
  80036d:	ba cd 5e 80 00       	mov    $0x805ecd,%edx
  800372:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  800377:	e8 d5 fc ff ff       	call   800051 <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80037c:	89 34 24             	mov    %esi,(%esp)
  80037f:	e8 2b 75 00 00       	call   8078af <inet_ntoa>
  800384:	50                   	push   %eax
  800385:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  80038c:	50                   	push   %eax
  80038d:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  800394:	50                   	push   %eax
  800395:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  80039c:	50                   	push   %eax
  80039d:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  8003a4:	50                   	push   %eax
  8003a5:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  8003ac:	50                   	push   %eax
  8003ad:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  8003b4:	50                   	push   %eax
  8003b5:	68 04 12 81 00       	push   $0x811204
  8003ba:	e8 5f e6 00 00       	call   80ea1e <cprintf>
	lwip_core_unlock();
  8003bf:	83 c4 30             	add    $0x30,%esp
  8003c2:	e8 b0 a4 00 00       	call   80a877 <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003c7:	83 ec 0c             	sub    $0xc,%esp
  8003ca:	68 11 13 81 00       	push   $0x811311
  8003cf:	e8 4a e6 00 00       	call   80ea1e <cprintf>
}
  8003d4:	83 c4 10             	add    $0x10,%esp
  8003d7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003da:	5b                   	pop    %ebx
  8003db:	5e                   	pop    %esi
  8003dc:	5d                   	pop    %ebp
  8003dd:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003de:	83 ec 04             	sub    $0x4,%esp
  8003e1:	68 e4 11 81 00       	push   $0x8111e4
  8003e6:	6a 5c                	push   $0x5c
  8003e8:	68 d5 12 81 00       	push   $0x8112d5
  8003ed:	e8 45 e5 00 00       	call   80e937 <_panic>

008003f2 <serve>:

void
serve(void) {
  8003f2:	f3 0f 1e fb          	endbr32 
  8003f6:	55                   	push   %ebp
  8003f7:	89 e5                	mov    %esp,%ebp
  8003f9:	57                   	push   %edi
  8003fa:	56                   	push   %esi
  8003fb:	53                   	push   %ebx
  8003fc:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003ff:	8d 7d e0             	lea    -0x20(%ebp),%edi
  800402:	e9 9d 00 00 00       	jmp    8004a4 <serve+0xb2>
		perm = 0;
  800407:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  80040e:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  800413:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  80041a:	74 1c                	je     800438 <serve+0x46>
	for (i = 0; i < QUEUE_SIZE; i++)
  80041c:	83 c0 01             	add    $0x1,%eax
  80041f:	83 f8 14             	cmp    $0x14,%eax
  800422:	75 ef                	jne    800413 <serve+0x21>
		panic("NS: buffer overflow");
  800424:	83 ec 04             	sub    $0x4,%esp
  800427:	68 2a 13 81 00       	push   $0x81132a
  80042c:	6a 3f                	push   $0x3f
  80042e:	68 d5 12 81 00       	push   $0x8112d5
  800433:	e8 ff e4 00 00       	call   80e937 <_panic>
	va = (void *)(REQVA + i * PGSIZE);
  800438:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80043e:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  800441:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800448:	83 ec 04             	sub    $0x4,%esp
  80044b:	57                   	push   %edi
  80044c:	53                   	push   %ebx
  80044d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800450:	50                   	push   %eax
  800451:	e8 5f f4 00 00       	call   80f8b5 <ipc_recv>
  800456:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800458:	83 c4 10             	add    $0x10,%esp
  80045b:	83 f8 0c             	cmp    $0xc,%eax
  80045e:	74 69                	je     8004c9 <serve+0xd7>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800460:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800464:	0f 84 bb 00 00 00    	je     800525 <serve+0x133>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80046a:	83 ec 0c             	sub    $0xc,%esp
  80046d:	6a 0c                	push   $0xc
  80046f:	e8 00 03 01 00       	call   810774 <malloc>
		if (!args)
  800474:	83 c4 10             	add    $0x10,%esp
  800477:	85 c0                	test   %eax,%eax
  800479:	0f 84 be 00 00 00    	je     80053d <serve+0x14b>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  80047f:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  800481:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800484:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800487:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  80048a:	50                   	push   %eax
  80048b:	68 cc 00 80 00       	push   $0x8000cc
  800490:	68 3e 13 81 00       	push   $0x81133e
  800495:	6a 00                	push   $0x0
  800497:	e8 86 a4 00 00       	call   80a922 <thread_create>
		thread_yield(); // let the thread created run
  80049c:	e8 ae a5 00 00       	call   80aa4f <thread_yield>
  8004a1:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004a4:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004a9:	e8 22 a4 00 00       	call   80a8d0 <thread_wakeups_pending>
  8004ae:	85 c0                	test   %eax,%eax
  8004b0:	0f 84 51 ff ff ff    	je     800407 <serve+0x15>
  8004b6:	83 fb 1f             	cmp    $0x1f,%ebx
  8004b9:	0f 8f 48 ff ff ff    	jg     800407 <serve+0x15>
			thread_yield();
  8004bf:	e8 8b a5 00 00       	call   80aa4f <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004c4:	83 c3 01             	add    $0x1,%ebx
  8004c7:	eb e0                	jmp    8004a9 <serve+0xb7>
			process_timer(whom);
  8004c9:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004cc:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  8004d2:	74 23                	je     8004f7 <serve+0x105>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004d4:	83 ec 08             	sub    $0x8,%esp
  8004d7:	56                   	push   %esi
  8004d8:	68 40 12 81 00       	push   $0x811240
  8004dd:	e8 3c e5 00 00       	call   80ea1e <cprintf>
		return;
  8004e2:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004e5:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004eb:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004ee:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)
			continue;
  8004f5:	eb ad                	jmp    8004a4 <serve+0xb2>
	start = sys_time_msec();
  8004f7:	e8 bf f0 00 00       	call   80f5bb <sys_time_msec>
  8004fc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004ff:	e8 4b a5 00 00       	call   80aa4f <thread_yield>
	now = sys_time_msec();
  800504:	e8 b2 f0 00 00       	call   80f5bb <sys_time_msec>
  800509:	89 c2                	mov    %eax,%edx
	ipc_send(envid, to, 0, 0);
  80050b:	6a 00                	push   $0x0
  80050d:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  80050f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800512:	05 fa 00 00 00       	add    $0xfa,%eax
  800517:	29 d0                	sub    %edx,%eax
	ipc_send(envid, to, 0, 0);
  800519:	50                   	push   %eax
  80051a:	56                   	push   %esi
  80051b:	e8 02 f4 00 00       	call   80f922 <ipc_send>
  800520:	83 c4 10             	add    $0x10,%esp
  800523:	eb c0                	jmp    8004e5 <serve+0xf3>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800525:	83 ec 08             	sub    $0x8,%esp
  800528:	ff 75 e4             	pushl  -0x1c(%ebp)
  80052b:	68 7c 12 81 00       	push   $0x81127c
  800530:	e8 e9 e4 00 00       	call   80ea1e <cprintf>
			continue; // just leave it hanging...
  800535:	83 c4 10             	add    $0x10,%esp
  800538:	e9 67 ff ff ff       	jmp    8004a4 <serve+0xb2>
			panic("could not allocate thread args structure");
  80053d:	83 ec 04             	sub    $0x4,%esp
  800540:	68 ac 12 81 00       	push   $0x8112ac
  800545:	68 27 01 00 00       	push   $0x127
  80054a:	68 d5 12 81 00       	push   $0x8112d5
  80054f:	e8 e3 e3 00 00       	call   80e937 <_panic>

00800554 <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  800554:	f3 0f 1e fb          	endbr32 
  800558:	55                   	push   %ebp
  800559:	89 e5                	mov    %esp,%ebp
  80055b:	56                   	push   %esi
  80055c:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  80055d:	83 ec 0c             	sub    $0xc,%esp
  800560:	68 4b 13 81 00       	push   $0x81134b
  800565:	e8 12 76 00 00       	call   807b7c <inet_addr>
  80056a:	89 c6                	mov    %eax,%esi
  80056c:	c7 04 24 54 13 81 00 	movl   $0x811354,(%esp)
  800573:	e8 04 76 00 00       	call   807b7c <inet_addr>
  800578:	89 c3                	mov    %eax,%ebx
  80057a:	c7 04 24 62 13 81 00 	movl   $0x811362,(%esp)
  800581:	e8 f6 75 00 00       	call   807b7c <inet_addr>
  800586:	83 c4 0c             	add    $0xc,%esp
  800589:	56                   	push   %esi
  80058a:	53                   	push   %ebx
  80058b:	50                   	push   %eax
  80058c:	e8 fc fc ff ff       	call   80028d <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800591:	e8 5c fe ff ff       	call   8003f2 <serve>

00800596 <umain>:
}

void
umain(int argc, char **argv)
{
  800596:	f3 0f 1e fb          	endbr32 
  80059a:	55                   	push   %ebp
  80059b:	89 e5                	mov    %esp,%ebp
  80059d:	53                   	push   %ebx
  80059e:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  8005a1:	e8 a5 ee 00 00       	call   80f44b <sys_getenvid>
  8005a6:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  8005a8:	c7 05 e8 42 81 00 57 	movl   $0x813d57,0x8142e8
  8005af:	3d 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  8005b2:	e8 6d f1 00 00       	call   80f724 <fork>
  8005b7:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  8005bc:	85 c0                	test   %eax,%eax
  8005be:	78 43                	js     800603 <umain+0x6d>
		panic("error forking");
	else if (timer_envid == 0) {
  8005c0:	74 58                	je     80061a <umain+0x84>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005c2:	e8 5d f1 00 00       	call   80f724 <fork>
	if (input_envid < 0)
  8005c7:	85 c0                	test   %eax,%eax
  8005c9:	78 65                	js     800630 <umain+0x9a>
		panic("error forking");
	else if (input_envid == 0) {
  8005cb:	74 7a                	je     800647 <umain+0xb1>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005cd:	e8 52 f1 00 00       	call   80f724 <fork>
  8005d2:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005d7:	85 c0                	test   %eax,%eax
  8005d9:	78 7a                	js     800655 <umain+0xbf>
		panic("error forking");
	else if (output_envid == 0) {
  8005db:	0f 84 8b 00 00 00    	je     80066c <umain+0xd6>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005e1:	e8 96 a2 00 00       	call   80a87c <thread_init>
	thread_create(0, "main", tmain, 0);
  8005e6:	6a 00                	push   $0x0
  8005e8:	68 54 05 80 00       	push   $0x800554
  8005ed:	68 7a 13 81 00       	push   $0x81137a
  8005f2:	6a 00                	push   $0x0
  8005f4:	e8 29 a3 00 00       	call   80a922 <thread_create>
	thread_yield();
  8005f9:	e8 51 a4 00 00       	call   80aa4f <thread_yield>
  8005fe:	83 c4 10             	add    $0x10,%esp
  800601:	eb 28                	jmp    80062b <umain+0x95>
		panic("error forking");
  800603:	83 ec 04             	sub    $0x4,%esp
  800606:	68 6c 13 81 00       	push   $0x81136c
  80060b:	68 44 01 00 00       	push   $0x144
  800610:	68 d5 12 81 00       	push   $0x8112d5
  800615:	e8 1d e3 00 00       	call   80e937 <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  80061a:	83 ec 08             	sub    $0x8,%esp
  80061d:	68 fa 00 00 00       	push   $0xfa
  800622:	53                   	push   %ebx
  800623:	e8 52 00 00 00       	call   80067a <timer>
		return;
  800628:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  80062b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80062e:	c9                   	leave  
  80062f:	c3                   	ret    
		panic("error forking");
  800630:	83 ec 04             	sub    $0x4,%esp
  800633:	68 6c 13 81 00       	push   $0x81136c
  800638:	68 4e 01 00 00       	push   $0x14e
  80063d:	68 d5 12 81 00       	push   $0x8112d5
  800642:	e8 f0 e2 00 00       	call   80e937 <_panic>
		input(ns_envid);
  800647:	83 ec 0c             	sub    $0xc,%esp
  80064a:	53                   	push   %ebx
  80064b:	e8 c1 00 00 00       	call   800711 <input>
		return;
  800650:	83 c4 10             	add    $0x10,%esp
  800653:	eb d6                	jmp    80062b <umain+0x95>
		panic("error forking");
  800655:	83 ec 04             	sub    $0x4,%esp
  800658:	68 6c 13 81 00       	push   $0x81136c
  80065d:	68 58 01 00 00       	push   $0x158
  800662:	68 d5 12 81 00       	push   $0x8112d5
  800667:	e8 cb e2 00 00       	call   80e937 <_panic>
		output(ns_envid);
  80066c:	83 ec 0c             	sub    $0xc,%esp
  80066f:	53                   	push   %ebx
  800670:	e8 57 01 00 00       	call   8007cc <output>
		return;
  800675:	83 c4 10             	add    $0x10,%esp
  800678:	eb b1                	jmp    80062b <umain+0x95>

0080067a <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  80067a:	f3 0f 1e fb          	endbr32 
  80067e:	55                   	push   %ebp
  80067f:	89 e5                	mov    %esp,%ebp
  800681:	57                   	push   %edi
  800682:	56                   	push   %esi
  800683:	53                   	push   %ebx
  800684:	83 ec 1c             	sub    $0x1c,%esp
  800687:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80068a:	e8 2c ef 00 00       	call   80f5bb <sys_time_msec>
  80068f:	03 45 0c             	add    0xc(%ebp),%eax
  800692:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  800694:	c7 05 e8 42 81 00 ac 	movl   $0x8113ac,0x8142e8
  80069b:	13 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80069e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8006a1:	eb 33                	jmp    8006d6 <timer+0x5c>
		if (r < 0)
  8006a3:	85 c0                	test   %eax,%eax
  8006a5:	78 45                	js     8006ec <timer+0x72>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8006a7:	6a 00                	push   $0x0
  8006a9:	6a 00                	push   $0x0
  8006ab:	6a 0c                	push   $0xc
  8006ad:	56                   	push   %esi
  8006ae:	e8 6f f2 00 00       	call   80f922 <ipc_send>
  8006b3:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006b6:	83 ec 04             	sub    $0x4,%esp
  8006b9:	6a 00                	push   $0x0
  8006bb:	6a 00                	push   $0x0
  8006bd:	57                   	push   %edi
  8006be:	e8 f2 f1 00 00       	call   80f8b5 <ipc_recv>
  8006c3:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006c8:	83 c4 10             	add    $0x10,%esp
  8006cb:	39 f0                	cmp    %esi,%eax
  8006cd:	75 2f                	jne    8006fe <timer+0x84>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006cf:	e8 e7 ee 00 00       	call   80f5bb <sys_time_msec>
  8006d4:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006d6:	e8 e0 ee 00 00       	call   80f5bb <sys_time_msec>
  8006db:	89 c2                	mov    %eax,%edx
  8006dd:	85 c0                	test   %eax,%eax
  8006df:	78 c2                	js     8006a3 <timer+0x29>
  8006e1:	39 d8                	cmp    %ebx,%eax
  8006e3:	73 be                	jae    8006a3 <timer+0x29>
			sys_yield();
  8006e5:	e8 84 ed 00 00       	call   80f46e <sys_yield>
  8006ea:	eb ea                	jmp    8006d6 <timer+0x5c>
			panic("sys_time_msec: %e", r);
  8006ec:	52                   	push   %edx
  8006ed:	68 b5 13 81 00       	push   $0x8113b5
  8006f2:	6a 0f                	push   $0xf
  8006f4:	68 c7 13 81 00       	push   $0x8113c7
  8006f9:	e8 39 e2 00 00       	call   80e937 <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006fe:	83 ec 08             	sub    $0x8,%esp
  800701:	50                   	push   %eax
  800702:	68 d4 13 81 00       	push   $0x8113d4
  800707:	e8 12 e3 00 00       	call   80ea1e <cprintf>
				continue;
  80070c:	83 c4 10             	add    $0x10,%esp
  80070f:	eb a5                	jmp    8006b6 <timer+0x3c>

00800711 <input>:
// 这里值得注意的一点是 有可能收包（sys_netpacket_recv）太快, 
// 发送给服务器时 服务器可能读取速度慢了 导致相应的内容被冲刷, 所以这里用一个临时存储
// 将收到的数据保存在input helper environment里
void
input(envid_t ns_envid)
{
  800711:	f3 0f 1e fb          	endbr32 
  800715:	55                   	push   %ebp
  800716:	89 e5                	mov    %esp,%ebp
  800718:	57                   	push   %edi
  800719:	56                   	push   %esi
  80071a:	53                   	push   %ebx
  80071b:	83 ec 0c             	sub    $0xc,%esp
  80071e:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_input";
  800721:	c7 05 e8 42 81 00 0f 	movl   $0x81140f,0x8142e8
  800728:	14 81 00 
  80072b:	bb 00 b0 fe 0f       	mov    $0xffeb000,%ebx
	int i, r;
	int32_t length;
	struct jif_pkt *cpkt = pkt;
	
	for(i = 0; i < 10; i++)
		if ((r = sys_page_alloc(0, (void*)((uintptr_t)pkt + i * PGSIZE), PTE_P | PTE_U | PTE_W)) < 0)
  800730:	83 ec 04             	sub    $0x4,%esp
  800733:	6a 07                	push   $0x7
  800735:	53                   	push   %ebx
  800736:	6a 00                	push   $0x0
  800738:	e8 54 ed 00 00       	call   80f491 <sys_page_alloc>
  80073d:	83 c4 10             	add    $0x10,%esp
  800740:	85 c0                	test   %eax,%eax
  800742:	78 1a                	js     80075e <input+0x4d>
  800744:	81 c3 00 10 00 00    	add    $0x1000,%ebx
	for(i = 0; i < 10; i++)
  80074a:	81 fb 00 50 ff 0f    	cmp    $0xfff5000,%ebx
  800750:	75 de                	jne    800730 <input+0x1f>
	struct jif_pkt *cpkt = pkt;
  800752:	be 00 b0 fe 0f       	mov    $0xffeb000,%esi
			panic("sys_page_alloc: %e", r);
	
	i = 0;
  800757:	bb 00 00 00 00       	mov    $0x0,%ebx
  80075c:	eb 17                	jmp    800775 <input+0x64>
			panic("sys_page_alloc: %e", r);
  80075e:	50                   	push   %eax
  80075f:	68 18 14 81 00       	push   $0x811418
  800764:	6a 34                	push   $0x34
  800766:	68 2b 14 81 00       	push   $0x81142b
  80076b:	e8 c7 e1 00 00       	call   80e937 <_panic>
	while(1) {
		while((length = sys_netpacket_recv((void*)((uintptr_t)cpkt + sizeof(cpkt->jp_len)), PGSIZE - sizeof(cpkt->jp_len))) < 0) {
			// cprintf("len: %d\n", length);
			sys_yield();
  800770:	e8 f9 ec 00 00       	call   80f46e <sys_yield>
		while((length = sys_netpacket_recv((void*)((uintptr_t)cpkt + sizeof(cpkt->jp_len)), PGSIZE - sizeof(cpkt->jp_len))) < 0) {
  800775:	83 ec 08             	sub    $0x8,%esp
  800778:	68 fc 0f 00 00       	push   $0xffc
  80077d:	8d 46 04             	lea    0x4(%esi),%eax
  800780:	50                   	push   %eax
  800781:	e8 7d ee 00 00       	call   80f603 <sys_netpacket_recv>
  800786:	83 c4 10             	add    $0x10,%esp
  800789:	85 c0                	test   %eax,%eax
  80078b:	78 e3                	js     800770 <input+0x5f>
		}

		cpkt->jp_len = length;
  80078d:	89 06                	mov    %eax,(%esi)
		ipc_send(ns_envid, NSREQ_INPUT, cpkt, PTE_P | PTE_U);
  80078f:	6a 05                	push   $0x5
  800791:	56                   	push   %esi
  800792:	6a 0a                	push   $0xa
  800794:	57                   	push   %edi
  800795:	e8 88 f1 00 00       	call   80f922 <ipc_send>
		i = (i + 1) % 10;
  80079a:	8d 4b 01             	lea    0x1(%ebx),%ecx
  80079d:	b8 67 66 66 66       	mov    $0x66666667,%eax
  8007a2:	f7 e9                	imul   %ecx
  8007a4:	c1 fa 02             	sar    $0x2,%edx
  8007a7:	89 c8                	mov    %ecx,%eax
  8007a9:	c1 f8 1f             	sar    $0x1f,%eax
  8007ac:	29 c2                	sub    %eax,%edx
  8007ae:	8d 04 92             	lea    (%edx,%edx,4),%eax
  8007b1:	01 c0                	add    %eax,%eax
  8007b3:	29 c1                	sub    %eax,%ecx
  8007b5:	89 cb                	mov    %ecx,%ebx
		cpkt = (struct jif_pkt*)((uintptr_t)pkt + i * PGSIZE);
  8007b7:	89 ce                	mov    %ecx,%esi
  8007b9:	c1 e6 0c             	shl    $0xc,%esi
  8007bc:	81 c6 00 b0 fe 0f    	add    $0xffeb000,%esi
		sys_yield();
  8007c2:	e8 a7 ec 00 00       	call   80f46e <sys_yield>
		while((length = sys_netpacket_recv((void*)((uintptr_t)cpkt + sizeof(cpkt->jp_len)), PGSIZE - sizeof(cpkt->jp_len))) < 0) {
  8007c7:	83 c4 10             	add    $0x10,%esp
  8007ca:	eb a9                	jmp    800775 <input+0x64>

008007cc <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8007cc:	f3 0f 1e fb          	endbr32 
  8007d0:	55                   	push   %ebp
  8007d1:	89 e5                	mov    %esp,%ebp
  8007d3:	56                   	push   %esi
  8007d4:	53                   	push   %ebx
  8007d5:	83 ec 10             	sub    $0x10,%esp
	binaryname = "ns_output";
  8007d8:	c7 05 e8 42 81 00 37 	movl   $0x811437,0x8142e8
  8007df:	14 81 00 
	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
	int perm; envid_t envid;
	while(1){
		if (ipc_recv(&envid, &nsipcbuf, &perm) != NSREQ_OUTPUT)
  8007e2:	8d 75 f4             	lea    -0xc(%ebp),%esi
  8007e5:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  8007e8:	eb 1f                	jmp    800809 <output+0x3d>
			continue;
		while(sys_netpacket_try_send(&nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)<0){
			// 说明tx_desc_ring还没准备/队列已满
			sys_yield();
  8007ea:	e8 7f ec 00 00       	call   80f46e <sys_yield>
		while(sys_netpacket_try_send(&nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)<0){
  8007ef:	83 ec 08             	sub    $0x8,%esp
  8007f2:	ff 35 00 d0 b3 00    	pushl  0xb3d000
  8007f8:	68 04 d0 b3 00       	push   $0xb3d004
  8007fd:	e8 dc ed 00 00       	call   80f5de <sys_netpacket_try_send>
  800802:	83 c4 10             	add    $0x10,%esp
  800805:	85 c0                	test   %eax,%eax
  800807:	78 e1                	js     8007ea <output+0x1e>
		if (ipc_recv(&envid, &nsipcbuf, &perm) != NSREQ_OUTPUT)
  800809:	83 ec 04             	sub    $0x4,%esp
  80080c:	56                   	push   %esi
  80080d:	68 00 d0 b3 00       	push   $0xb3d000
  800812:	53                   	push   %ebx
  800813:	e8 9d f0 00 00       	call   80f8b5 <ipc_recv>
  800818:	83 c4 10             	add    $0x10,%esp
  80081b:	83 f8 0b             	cmp    $0xb,%eax
  80081e:	75 e9                	jne    800809 <output+0x3d>
  800820:	eb cd                	jmp    8007ef <output+0x23>

00800822 <get_socket>:
static struct lwip_socket *
get_socket(int s)
{
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800822:	83 f8 1f             	cmp    $0x1f,%eax
  800825:	77 1b                	ja     800842 <get_socket+0x20>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  800827:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80082a:	8d 14 95 60 50 81 00 	lea    0x815060(,%edx,4),%edx

  if (!sock->conn) {
  800831:	8d 04 80             	lea    (%eax,%eax,4),%eax
  800834:	8b 04 85 60 50 81 00 	mov    0x815060(,%eax,4),%eax
  80083b:	85 c0                	test   %eax,%eax
  80083d:	74 14                	je     800853 <get_socket+0x31>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  80083f:	89 d0                	mov    %edx,%eax
  800841:	c3                   	ret    
    set_errno(EBADF);
  800842:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800849:	00 00 00 
    return NULL;
  80084c:	ba 00 00 00 00       	mov    $0x0,%edx
  800851:	eb ec                	jmp    80083f <get_socket+0x1d>
    set_errno(EBADF);
  800853:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  80085a:	00 00 00 
    return NULL;
  80085d:	89 c2                	mov    %eax,%edx
  80085f:	eb de                	jmp    80083f <get_socket+0x1d>

00800861 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800861:	55                   	push   %ebp
  800862:	89 e5                	mov    %esp,%ebp
  800864:	57                   	push   %edi
  800865:	56                   	push   %esi
  800866:	53                   	push   %ebx
  800867:	83 ec 40             	sub    $0x40,%esp
  80086a:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80086d:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800870:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800873:	6a 04                	push   $0x4
  800875:	6a 00                	push   $0x0
  800877:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80087a:	50                   	push   %eax
  80087b:	e8 5a e9 00 00       	call   80f1da <memset>
  FD_ZERO(&lwriteset);
  800880:	83 c4 0c             	add    $0xc,%esp
  800883:	6a 04                	push   $0x4
  800885:	6a 00                	push   $0x0
  800887:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80088a:	50                   	push   %eax
  80088b:	e8 4a e9 00 00       	call   80f1da <memset>
  FD_ZERO(&lexceptset);
  800890:	83 c4 0c             	add    $0xc,%esp
  800893:	6a 04                	push   $0x4
  800895:	6a 00                	push   $0x0
  800897:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80089a:	50                   	push   %eax
  80089b:	e8 3a e9 00 00       	call   80f1da <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8008a0:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  8008a3:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  8008aa:	bf 00 00 00 00       	mov    $0x0,%edi
  8008af:	eb 33                	jmp    8008e4 <lwip_selscan+0x83>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8008b1:	89 f8                	mov    %edi,%eax
  8008b3:	e8 6a ff ff ff       	call   800822 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8008b8:	85 c0                	test   %eax,%eax
  8008ba:	74 4c                	je     800908 <lwip_selscan+0xa7>
  8008bc:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8008c0:	74 16                	je     8008d8 <lwip_selscan+0x77>
        FD_SET(i, &lreadset);
  8008c2:	b8 01 00 00 00       	mov    $0x1,%eax
  8008c7:	89 f1                	mov    %esi,%ecx
  8008c9:	d3 e0                	shl    %cl,%eax
  8008cb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8008ce:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8008d2:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  8008d6:	eb 30                	jmp    800908 <lwip_selscan+0xa7>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8008d8:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8008dd:	74 29                	je     800908 <lwip_selscan+0xa7>
  8008df:	eb e1                	jmp    8008c2 <lwip_selscan+0x61>
  for(i = 0; i < maxfdp1; i++) {
  8008e1:	83 c7 01             	add    $0x1,%edi
  8008e4:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  8008e7:	7d 53                	jge    80093c <lwip_selscan+0xdb>
    if (FD_ISSET(i, readset)) {
  8008e9:	8d 5f 07             	lea    0x7(%edi),%ebx
  8008ec:	85 ff                	test   %edi,%edi
  8008ee:	0f 49 df             	cmovns %edi,%ebx
  8008f1:	c1 fb 03             	sar    $0x3,%ebx
  8008f4:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  8008f7:	89 fe                	mov    %edi,%esi
  8008f9:	83 e6 07             	and    $0x7,%esi
  8008fc:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8008ff:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800903:	0f a3 f0             	bt     %esi,%eax
  800906:	72 a9                	jb     8008b1 <lwip_selscan+0x50>
      }
    }
    if (FD_ISSET(i, writeset)) {
  800908:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80090b:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  80090f:	0f a3 f0             	bt     %esi,%eax
  800912:	73 cd                	jae    8008e1 <lwip_selscan+0x80>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800914:	89 f8                	mov    %edi,%eax
  800916:	e8 07 ff ff ff       	call   800822 <get_socket>
      if (p_sock && p_sock->sendevent) {
  80091b:	85 c0                	test   %eax,%eax
  80091d:	74 c2                	je     8008e1 <lwip_selscan+0x80>
  80091f:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800924:	74 bb                	je     8008e1 <lwip_selscan+0x80>
        FD_SET(i, &lwriteset);
  800926:	b8 01 00 00 00       	mov    $0x1,%eax
  80092b:	89 f1                	mov    %esi,%ecx
  80092d:	d3 e0                	shl    %cl,%eax
  80092f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800932:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800936:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  80093a:	eb a5                	jmp    8008e1 <lwip_selscan+0x80>
      }
    }
  }
  *readset = lreadset;
  80093c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80093f:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800942:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800944:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800947:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80094a:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  80094c:	83 ec 04             	sub    $0x4,%esp
  80094f:	6a 04                	push   $0x4
  800951:	6a 00                	push   $0x0
  800953:	ff 75 08             	pushl  0x8(%ebp)
  800956:	e8 7f e8 00 00       	call   80f1da <memset>
  
  return nready;
}
  80095b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80095e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800961:	5b                   	pop    %ebx
  800962:	5e                   	pop    %esi
  800963:	5f                   	pop    %edi
  800964:	5d                   	pop    %ebp
  800965:	c3                   	ret    

00800966 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800966:	55                   	push   %ebp
  800967:	89 e5                	mov    %esp,%ebp
  800969:	57                   	push   %edi
  80096a:	56                   	push   %esi
  80096b:	53                   	push   %ebx
  80096c:	83 ec 3c             	sub    $0x3c,%esp
  80096f:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800972:	89 ce                	mov    %ecx,%esi
  800974:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800977:	e8 a6 fe ff ff       	call   800822 <get_socket>
  if (!sock)
  80097c:	85 c0                	test   %eax,%eax
  80097e:	0f 84 86 00 00 00    	je     800a0a <lwip_getaddrname+0xa4>
  800984:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  800986:	83 ec 04             	sub    $0x4,%esp
  800989:	6a 10                	push   $0x10
  80098b:	6a 00                	push   $0x0
  80098d:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800990:	50                   	push   %eax
  800991:	e8 44 e8 00 00       	call   80f1da <memset>
  sin.sin_len = sizeof(sin);
  800996:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  80099a:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  80099e:	89 f8                	mov    %edi,%eax
  8009a0:	0f b6 f8             	movzbl %al,%edi
  8009a3:	57                   	push   %edi
  8009a4:	8d 45 da             	lea    -0x26(%ebp),%eax
  8009a7:	50                   	push   %eax
  8009a8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8009ab:	50                   	push   %eax
  8009ac:	ff 33                	pushl  (%ebx)
  8009ae:	e8 a3 a6 00 00       	call   80b056 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8009b3:	83 c4 14             	add    $0x14,%esp
  8009b6:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  8009ba:	50                   	push   %eax
  8009bb:	e8 93 6f 00 00       	call   807953 <htons>
  8009c0:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8009c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8009c7:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8009ca:	83 c4 10             	add    $0x10,%esp
  8009cd:	83 3e 10             	cmpl   $0x10,(%esi)
  8009d0:	76 06                	jbe    8009d8 <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8009d2:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  8009d8:	83 ec 04             	sub    $0x4,%esp
  8009db:	ff 36                	pushl  (%esi)
  8009dd:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8009e0:	50                   	push   %eax
  8009e1:	ff 75 c4             	pushl  -0x3c(%ebp)
  8009e4:	e8 a3 e8 00 00       	call   80f28c <memcpy>
  sock_set_errno(sock, 0);
  8009e9:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8009f0:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8009f7:	00 00 00 
  return 0;
  8009fa:	83 c4 10             	add    $0x10,%esp
  8009fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800a02:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800a05:	5b                   	pop    %ebx
  800a06:	5e                   	pop    %esi
  800a07:	5f                   	pop    %edi
  800a08:	5d                   	pop    %ebp
  800a09:	c3                   	ret    
    return -1;
  800a0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800a0f:	eb f1                	jmp    800a02 <lwip_getaddrname+0x9c>

00800a11 <event_callback>:
{
  800a11:	f3 0f 1e fb          	endbr32 
  800a15:	55                   	push   %ebp
  800a16:	89 e5                	mov    %esp,%ebp
  800a18:	57                   	push   %edi
  800a19:	56                   	push   %esi
  800a1a:	53                   	push   %ebx
  800a1b:	83 ec 1c             	sub    $0x1c,%esp
  800a1e:	8b 7d 08             	mov    0x8(%ebp),%edi
  800a21:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (conn) {
  800a24:	85 ff                	test   %edi,%edi
  800a26:	0f 84 80 01 00 00    	je     800bac <event_callback+0x19b>
    s = conn->socket;
  800a2c:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800a2f:	85 db                	test   %ebx,%ebx
  800a31:	78 3c                	js     800a6f <event_callback+0x5e>
    sock = get_socket(s);
  800a33:	89 d8                	mov    %ebx,%eax
  800a35:	e8 e8 fd ff ff       	call   800822 <get_socket>
  800a3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800a3d:	85 c0                	test   %eax,%eax
  800a3f:	0f 84 67 01 00 00    	je     800bac <event_callback+0x19b>
  sys_sem_wait(selectsem);
  800a45:	83 ec 0c             	sub    $0xc,%esp
  800a48:	ff 35 40 50 81 00    	pushl  0x815040
  800a4e:	e8 cd 48 00 00       	call   805320 <sys_sem_wait>
  switch (evt) {
  800a53:	83 c4 10             	add    $0x10,%esp
  800a56:	83 fe 02             	cmp    $0x2,%esi
  800a59:	0f 84 a0 00 00 00    	je     800aff <event_callback+0xee>
  800a5f:	77 59                	ja     800aba <event_callback+0xa9>
  800a61:	85 f6                	test   %esi,%esi
  800a63:	74 65                	je     800aca <event_callback+0xb9>
      sock->rcvevent--;
  800a65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a68:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800a6d:	eb 63                	jmp    800ad2 <event_callback+0xc1>
      sys_sem_wait(socksem);
  800a6f:	83 ec 0c             	sub    $0xc,%esp
  800a72:	ff 35 44 50 81 00    	pushl  0x815044
  800a78:	e8 a3 48 00 00       	call   805320 <sys_sem_wait>
      if (conn->socket < 0) {
  800a7d:	8b 47 1c             	mov    0x1c(%edi),%eax
  800a80:	83 c4 10             	add    $0x10,%esp
  800a83:	85 c0                	test   %eax,%eax
  800a85:	78 13                	js     800a9a <event_callback+0x89>
      sys_sem_signal(socksem);
  800a87:	83 ec 0c             	sub    $0xc,%esp
  800a8a:	ff 35 44 50 81 00    	pushl  0x815044
  800a90:	e8 d8 98 00 00       	call   80a36d <sys_sem_signal>
  800a95:	83 c4 10             	add    $0x10,%esp
  800a98:	eb 99                	jmp    800a33 <event_callback+0x22>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800a9a:	85 f6                	test   %esi,%esi
  800a9c:	75 06                	jne    800aa4 <event_callback+0x93>
          conn->socket--;
  800a9e:	83 e8 01             	sub    $0x1,%eax
  800aa1:	89 47 1c             	mov    %eax,0x1c(%edi)
        sys_sem_signal(socksem);
  800aa4:	83 ec 0c             	sub    $0xc,%esp
  800aa7:	ff 35 44 50 81 00    	pushl  0x815044
  800aad:	e8 bb 98 00 00       	call   80a36d <sys_sem_signal>
        return;
  800ab2:	83 c4 10             	add    $0x10,%esp
  800ab5:	e9 f2 00 00 00       	jmp    800bac <event_callback+0x19b>
  switch (evt) {
  800aba:	83 fe 03             	cmp    $0x3,%esi
  800abd:	75 4b                	jne    800b0a <event_callback+0xf9>
      sock->sendevent = 0;
  800abf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ac2:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800ac8:	eb 08                	jmp    800ad2 <event_callback+0xc1>
      sock->rcvevent++;
  800aca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800acd:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  800ad2:	83 ec 0c             	sub    $0xc,%esp
  800ad5:	ff 35 40 50 81 00    	pushl  0x815040
  800adb:	e8 8d 98 00 00       	call   80a36d <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800ae0:	8d 73 07             	lea    0x7(%ebx),%esi
  800ae3:	83 c4 10             	add    $0x10,%esp
  800ae6:	85 db                	test   %ebx,%ebx
  800ae8:	0f 49 f3             	cmovns %ebx,%esi
  800aeb:	c1 fe 03             	sar    $0x3,%esi
  800aee:	89 d9                	mov    %ebx,%ecx
  800af0:	83 e1 07             	and    $0x7,%ecx
  800af3:	bf 01 00 00 00       	mov    $0x1,%edi
  800af8:	d3 e7                	shl    %cl,%edi
  800afa:	e9 83 00 00 00       	jmp    800b82 <event_callback+0x171>
      sock->sendevent = 1;
  800aff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b02:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800b08:	eb c8                	jmp    800ad2 <event_callback+0xc1>
      LWIP_ASSERT("unknown event", 0);
  800b0a:	83 ec 04             	sub    $0x4,%esp
  800b0d:	68 41 14 81 00       	push   $0x811441
  800b12:	68 17 04 00 00       	push   $0x417
  800b17:	68 4f 14 81 00       	push   $0x81144f
  800b1c:	e8 16 de 00 00       	call   80e937 <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b21:	8b 1b                	mov    (%ebx),%ebx
  800b23:	85 db                	test   %ebx,%ebx
  800b25:	74 74                	je     800b9b <event_callback+0x18a>
      if (scb->sem_signalled == 0) {
  800b27:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800b2b:	75 f4                	jne    800b21 <event_callback+0x110>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800b2d:	8b 43 04             	mov    0x4(%ebx),%eax
  800b30:	85 c0                	test   %eax,%eax
  800b32:	74 12                	je     800b46 <event_callback+0x135>
  800b34:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b38:	85 f8                	test   %edi,%eax
  800b3a:	74 0a                	je     800b46 <event_callback+0x135>
          if (sock->rcvevent)
  800b3c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b3f:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800b44:	75 19                	jne    800b5f <event_callback+0x14e>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800b46:	8b 43 08             	mov    0x8(%ebx),%eax
  800b49:	85 c0                	test   %eax,%eax
  800b4b:	74 d4                	je     800b21 <event_callback+0x110>
  800b4d:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b51:	85 f8                	test   %edi,%eax
  800b53:	74 cc                	je     800b21 <event_callback+0x110>
          if (sock->sendevent)
  800b55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b58:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800b5d:	74 c2                	je     800b21 <event_callback+0x110>
      scb->sem_signalled = 1;
  800b5f:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800b66:	83 ec 0c             	sub    $0xc,%esp
  800b69:	ff 35 40 50 81 00    	pushl  0x815040
  800b6f:	e8 f9 97 00 00       	call   80a36d <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800b74:	83 c4 04             	add    $0x4,%esp
  800b77:	ff 73 14             	pushl  0x14(%ebx)
  800b7a:	e8 ee 97 00 00       	call   80a36d <sys_sem_signal>
    sys_sem_wait(selectsem);
  800b7f:	83 c4 10             	add    $0x10,%esp
  800b82:	83 ec 0c             	sub    $0xc,%esp
  800b85:	ff 35 40 50 81 00    	pushl  0x815040
  800b8b:	e8 90 47 00 00       	call   805320 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b90:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800b96:	83 c4 10             	add    $0x10,%esp
  800b99:	eb 88                	jmp    800b23 <event_callback+0x112>
      sys_sem_signal(selectsem);
  800b9b:	83 ec 0c             	sub    $0xc,%esp
  800b9e:	ff 35 40 50 81 00    	pushl  0x815040
  800ba4:	e8 c4 97 00 00       	call   80a36d <sys_sem_signal>
      break;
  800ba9:	83 c4 10             	add    $0x10,%esp
}
  800bac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800baf:	5b                   	pop    %ebx
  800bb0:	5e                   	pop    %esi
  800bb1:	5f                   	pop    %edi
  800bb2:	5d                   	pop    %ebp
  800bb3:	c3                   	ret    

00800bb4 <alloc_socket>:
{
  800bb4:	55                   	push   %ebp
  800bb5:	89 e5                	mov    %esp,%ebp
  800bb7:	56                   	push   %esi
  800bb8:	53                   	push   %ebx
  800bb9:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800bbb:	83 ec 0c             	sub    $0xc,%esp
  800bbe:	ff 35 44 50 81 00    	pushl  0x815044
  800bc4:	e8 57 47 00 00       	call   805320 <sys_sem_wait>
  800bc9:	b8 60 50 81 00       	mov    $0x815060,%eax
  800bce:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800bd1:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800bd6:	83 38 00             	cmpl   $0x0,(%eax)
  800bd9:	74 23                	je     800bfe <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800bdb:	83 c3 01             	add    $0x1,%ebx
  800bde:	83 c0 14             	add    $0x14,%eax
  800be1:	83 fb 20             	cmp    $0x20,%ebx
  800be4:	75 f0                	jne    800bd6 <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800be6:	83 ec 0c             	sub    $0xc,%esp
  800be9:	ff 35 44 50 81 00    	pushl  0x815044
  800bef:	e8 79 97 00 00       	call   80a36d <sys_sem_signal>
  return -1;
  800bf4:	83 c4 10             	add    $0x10,%esp
  800bf7:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800bfc:	eb 55                	jmp    800c53 <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800bfe:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800c01:	c1 e2 02             	shl    $0x2,%edx
  800c04:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800c0a:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800c11:	00 00 00 
      sockets[i].lastoffset = 0;
  800c14:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800c1b:	00 00 
      sockets[i].rcvevent   = 0;
  800c1d:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800c24:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800c26:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800c2d:	01 00 
      sockets[i].flags      = 0;
  800c2f:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800c36:	00 00 
      sockets[i].err        = 0;
  800c38:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800c3f:	00 00 00 
      sys_sem_signal(socksem);
  800c42:	83 ec 0c             	sub    $0xc,%esp
  800c45:	ff 35 44 50 81 00    	pushl  0x815044
  800c4b:	e8 1d 97 00 00       	call   80a36d <sys_sem_signal>
      return i;
  800c50:	83 c4 10             	add    $0x10,%esp
}
  800c53:	89 d8                	mov    %ebx,%eax
  800c55:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800c58:	5b                   	pop    %ebx
  800c59:	5e                   	pop    %esi
  800c5a:	5d                   	pop    %ebp
  800c5b:	c3                   	ret    

00800c5c <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800c5c:	f3 0f 1e fb          	endbr32 
  800c60:	55                   	push   %ebp
  800c61:	89 e5                	mov    %esp,%ebp
  800c63:	56                   	push   %esi
  800c64:	53                   	push   %ebx
  800c65:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800c68:	85 c0                	test   %eax,%eax
  800c6a:	74 3b                	je     800ca7 <lwip_getsockopt_internal+0x4b>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800c6c:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800c6e:	8b 48 08             	mov    0x8(%eax),%ecx
  optname = data->optname;
  800c71:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800c74:	8b 70 10             	mov    0x10(%eax),%esi

  switch (level) {
  800c77:	83 f9 06             	cmp    $0x6,%ecx
  800c7a:	0f 84 39 01 00 00    	je     800db9 <lwip_getsockopt_internal+0x15d>
  800c80:	81 f9 ff 0f 00 00    	cmp    $0xfff,%ecx
  800c86:	74 36                	je     800cbe <lwip_getsockopt_internal+0x62>
  800c88:	85 c9                	test   %ecx,%ecx
  800c8a:	0f 84 fb 00 00 00    	je     800d8b <lwip_getsockopt_internal+0x12f>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800c90:	83 ec 0c             	sub    $0xc,%esp
  800c93:	8b 03                	mov    (%ebx),%eax
  800c95:	ff 70 10             	pushl  0x10(%eax)
  800c98:	e8 d0 96 00 00       	call   80a36d <sys_sem_signal>
}
  800c9d:	83 c4 10             	add    $0x10,%esp
  800ca0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800ca3:	5b                   	pop    %ebx
  800ca4:	5e                   	pop    %esi
  800ca5:	5d                   	pop    %ebp
  800ca6:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800ca7:	83 ec 04             	sub    $0x4,%esp
  800caa:	68 66 14 81 00       	push   $0x811466
  800caf:	68 38 05 00 00       	push   $0x538
  800cb4:	68 4f 14 81 00       	push   $0x81144f
  800cb9:	e8 79 dc 00 00       	call   80e937 <_panic>
  800cbe:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800cc4:	0f 84 88 00 00 00    	je     800d52 <lwip_getsockopt_internal+0xf6>
  800cca:	7e 20                	jle    800cec <lwip_getsockopt_internal+0x90>
  800ccc:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800cd2:	74 40                	je     800d14 <lwip_getsockopt_internal+0xb8>
  800cd4:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800cda:	75 b4                	jne    800c90 <lwip_getsockopt_internal+0x34>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800cdc:	8b 03                	mov    (%ebx),%eax
  800cde:	8b 40 08             	mov    0x8(%eax),%eax
  800ce1:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800ce5:	83 e0 01             	and    $0x1,%eax
  800ce8:	89 06                	mov    %eax,(%esi)
      break;
  800cea:	eb a4                	jmp    800c90 <lwip_getsockopt_internal+0x34>
  800cec:	8d 4a fe             	lea    -0x2(%edx),%ecx
  800cef:	83 f9 1e             	cmp    $0x1e,%ecx
  800cf2:	77 9c                	ja     800c90 <lwip_getsockopt_internal+0x34>
  800cf4:	b8 01 00 00 00       	mov    $0x1,%eax
  800cf9:	d3 e0                	shl    %cl,%eax
  800cfb:	a9 41 00 00 40       	test   $0x40000041,%eax
  800d00:	74 8e                	je     800c90 <lwip_getsockopt_internal+0x34>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800d02:	8b 03                	mov    (%ebx),%eax
  800d04:	8b 40 08             	mov    0x8(%eax),%eax
  800d07:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800d0b:	21 c2                	and    %eax,%edx
  800d0d:	89 16                	mov    %edx,(%esi)
      break;
  800d0f:	e9 7c ff ff ff       	jmp    800c90 <lwip_getsockopt_internal+0x34>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800d14:	8b 03                	mov    (%ebx),%eax
  800d16:	8b 00                	mov    (%eax),%eax
  800d18:	89 c2                	mov    %eax,%edx
  800d1a:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  800d20:	83 fa 20             	cmp    $0x20,%edx
  800d23:	74 22                	je     800d47 <lwip_getsockopt_internal+0xeb>
  800d25:	83 fa 40             	cmp    $0x40,%edx
  800d28:	74 12                	je     800d3c <lwip_getsockopt_internal+0xe0>
        *(int*)optval = sock->conn->type;
  800d2a:	83 fa 10             	cmp    $0x10,%edx
  800d2d:	ba 01 00 00 00       	mov    $0x1,%edx
  800d32:	0f 44 c2             	cmove  %edx,%eax
  800d35:	89 06                	mov    %eax,(%esi)
  800d37:	e9 54 ff ff ff       	jmp    800c90 <lwip_getsockopt_internal+0x34>
        *(int*)optval = SOCK_RAW;
  800d3c:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
        break;
  800d42:	e9 49 ff ff ff       	jmp    800c90 <lwip_getsockopt_internal+0x34>
        *(int*)optval = SOCK_DGRAM;
  800d47:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
        break;
  800d4d:	e9 3e ff ff ff       	jmp    800c90 <lwip_getsockopt_internal+0x34>
      if (sock->err == 0) {
  800d52:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800d56:	75 22                	jne    800d7a <lwip_getsockopt_internal+0x11e>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800d58:	8b 03                	mov    (%ebx),%eax
  800d5a:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800d5e:	f7 d8                	neg    %eax
  800d60:	ba 05 00 00 00       	mov    $0x5,%edx
  800d65:	83 f8 0e             	cmp    $0xe,%eax
  800d68:	77 07                	ja     800d71 <lwip_getsockopt_internal+0x115>
  800d6a:	8b 14 85 20 15 81 00 	mov    0x811520(,%eax,4),%edx
  800d71:	89 53 10             	mov    %edx,0x10(%ebx)
  800d74:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
      *(int *)optval = sock->err;
  800d7a:	8b 43 10             	mov    0x10(%ebx),%eax
  800d7d:	89 06                	mov    %eax,(%esi)
      sock->err = 0;
  800d7f:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      break;
  800d86:	e9 05 ff ff ff       	jmp    800c90 <lwip_getsockopt_internal+0x34>
  800d8b:	83 fa 01             	cmp    $0x1,%edx
  800d8e:	74 19                	je     800da9 <lwip_getsockopt_internal+0x14d>
  800d90:	83 fa 02             	cmp    $0x2,%edx
  800d93:	0f 85 f7 fe ff ff    	jne    800c90 <lwip_getsockopt_internal+0x34>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800d99:	8b 03                	mov    (%ebx),%eax
  800d9b:	8b 40 08             	mov    0x8(%eax),%eax
  800d9e:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800da2:	89 06                	mov    %eax,(%esi)
      break;
  800da4:	e9 e7 fe ff ff       	jmp    800c90 <lwip_getsockopt_internal+0x34>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800da9:	8b 03                	mov    (%ebx),%eax
  800dab:	8b 40 08             	mov    0x8(%eax),%eax
  800dae:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800db2:	89 06                	mov    %eax,(%esi)
      break;
  800db4:	e9 d7 fe ff ff       	jmp    800c90 <lwip_getsockopt_internal+0x34>
  800db9:	83 fa 01             	cmp    $0x1,%edx
  800dbc:	74 1b                	je     800dd9 <lwip_getsockopt_internal+0x17d>
  800dbe:	83 fa 02             	cmp    $0x2,%edx
  800dc1:	0f 85 c9 fe ff ff    	jne    800c90 <lwip_getsockopt_internal+0x34>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800dc7:	8b 03                	mov    (%ebx),%eax
  800dc9:	8b 40 08             	mov    0x8(%eax),%eax
  800dcc:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800dd2:	89 06                	mov    %eax,(%esi)
      break;
  800dd4:	e9 b7 fe ff ff       	jmp    800c90 <lwip_getsockopt_internal+0x34>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800dd9:	8b 03                	mov    (%ebx),%eax
  800ddb:	8b 40 08             	mov    0x8(%eax),%eax
  800dde:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800de2:	83 e0 40             	and    $0x40,%eax
  800de5:	0f b6 c0             	movzbl %al,%eax
  800de8:	89 06                	mov    %eax,(%esi)
      break;
  800dea:	e9 a1 fe ff ff       	jmp    800c90 <lwip_getsockopt_internal+0x34>

00800def <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800def:	f3 0f 1e fb          	endbr32 
  800df3:	55                   	push   %ebp
  800df4:	89 e5                	mov    %esp,%ebp
  800df6:	53                   	push   %ebx
  800df7:	83 ec 04             	sub    $0x4,%esp
  800dfa:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800dfd:	85 c0                	test   %eax,%eax
  800dff:	74 35                	je     800e36 <lwip_setsockopt_internal+0x47>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800e01:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800e03:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800e06:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800e09:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800e0c:	83 fa 06             	cmp    $0x6,%edx
  800e0f:	0f 84 aa 00 00 00    	je     800ebf <lwip_setsockopt_internal+0xd0>
  800e15:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800e1b:	74 30                	je     800e4d <lwip_setsockopt_internal+0x5e>
  800e1d:	85 d2                	test   %edx,%edx
  800e1f:	74 76                	je     800e97 <lwip_setsockopt_internal+0xa8>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800e21:	83 ec 0c             	sub    $0xc,%esp
  800e24:	8b 03                	mov    (%ebx),%eax
  800e26:	ff 70 10             	pushl  0x10(%eax)
  800e29:	e8 3f 95 00 00       	call   80a36d <sys_sem_signal>
}
  800e2e:	83 c4 10             	add    $0x10,%esp
  800e31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800e34:	c9                   	leave  
  800e35:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800e36:	83 ec 04             	sub    $0x4,%esp
  800e39:	68 66 14 81 00       	push   $0x811466
  800e3e:	68 ae 06 00 00       	push   $0x6ae
  800e43:	68 4f 14 81 00       	push   $0x81144f
  800e48:	e8 ea da 00 00       	call   80e937 <_panic>
  800e4d:	83 f9 20             	cmp    $0x20,%ecx
  800e50:	74 0d                	je     800e5f <lwip_setsockopt_internal+0x70>
  800e52:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800e58:	74 22                	je     800e7c <lwip_setsockopt_internal+0x8d>
  800e5a:	83 f9 08             	cmp    $0x8,%ecx
  800e5d:	75 c2                	jne    800e21 <lwip_setsockopt_internal+0x32>
      if (*(int*)optval) {
  800e5f:	83 38 00             	cmpl   $0x0,(%eax)
  800e62:	74 0b                	je     800e6f <lwip_setsockopt_internal+0x80>
        sock->conn->pcb.ip->so_options |= optname;
  800e64:	8b 03                	mov    (%ebx),%eax
  800e66:	8b 40 08             	mov    0x8(%eax),%eax
  800e69:	66 09 48 08          	or     %cx,0x8(%eax)
  800e6d:	eb b2                	jmp    800e21 <lwip_setsockopt_internal+0x32>
        sock->conn->pcb.ip->so_options &= ~optname;
  800e6f:	8b 03                	mov    (%ebx),%eax
  800e71:	8b 40 08             	mov    0x8(%eax),%eax
  800e74:	f7 d1                	not    %ecx
  800e76:	66 21 48 08          	and    %cx,0x8(%eax)
  800e7a:	eb a5                	jmp    800e21 <lwip_setsockopt_internal+0x32>
      if (*(int*)optval) {
  800e7c:	83 38 00             	cmpl   $0x0,(%eax)
  800e7f:	74 0b                	je     800e8c <lwip_setsockopt_internal+0x9d>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800e81:	8b 03                	mov    (%ebx),%eax
  800e83:	8b 40 08             	mov    0x8(%eax),%eax
  800e86:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800e8a:	eb 95                	jmp    800e21 <lwip_setsockopt_internal+0x32>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800e8c:	8b 03                	mov    (%ebx),%eax
  800e8e:	8b 40 08             	mov    0x8(%eax),%eax
  800e91:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800e95:	eb 8a                	jmp    800e21 <lwip_setsockopt_internal+0x32>
  800e97:	83 f9 01             	cmp    $0x1,%ecx
  800e9a:	74 14                	je     800eb0 <lwip_setsockopt_internal+0xc1>
  800e9c:	83 f9 02             	cmp    $0x2,%ecx
  800e9f:	75 80                	jne    800e21 <lwip_setsockopt_internal+0x32>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800ea1:	8b 13                	mov    (%ebx),%edx
  800ea3:	8b 52 08             	mov    0x8(%edx),%edx
  800ea6:	8b 00                	mov    (%eax),%eax
  800ea8:	88 42 0b             	mov    %al,0xb(%edx)
      break;
  800eab:	e9 71 ff ff ff       	jmp    800e21 <lwip_setsockopt_internal+0x32>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800eb0:	8b 13                	mov    (%ebx),%edx
  800eb2:	8b 52 08             	mov    0x8(%edx),%edx
  800eb5:	8b 00                	mov    (%eax),%eax
  800eb7:	88 42 0a             	mov    %al,0xa(%edx)
      break;
  800eba:	e9 62 ff ff ff       	jmp    800e21 <lwip_setsockopt_internal+0x32>
  800ebf:	83 f9 01             	cmp    $0x1,%ecx
  800ec2:	74 1b                	je     800edf <lwip_setsockopt_internal+0xf0>
  800ec4:	83 f9 02             	cmp    $0x2,%ecx
  800ec7:	0f 85 54 ff ff ff    	jne    800e21 <lwip_setsockopt_internal+0x32>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800ecd:	8b 13                	mov    (%ebx),%edx
  800ecf:	8b 52 08             	mov    0x8(%edx),%edx
  800ed2:	8b 00                	mov    (%eax),%eax
  800ed4:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
  800eda:	e9 42 ff ff ff       	jmp    800e21 <lwip_setsockopt_internal+0x32>
      if (*(int*)optval) {
  800edf:	83 38 00             	cmpl   $0x0,(%eax)
  800ee2:	74 0e                	je     800ef2 <lwip_setsockopt_internal+0x103>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800ee4:	8b 03                	mov    (%ebx),%eax
  800ee6:	8b 40 08             	mov    0x8(%eax),%eax
  800ee9:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800eed:	e9 2f ff ff ff       	jmp    800e21 <lwip_setsockopt_internal+0x32>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800ef2:	8b 03                	mov    (%ebx),%eax
  800ef4:	8b 40 08             	mov    0x8(%eax),%eax
  800ef7:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800efb:	e9 21 ff ff ff       	jmp    800e21 <lwip_setsockopt_internal+0x32>

00800f00 <lwip_socket_init>:
{
  800f00:	f3 0f 1e fb          	endbr32 
  800f04:	55                   	push   %ebp
  800f05:	89 e5                	mov    %esp,%ebp
  800f07:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800f0a:	6a 01                	push   $0x1
  800f0c:	e8 8f 91 00 00       	call   80a0a0 <sys_sem_new>
  800f11:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800f16:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800f1d:	e8 7e 91 00 00       	call   80a0a0 <sys_sem_new>
  800f22:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800f27:	83 c4 10             	add    $0x10,%esp
  800f2a:	c9                   	leave  
  800f2b:	c3                   	ret    

00800f2c <lwip_accept>:
{
  800f2c:	f3 0f 1e fb          	endbr32 
  800f30:	55                   	push   %ebp
  800f31:	89 e5                	mov    %esp,%ebp
  800f33:	57                   	push   %edi
  800f34:	56                   	push   %esi
  800f35:	53                   	push   %ebx
  800f36:	83 ec 3c             	sub    $0x3c,%esp
  800f39:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  800f3c:	8b 45 08             	mov    0x8(%ebp),%eax
  800f3f:	e8 de f8 ff ff       	call   800822 <get_socket>
  if (!sock)
  800f44:	85 c0                	test   %eax,%eax
  800f46:	0f 84 8c 01 00 00    	je     8010d8 <lwip_accept+0x1ac>
  800f4c:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  800f4e:	83 ec 0c             	sub    $0xc,%esp
  800f51:	ff 30                	pushl  (%eax)
  800f53:	e8 c8 a2 00 00       	call   80b220 <netconn_accept>
  800f58:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800f5a:	83 c4 10             	add    $0x10,%esp
  800f5d:	85 c0                	test   %eax,%eax
  800f5f:	0f 84 de 00 00 00    	je     801043 <lwip_accept+0x117>
  err = netconn_peer(newconn, &naddr, &port);
  800f65:	6a 00                	push   $0x0
  800f67:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800f6a:	50                   	push   %eax
  800f6b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800f6e:	50                   	push   %eax
  800f6f:	53                   	push   %ebx
  800f70:	e8 e1 a0 00 00       	call   80b056 <netconn_getaddr>
  800f75:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800f78:	83 c4 10             	add    $0x10,%esp
  800f7b:	84 c0                	test   %al,%al
  800f7d:	0f 85 e9 00 00 00    	jne    80106c <lwip_accept+0x140>
  memset(&sin, 0, sizeof(sin));
  800f83:	83 ec 04             	sub    $0x4,%esp
  800f86:	6a 10                	push   $0x10
  800f88:	6a 00                	push   $0x0
  800f8a:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f8d:	50                   	push   %eax
  800f8e:	e8 47 e2 00 00       	call   80f1da <memset>
  sin.sin_len = sizeof(sin);
  800f93:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800f97:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800f9b:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800f9f:	89 04 24             	mov    %eax,(%esp)
  800fa2:	e8 ac 69 00 00       	call   807953 <htons>
  800fa7:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800fab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800fae:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  800fb1:	83 c4 10             	add    $0x10,%esp
  800fb4:	83 3f 10             	cmpl   $0x10,(%edi)
  800fb7:	76 06                	jbe    800fbf <lwip_accept+0x93>
    *addrlen = sizeof(sin);
  800fb9:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  800fbf:	83 ec 04             	sub    $0x4,%esp
  800fc2:	ff 37                	pushl  (%edi)
  800fc4:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800fc7:	50                   	push   %eax
  800fc8:	ff 75 0c             	pushl  0xc(%ebp)
  800fcb:	e8 bc e2 00 00       	call   80f28c <memcpy>
  newsock = alloc_socket(newconn);
  800fd0:	89 d8                	mov    %ebx,%eax
  800fd2:	e8 dd fb ff ff       	call   800bb4 <alloc_socket>
  800fd7:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800fd9:	83 c4 10             	add    $0x10,%esp
  800fdc:	83 f8 ff             	cmp    $0xffffffff,%eax
  800fdf:	0f 84 ba 00 00 00    	je     80109f <lwip_accept+0x173>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800fe5:	83 f8 1f             	cmp    $0x1f,%eax
  800fe8:	0f 87 d3 00 00 00    	ja     8010c1 <lwip_accept+0x195>
  newconn->callback = event_callback;
  800fee:	c7 43 2c 11 0a 80 00 	movl   $0x800a11,0x2c(%ebx)
  sys_sem_wait(socksem);
  800ff5:	83 ec 0c             	sub    $0xc,%esp
  800ff8:	ff 35 44 50 81 00    	pushl  0x815044
  800ffe:	e8 1d 43 00 00       	call   805320 <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  801003:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  801006:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  80100a:	f7 d2                	not    %edx
  80100c:	66 01 14 85 6a 50 81 	add    %dx,0x81506a(,%eax,4)
  801013:	00 
  newconn->socket = newsock;
  801014:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  801017:	83 c4 04             	add    $0x4,%esp
  80101a:	ff 35 44 50 81 00    	pushl  0x815044
  801020:	e8 48 93 00 00       	call   80a36d <sys_sem_signal>
  sock_set_errno(sock, 0);
  801025:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  80102c:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801033:	00 00 00 
  return newsock;
  801036:	83 c4 10             	add    $0x10,%esp
}
  801039:	89 f8                	mov    %edi,%eax
  80103b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80103e:	5b                   	pop    %ebx
  80103f:	5e                   	pop    %esi
  801040:	5f                   	pop    %edi
  801041:	5d                   	pop    %ebp
  801042:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  801043:	8b 06                	mov    (%esi),%eax
  801045:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  801049:	f7 d8                	neg    %eax
  80104b:	ba 05 00 00 00       	mov    $0x5,%edx
  801050:	83 f8 0e             	cmp    $0xe,%eax
  801053:	77 07                	ja     80105c <lwip_accept+0x130>
  801055:	8b 14 85 20 15 81 00 	mov    0x811520(,%eax,4),%edx
  80105c:	89 56 10             	mov    %edx,0x10(%esi)
  80105f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801065:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80106a:	eb cd                	jmp    801039 <lwip_accept+0x10d>
    netconn_delete(newconn);
  80106c:	83 ec 0c             	sub    $0xc,%esp
  80106f:	53                   	push   %ebx
  801070:	e8 71 9f 00 00       	call   80afe6 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  801075:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  801079:	f7 d8                	neg    %eax
  80107b:	83 c4 10             	add    $0x10,%esp
  80107e:	ba 05 00 00 00       	mov    $0x5,%edx
  801083:	83 f8 0e             	cmp    $0xe,%eax
  801086:	77 07                	ja     80108f <lwip_accept+0x163>
  801088:	8b 14 85 20 15 81 00 	mov    0x811520(,%eax,4),%edx
  80108f:	89 56 10             	mov    %edx,0x10(%esi)
  801092:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801098:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80109d:	eb 9a                	jmp    801039 <lwip_accept+0x10d>
    netconn_delete(newconn);
  80109f:	83 ec 0c             	sub    $0xc,%esp
  8010a2:	53                   	push   %ebx
  8010a3:	e8 3e 9f 00 00       	call   80afe6 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  8010a8:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  8010af:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  8010b6:	00 00 00 
    return -1;
  8010b9:	83 c4 10             	add    $0x10,%esp
  8010bc:	e9 78 ff ff ff       	jmp    801039 <lwip_accept+0x10d>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  8010c1:	83 ec 04             	sub    $0x4,%esp
  8010c4:	68 72 14 81 00       	push   $0x811472
  8010c9:	68 25 01 00 00       	push   $0x125
  8010ce:	68 4f 14 81 00       	push   $0x81144f
  8010d3:	e8 5f d8 00 00       	call   80e937 <_panic>
    return -1;
  8010d8:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  8010dd:	e9 57 ff ff ff       	jmp    801039 <lwip_accept+0x10d>

008010e2 <lwip_bind>:
{
  8010e2:	f3 0f 1e fb          	endbr32 
  8010e6:	55                   	push   %ebp
  8010e7:	89 e5                	mov    %esp,%ebp
  8010e9:	56                   	push   %esi
  8010ea:	53                   	push   %ebx
  8010eb:	83 ec 10             	sub    $0x10,%esp
  8010ee:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  8010f1:	8b 45 08             	mov    0x8(%ebp),%eax
  8010f4:	e8 29 f7 ff ff       	call   800822 <get_socket>
  if (!sock)
  8010f9:	85 c0                	test   %eax,%eax
  8010fb:	0f 84 94 00 00 00    	je     801195 <lwip_bind+0xb3>
  801101:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801103:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801107:	75 4f                	jne    801158 <lwip_bind+0x76>
  801109:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80110d:	75 49                	jne    801158 <lwip_bind+0x76>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80110f:	8b 46 04             	mov    0x4(%esi),%eax
  801112:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  801115:	83 ec 0c             	sub    $0xc,%esp
  801118:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80111c:	50                   	push   %eax
  80111d:	e8 42 68 00 00       	call   807964 <ntohs>
  801122:	83 c4 0c             	add    $0xc,%esp
  801125:	0f b7 c0             	movzwl %ax,%eax
  801128:	50                   	push   %eax
  801129:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80112c:	50                   	push   %eax
  80112d:	ff 33                	pushl  (%ebx)
  80112f:	e8 b2 9f 00 00       	call   80b0e6 <netconn_bind>
  if (err != ERR_OK) {
  801134:	83 c4 10             	add    $0x10,%esp
  801137:	84 c0                	test   %al,%al
  801139:	75 34                	jne    80116f <lwip_bind+0x8d>
  sock_set_errno(sock, 0);
  80113b:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801142:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801149:	00 00 00 
  return 0;
  80114c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801151:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801154:	5b                   	pop    %ebx
  801155:	5e                   	pop    %esi
  801156:	5d                   	pop    %ebp
  801157:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801158:	83 ec 04             	sub    $0x4,%esp
  80115b:	68 87 14 81 00       	push   $0x811487
  801160:	68 48 01 00 00       	push   $0x148
  801165:	68 4f 14 81 00       	push   $0x81144f
  80116a:	e8 c8 d7 00 00       	call   80e937 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  80116f:	0f be c0             	movsbl %al,%eax
  801172:	f7 d8                	neg    %eax
  801174:	ba 05 00 00 00       	mov    $0x5,%edx
  801179:	83 f8 0e             	cmp    $0xe,%eax
  80117c:	77 07                	ja     801185 <lwip_bind+0xa3>
  80117e:	8b 14 85 20 15 81 00 	mov    0x811520(,%eax,4),%edx
  801185:	89 53 10             	mov    %edx,0x10(%ebx)
  801188:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80118e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801193:	eb bc                	jmp    801151 <lwip_bind+0x6f>
    return -1;
  801195:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80119a:	eb b5                	jmp    801151 <lwip_bind+0x6f>

0080119c <lwip_close>:
{
  80119c:	f3 0f 1e fb          	endbr32 
  8011a0:	55                   	push   %ebp
  8011a1:	89 e5                	mov    %esp,%ebp
  8011a3:	53                   	push   %ebx
  8011a4:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  8011a7:	8b 45 08             	mov    0x8(%ebp),%eax
  8011aa:	e8 73 f6 ff ff       	call   800822 <get_socket>
  if (!sock) {
  8011af:	85 c0                	test   %eax,%eax
  8011b1:	74 6f                	je     801222 <lwip_close+0x86>
  8011b3:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  8011b5:	83 ec 0c             	sub    $0xc,%esp
  8011b8:	ff 30                	pushl  (%eax)
  8011ba:	e8 27 9e 00 00       	call   80afe6 <netconn_delete>
  sys_sem_wait(socksem);
  8011bf:	83 c4 04             	add    $0x4,%esp
  8011c2:	ff 35 44 50 81 00    	pushl  0x815044
  8011c8:	e8 53 41 00 00       	call   805320 <sys_sem_wait>
  if (sock->lastdata) {
  8011cd:	8b 43 04             	mov    0x4(%ebx),%eax
  8011d0:	83 c4 10             	add    $0x10,%esp
  8011d3:	85 c0                	test   %eax,%eax
  8011d5:	74 0c                	je     8011e3 <lwip_close+0x47>
    netbuf_delete(sock->lastdata);
  8011d7:	83 ec 0c             	sub    $0xc,%esp
  8011da:	50                   	push   %eax
  8011db:	e8 1b 14 00 00       	call   8025fb <netbuf_delete>
  8011e0:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  8011e3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  8011ea:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8011f0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8011f6:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8011fd:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801204:	00 00 00 
  sys_sem_signal(socksem);
  801207:	83 ec 0c             	sub    $0xc,%esp
  80120a:	ff 35 44 50 81 00    	pushl  0x815044
  801210:	e8 58 91 00 00       	call   80a36d <sys_sem_signal>
  return 0;
  801215:	83 c4 10             	add    $0x10,%esp
  801218:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80121d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  801220:	c9                   	leave  
  801221:	c3                   	ret    
    return -1;
  801222:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801227:	eb f4                	jmp    80121d <lwip_close+0x81>

00801229 <lwip_connect>:
{
  801229:	f3 0f 1e fb          	endbr32 
  80122d:	55                   	push   %ebp
  80122e:	89 e5                	mov    %esp,%ebp
  801230:	56                   	push   %esi
  801231:	53                   	push   %ebx
  801232:	83 ec 10             	sub    $0x10,%esp
  801235:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  801238:	8b 45 08             	mov    0x8(%ebp),%eax
  80123b:	e8 e2 f5 ff ff       	call   800822 <get_socket>
  if (!sock)
  801240:	85 c0                	test   %eax,%eax
  801242:	0f 84 94 00 00 00    	je     8012dc <lwip_connect+0xb3>
  801248:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80124a:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80124e:	75 4f                	jne    80129f <lwip_connect+0x76>
  801250:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801254:	75 49                	jne    80129f <lwip_connect+0x76>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801256:	8b 46 04             	mov    0x4(%esi),%eax
  801259:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80125c:	83 ec 0c             	sub    $0xc,%esp
  80125f:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801263:	50                   	push   %eax
  801264:	e8 fb 66 00 00       	call   807964 <ntohs>
  801269:	83 c4 0c             	add    $0xc,%esp
  80126c:	0f b7 c0             	movzwl %ax,%eax
  80126f:	50                   	push   %eax
  801270:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801273:	50                   	push   %eax
  801274:	ff 33                	pushl  (%ebx)
  801276:	e8 c0 9e 00 00       	call   80b13b <netconn_connect>
  if (err != ERR_OK) {
  80127b:	83 c4 10             	add    $0x10,%esp
  80127e:	84 c0                	test   %al,%al
  801280:	75 34                	jne    8012b6 <lwip_connect+0x8d>
  sock_set_errno(sock, 0);
  801282:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801289:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801290:	00 00 00 
  return 0;
  801293:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801298:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80129b:	5b                   	pop    %ebx
  80129c:	5e                   	pop    %esi
  80129d:	5d                   	pop    %ebp
  80129e:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80129f:	83 ec 04             	sub    $0x4,%esp
  8012a2:	68 a2 14 81 00       	push   $0x8114a2
  8012a7:	68 84 01 00 00       	push   $0x184
  8012ac:	68 4f 14 81 00       	push   $0x81144f
  8012b1:	e8 81 d6 00 00       	call   80e937 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  8012b6:	0f be c0             	movsbl %al,%eax
  8012b9:	f7 d8                	neg    %eax
  8012bb:	ba 05 00 00 00       	mov    $0x5,%edx
  8012c0:	83 f8 0e             	cmp    $0xe,%eax
  8012c3:	77 07                	ja     8012cc <lwip_connect+0xa3>
  8012c5:	8b 14 85 20 15 81 00 	mov    0x811520(,%eax,4),%edx
  8012cc:	89 53 10             	mov    %edx,0x10(%ebx)
  8012cf:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8012d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012da:	eb bc                	jmp    801298 <lwip_connect+0x6f>
    return -1;
  8012dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012e1:	eb b5                	jmp    801298 <lwip_connect+0x6f>

008012e3 <lwip_listen>:
{
  8012e3:	f3 0f 1e fb          	endbr32 
  8012e7:	55                   	push   %ebp
  8012e8:	89 e5                	mov    %esp,%ebp
  8012ea:	56                   	push   %esi
  8012eb:	53                   	push   %ebx
  8012ec:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  8012ef:	8b 45 08             	mov    0x8(%ebp),%eax
  8012f2:	e8 2b f5 ff ff       	call   800822 <get_socket>
  if (!sock)
  8012f7:	85 c0                	test   %eax,%eax
  8012f9:	74 6f                	je     80136a <lwip_listen+0x87>
  8012fb:	89 c6                	mov    %eax,%esi
  8012fd:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  801303:	b8 ff 00 00 00       	mov    $0xff,%eax
  801308:	0f 4f d8             	cmovg  %eax,%ebx
  err = netconn_listen_with_backlog(sock->conn, backlog);
  80130b:	83 ec 08             	sub    $0x8,%esp
  80130e:	85 db                	test   %ebx,%ebx
  801310:	b8 00 00 00 00       	mov    $0x0,%eax
  801315:	0f 48 d8             	cmovs  %eax,%ebx
  801318:	53                   	push   %ebx
  801319:	ff 36                	pushl  (%esi)
  80131b:	e8 b8 9e 00 00       	call   80b1d8 <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  801320:	83 c4 10             	add    $0x10,%esp
  801323:	84 c0                	test   %al,%al
  801325:	75 1d                	jne    801344 <lwip_listen+0x61>
  sock_set_errno(sock, 0);
  801327:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  80132e:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801335:	00 00 00 
  return 0;
  801338:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80133d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801340:	5b                   	pop    %ebx
  801341:	5e                   	pop    %esi
  801342:	5d                   	pop    %ebp
  801343:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  801344:	0f be c0             	movsbl %al,%eax
  801347:	f7 d8                	neg    %eax
  801349:	ba 05 00 00 00       	mov    $0x5,%edx
  80134e:	83 f8 0e             	cmp    $0xe,%eax
  801351:	77 07                	ja     80135a <lwip_listen+0x77>
  801353:	8b 14 85 20 15 81 00 	mov    0x811520(,%eax,4),%edx
  80135a:	89 56 10             	mov    %edx,0x10(%esi)
  80135d:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801363:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801368:	eb d3                	jmp    80133d <lwip_listen+0x5a>
    return -1;
  80136a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80136f:	eb cc                	jmp    80133d <lwip_listen+0x5a>

00801371 <lwip_recvfrom>:
{
  801371:	f3 0f 1e fb          	endbr32 
  801375:	55                   	push   %ebp
  801376:	89 e5                	mov    %esp,%ebp
  801378:	57                   	push   %edi
  801379:	56                   	push   %esi
  80137a:	53                   	push   %ebx
  80137b:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  80137e:	8b 45 08             	mov    0x8(%ebp),%eax
  801381:	e8 9c f4 ff ff       	call   800822 <get_socket>
  if (!sock)
  801386:	85 c0                	test   %eax,%eax
  801388:	0f 84 22 02 00 00    	je     8015b0 <lwip_recvfrom+0x23f>
  80138e:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  801390:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801396:	8b 45 14             	mov    0x14(%ebp),%eax
  801399:	83 e0 08             	and    $0x8,%eax
  80139c:	89 45 b8             	mov    %eax,-0x48(%ebp)
  80139f:	e9 a7 00 00 00       	jmp    80144b <lwip_recvfrom+0xda>
  8013a4:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  8013a8:	75 06                	jne    8013b0 <lwip_recvfrom+0x3f>
  8013aa:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  8013ae:	74 07                	je     8013b7 <lwip_recvfrom+0x46>
  8013b0:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8013b5:	74 56                	je     80140d <lwip_recvfrom+0x9c>
      sock->lastdata = buf = netconn_recv(sock->conn);
  8013b7:	83 ec 0c             	sub    $0xc,%esp
  8013ba:	ff 37                	pushl  (%edi)
  8013bc:	e8 d5 9e 00 00       	call   80b296 <netconn_recv>
  8013c1:	89 c6                	mov    %eax,%esi
  8013c3:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  8013c6:	83 c4 10             	add    $0x10,%esp
  8013c9:	85 c0                	test   %eax,%eax
  8013cb:	0f 85 85 00 00 00    	jne    801456 <lwip_recvfrom+0xe5>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8013d1:	8b 17                	mov    (%edi),%edx
  8013d3:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  8013d7:	74 0b                	je     8013e4 <lwip_recvfrom+0x73>
  8013d9:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8013de:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8013e2:	74 17                	je     8013fb <lwip_recvfrom+0x8a>
  8013e4:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8013e8:	f7 da                	neg    %edx
  8013ea:	b8 05 00 00 00       	mov    $0x5,%eax
  8013ef:	83 fa 0e             	cmp    $0xe,%edx
  8013f2:	77 07                	ja     8013fb <lwip_recvfrom+0x8a>
  8013f4:	8b 04 95 20 15 81 00 	mov    0x811520(,%edx,4),%eax
  8013fb:	89 47 10             	mov    %eax,0x10(%edi)
  8013fe:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  801403:	b8 00 00 00 00       	mov    $0x0,%eax
  801408:	e9 0b 01 00 00       	jmp    801518 <lwip_recvfrom+0x1a7>
        sock_set_errno(sock, EWOULDBLOCK);
  80140d:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  801414:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  80141b:	00 00 00 
        return -1;
  80141e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801423:	e9 f0 00 00 00       	jmp    801518 <lwip_recvfrom+0x1a7>
        sock->lastdata = NULL;
  801428:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  80142f:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  801435:	83 ec 0c             	sub    $0xc,%esp
  801438:	56                   	push   %esi
  801439:	e8 bd 11 00 00       	call   8025fb <netbuf_delete>
  80143e:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  801441:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  801445:	0f 85 ac 00 00 00    	jne    8014f7 <lwip_recvfrom+0x186>
    if (sock->lastdata) {
  80144b:	8b 77 04             	mov    0x4(%edi),%esi
  80144e:	85 f6                	test   %esi,%esi
  801450:	0f 84 4e ff ff ff    	je     8013a4 <lwip_recvfrom+0x33>
    buflen = netbuf_len(buf);
  801456:	8b 16                	mov    (%esi),%edx
  801458:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
    buflen -= sock->lastoffset;
  80145c:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  801460:	89 cb                	mov    %ecx,%ebx
  801462:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  801464:	0f b7 db             	movzwl %bx,%ebx
  801467:	89 5d bc             	mov    %ebx,-0x44(%ebp)
      copylen = len;
  80146a:	29 c1                	sub    %eax,%ecx
  80146c:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  80146f:	66 0f 4d 4d 10       	cmovge 0x10(%ebp),%cx
  801474:	89 cb                	mov    %ecx,%ebx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  801476:	0f b7 c9             	movzwl %cx,%ecx
  801479:	0f b7 c0             	movzwl %ax,%eax
  80147c:	50                   	push   %eax
  80147d:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801480:	51                   	push   %ecx
  801481:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  801485:	03 45 0c             	add    0xc(%ebp),%eax
  801488:	50                   	push   %eax
  801489:	52                   	push   %edx
  80148a:	e8 15 3d 00 00       	call   8051a4 <pbuf_copy_partial>
    off += copylen;
  80148f:	66 01 5d c4          	add    %bx,-0x3c(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801493:	83 c4 04             	add    $0x4,%esp
  801496:	ff 37                	pushl  (%edi)
  801498:	e8 8d 9b 00 00       	call   80b02a <netconn_type>
  80149d:	83 c4 10             	add    $0x10,%esp
      done = 1;
  8014a0:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8014a4:	83 f8 10             	cmp    $0x10,%eax
  8014a7:	75 23                	jne    8014cc <lwip_recvfrom+0x15b>
      len -= copylen;
  8014a9:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  8014ac:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8014af:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8014b3:	7e 17                	jle    8014cc <lwip_recvfrom+0x15b>
  8014b5:	8b 06                	mov    (%esi),%eax
  8014b7:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
  8014bb:	83 e0 01             	and    $0x1,%eax
  8014be:	88 45 c7             	mov    %al,-0x39(%ebp)
  8014c1:	75 09                	jne    8014cc <lwip_recvfrom+0x15b>
  8014c3:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8014c8:	0f 94 45 c7          	sete   -0x39(%ebp)
    if ((flags & MSG_PEEK)==0) {
  8014cc:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  8014d0:	75 25                	jne    8014f7 <lwip_recvfrom+0x186>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8014d2:	8b 07                	mov    (%edi),%eax
  8014d4:	83 38 10             	cmpl   $0x10,(%eax)
  8014d7:	0f 85 4b ff ff ff    	jne    801428 <lwip_recvfrom+0xb7>
  8014dd:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8014e0:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8014e3:	85 c0                	test   %eax,%eax
  8014e5:	0f 8e 3d ff ff ff    	jle    801428 <lwip_recvfrom+0xb7>
        sock->lastdata = buf;
  8014eb:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8014ee:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8014f2:	e9 4a ff ff ff       	jmp    801441 <lwip_recvfrom+0xd0>
  if (from && fromlen) {
  8014f7:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8014fb:	74 06                	je     801503 <lwip_recvfrom+0x192>
  8014fd:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801501:	75 1d                	jne    801520 <lwip_recvfrom+0x1af>
  sock_set_errno(sock, 0);
  801503:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  80150a:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801511:	00 00 00 
  return off;
  801514:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
}
  801518:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80151b:	5b                   	pop    %ebx
  80151c:	5e                   	pop    %esi
  80151d:	5f                   	pop    %edi
  80151e:	5d                   	pop    %ebp
  80151f:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801520:	83 ec 0c             	sub    $0xc,%esp
  801523:	ff 37                	pushl  (%edi)
  801525:	e8 00 9b 00 00       	call   80b02a <netconn_type>
  80152a:	83 c4 10             	add    $0x10,%esp
  80152d:	83 f8 10             	cmp    $0x10,%eax
  801530:	74 65                	je     801597 <lwip_recvfrom+0x226>
      addr = netbuf_fromaddr(buf);
  801532:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  801535:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  801539:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  80153d:	83 ec 04             	sub    $0x4,%esp
  801540:	6a 10                	push   $0x10
  801542:	6a 00                	push   $0x0
  801544:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801547:	50                   	push   %eax
  801548:	e8 8d dc 00 00       	call   80f1da <memset>
    sin.sin_len = sizeof(sin);
  80154d:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  801551:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  801555:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  801559:	89 04 24             	mov    %eax,(%esp)
  80155c:	e8 f2 63 00 00       	call   807953 <htons>
  801561:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  801565:	8b 03                	mov    (%ebx),%eax
  801567:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  80156a:	83 c4 10             	add    $0x10,%esp
  80156d:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801570:	83 38 10             	cmpl   $0x10,(%eax)
  801573:	76 06                	jbe    80157b <lwip_recvfrom+0x20a>
      *fromlen = sizeof(sin);
  801575:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  80157b:	83 ec 04             	sub    $0x4,%esp
  80157e:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801581:	ff 30                	pushl  (%eax)
  801583:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801586:	50                   	push   %eax
  801587:	ff 75 18             	pushl  0x18(%ebp)
  80158a:	e8 fd dc 00 00       	call   80f28c <memcpy>
  80158f:	83 c4 10             	add    $0x10,%esp
  801592:	e9 6c ff ff ff       	jmp    801503 <lwip_recvfrom+0x192>
      netconn_getaddr(sock->conn, addr, &port, 0);
  801597:	6a 00                	push   $0x0
  801599:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  80159c:	50                   	push   %eax
  80159d:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8015a0:	50                   	push   %eax
  8015a1:	ff 37                	pushl  (%edi)
  8015a3:	e8 ae 9a 00 00       	call   80b056 <netconn_getaddr>
  8015a8:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8015ab:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  8015ae:	eb 8d                	jmp    80153d <lwip_recvfrom+0x1cc>
    return -1;
  8015b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8015b5:	e9 5e ff ff ff       	jmp    801518 <lwip_recvfrom+0x1a7>

008015ba <lwip_read>:
{
  8015ba:	f3 0f 1e fb          	endbr32 
  8015be:	55                   	push   %ebp
  8015bf:	89 e5                	mov    %esp,%ebp
  8015c1:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8015c4:	6a 00                	push   $0x0
  8015c6:	6a 00                	push   $0x0
  8015c8:	6a 00                	push   $0x0
  8015ca:	ff 75 10             	pushl  0x10(%ebp)
  8015cd:	ff 75 0c             	pushl  0xc(%ebp)
  8015d0:	ff 75 08             	pushl  0x8(%ebp)
  8015d3:	e8 99 fd ff ff       	call   801371 <lwip_recvfrom>
}
  8015d8:	c9                   	leave  
  8015d9:	c3                   	ret    

008015da <lwip_recv>:
{
  8015da:	f3 0f 1e fb          	endbr32 
  8015de:	55                   	push   %ebp
  8015df:	89 e5                	mov    %esp,%ebp
  8015e1:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8015e4:	6a 00                	push   $0x0
  8015e6:	6a 00                	push   $0x0
  8015e8:	ff 75 14             	pushl  0x14(%ebp)
  8015eb:	ff 75 10             	pushl  0x10(%ebp)
  8015ee:	ff 75 0c             	pushl  0xc(%ebp)
  8015f1:	ff 75 08             	pushl  0x8(%ebp)
  8015f4:	e8 78 fd ff ff       	call   801371 <lwip_recvfrom>
}
  8015f9:	c9                   	leave  
  8015fa:	c3                   	ret    

008015fb <lwip_sendto>:
{
  8015fb:	f3 0f 1e fb          	endbr32 
  8015ff:	55                   	push   %ebp
  801600:	89 e5                	mov    %esp,%ebp
  801602:	57                   	push   %edi
  801603:	56                   	push   %esi
  801604:	53                   	push   %ebx
  801605:	83 ec 2c             	sub    $0x2c,%esp
  801608:	8b 75 10             	mov    0x10(%ebp),%esi
  80160b:	8b 7d 18             	mov    0x18(%ebp),%edi
  sock = get_socket(s);
  80160e:	8b 45 08             	mov    0x8(%ebp),%eax
  801611:	e8 0c f2 ff ff       	call   800822 <get_socket>
  if (!sock)
  801616:	85 c0                	test   %eax,%eax
  801618:	0f 84 28 01 00 00    	je     801746 <lwip_sendto+0x14b>
  80161e:	89 c3                	mov    %eax,%ebx
  if (sock->conn->type==NETCONN_TCP) {
  801620:	8b 00                	mov    (%eax),%eax
  801622:	83 38 10             	cmpl   $0x10,(%eax)
  801625:	0f 84 be 00 00 00    	je     8016e9 <lwip_sendto+0xee>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  80162b:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  801631:	0f 87 c8 00 00 00    	ja     8016ff <lwip_sendto+0x104>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801637:	89 f8                	mov    %edi,%eax
  801639:	0b 45 1c             	or     0x1c(%ebp),%eax
  80163c:	0f 84 0b 01 00 00    	je     80174d <lwip_sendto+0x152>
  801642:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  801646:	0f 85 ca 00 00 00    	jne    801716 <lwip_sendto+0x11b>
  80164c:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  801650:	0f 85 c0 00 00 00    	jne    801716 <lwip_sendto+0x11b>
  buf.p = buf.ptr = NULL;
  801656:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80165d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  801664:	8b 47 04             	mov    0x4(%edi),%eax
  801667:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  80166a:	83 ec 0c             	sub    $0xc,%esp
  80166d:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  801671:	50                   	push   %eax
  801672:	e8 ed 62 00 00       	call   807964 <ntohs>
    buf.addr         = &remote_addr;
  801677:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80167a:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80167d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  801681:	83 c4 10             	add    $0x10,%esp
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801684:	83 ec 04             	sub    $0x4,%esp
  801687:	0f b7 c6             	movzwl %si,%eax
  80168a:	50                   	push   %eax
  80168b:	ff 75 0c             	pushl  0xc(%ebp)
  80168e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801691:	50                   	push   %eax
  801692:	e8 6b 10 00 00       	call   802702 <netbuf_ref>
  801697:	0f be f8             	movsbl %al,%edi
  80169a:	83 c4 10             	add    $0x10,%esp
  80169d:	85 ff                	test   %edi,%edi
  80169f:	0f 84 88 00 00 00    	je     80172d <lwip_sendto+0x132>
  if (buf.p != NULL) {
  8016a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8016a8:	85 c0                	test   %eax,%eax
  8016aa:	74 0c                	je     8016b8 <lwip_sendto+0xbd>
    pbuf_free(buf.p);
  8016ac:	83 ec 0c             	sub    $0xc,%esp
  8016af:	50                   	push   %eax
  8016b0:	e8 66 33 00 00       	call   804a1b <pbuf_free>
  8016b5:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  8016b8:	89 fa                	mov    %edi,%edx
  8016ba:	f7 da                	neg    %edx
  8016bc:	b8 05 00 00 00       	mov    $0x5,%eax
  8016c1:	83 fa 0e             	cmp    $0xe,%edx
  8016c4:	77 07                	ja     8016cd <lwip_sendto+0xd2>
  8016c6:	8b 04 95 20 15 81 00 	mov    0x811520(,%edx,4),%eax
  8016cd:	89 43 10             	mov    %eax,0x10(%ebx)
  8016d0:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8016d5:	85 ff                	test   %edi,%edi
  8016d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016dc:	0f 45 f0             	cmovne %eax,%esi
}
  8016df:	89 f0                	mov    %esi,%eax
  8016e1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8016e4:	5b                   	pop    %ebx
  8016e5:	5e                   	pop    %esi
  8016e6:	5f                   	pop    %edi
  8016e7:	5d                   	pop    %ebp
  8016e8:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  8016e9:	ff 75 14             	pushl  0x14(%ebp)
  8016ec:	56                   	push   %esi
  8016ed:	ff 75 0c             	pushl  0xc(%ebp)
  8016f0:	ff 75 08             	pushl  0x8(%ebp)
  8016f3:	e8 7c 00 00 00       	call   801774 <lwip_send>
  8016f8:	89 c6                	mov    %eax,%esi
  8016fa:	83 c4 10             	add    $0x10,%esp
  8016fd:	eb e0                	jmp    8016df <lwip_sendto+0xe4>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8016ff:	83 ec 04             	sub    $0x4,%esp
  801702:	68 e0 14 81 00       	push   $0x8114e0
  801707:	68 96 02 00 00       	push   $0x296
  80170c:	68 4f 14 81 00       	push   $0x81144f
  801711:	e8 21 d2 00 00       	call   80e937 <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801716:	83 ec 04             	sub    $0x4,%esp
  801719:	68 c0 14 81 00       	push   $0x8114c0
  80171e:	68 98 02 00 00       	push   $0x298
  801723:	68 4f 14 81 00       	push   $0x81144f
  801728:	e8 0a d2 00 00       	call   80e937 <_panic>
    err = netconn_send(sock->conn, &buf);
  80172d:	83 ec 08             	sub    $0x8,%esp
  801730:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801733:	50                   	push   %eax
  801734:	ff 33                	pushl  (%ebx)
  801736:	e8 f4 9c 00 00       	call   80b42f <netconn_send>
  80173b:	0f be f8             	movsbl %al,%edi
  80173e:	83 c4 10             	add    $0x10,%esp
  801741:	e9 5f ff ff ff       	jmp    8016a5 <lwip_sendto+0xaa>
    return -1;
  801746:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80174b:	eb 92                	jmp    8016df <lwip_sendto+0xe4>
  buf.p = buf.ptr = NULL;
  80174d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801754:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = 0;
  80175b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    buf.addr         = NULL;
  801762:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801769:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  80176f:	e9 10 ff ff ff       	jmp    801684 <lwip_sendto+0x89>

00801774 <lwip_send>:
{
  801774:	f3 0f 1e fb          	endbr32 
  801778:	55                   	push   %ebp
  801779:	89 e5                	mov    %esp,%ebp
  80177b:	57                   	push   %edi
  80177c:	56                   	push   %esi
  80177d:	53                   	push   %ebx
  80177e:	83 ec 0c             	sub    $0xc,%esp
  801781:	8b 7d 08             	mov    0x8(%ebp),%edi
  801784:	8b 75 10             	mov    0x10(%ebp),%esi
  sock = get_socket(s);
  801787:	89 f8                	mov    %edi,%eax
  801789:	e8 94 f0 ff ff       	call   800822 <get_socket>
  if (!sock)
  80178e:	85 c0                	test   %eax,%eax
  801790:	74 70                	je     801802 <lwip_send+0x8e>
  801792:	89 c3                	mov    %eax,%ebx
  if (sock->conn->type!=NETCONN_TCP) {
  801794:	8b 10                	mov    (%eax),%edx
  801796:	83 3a 10             	cmpl   $0x10,(%edx)
  801799:	74 1f                	je     8017ba <lwip_send+0x46>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  80179b:	83 ec 08             	sub    $0x8,%esp
  80179e:	6a 00                	push   $0x0
  8017a0:	6a 00                	push   $0x0
  8017a2:	ff 75 14             	pushl  0x14(%ebp)
  8017a5:	56                   	push   %esi
  8017a6:	ff 75 0c             	pushl  0xc(%ebp)
  8017a9:	57                   	push   %edi
  8017aa:	e8 4c fe ff ff       	call   8015fb <lwip_sendto>
  8017af:	83 c4 20             	add    $0x20,%esp
}
  8017b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8017b5:	5b                   	pop    %ebx
  8017b6:	5e                   	pop    %esi
  8017b7:	5f                   	pop    %edi
  8017b8:	5d                   	pop    %ebp
  8017b9:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  8017ba:	8b 45 14             	mov    0x14(%ebp),%eax
  8017bd:	c1 e8 03             	shr    $0x3,%eax
  8017c0:	83 e0 02             	and    $0x2,%eax
  8017c3:	83 c8 01             	or     $0x1,%eax
  8017c6:	0f b6 c0             	movzbl %al,%eax
  8017c9:	50                   	push   %eax
  8017ca:	56                   	push   %esi
  8017cb:	ff 75 0c             	pushl  0xc(%ebp)
  8017ce:	52                   	push   %edx
  8017cf:	e8 df 9c 00 00       	call   80b4b3 <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  8017d4:	0f be d0             	movsbl %al,%edx
  8017d7:	f7 da                	neg    %edx
  8017d9:	83 c4 10             	add    $0x10,%esp
  8017dc:	b9 05 00 00 00       	mov    $0x5,%ecx
  8017e1:	83 fa 0e             	cmp    $0xe,%edx
  8017e4:	77 07                	ja     8017ed <lwip_send+0x79>
  8017e6:	8b 0c 95 20 15 81 00 	mov    0x811520(,%edx,4),%ecx
  8017ed:	89 4b 10             	mov    %ecx,0x10(%ebx)
  8017f0:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8017f6:	84 c0                	test   %al,%al
  8017f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017fd:	0f 44 c6             	cmove  %esi,%eax
  801800:	eb b0                	jmp    8017b2 <lwip_send+0x3e>
    return -1;
  801802:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801807:	eb a9                	jmp    8017b2 <lwip_send+0x3e>

00801809 <lwip_socket>:
{
  801809:	f3 0f 1e fb          	endbr32 
  80180d:	55                   	push   %ebp
  80180e:	89 e5                	mov    %esp,%ebp
  801810:	56                   	push   %esi
  801811:	53                   	push   %ebx
  801812:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  801815:	83 f8 02             	cmp    $0x2,%eax
  801818:	74 5c                	je     801876 <lwip_socket+0x6d>
  80181a:	83 f8 03             	cmp    $0x3,%eax
  80181d:	74 16                	je     801835 <lwip_socket+0x2c>
  80181f:	83 f8 01             	cmp    $0x1,%eax
  801822:	74 79                	je     80189d <lwip_socket+0x94>
    set_errno(EINVAL);
  801824:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  80182b:	00 00 00 
    return -1;
  80182e:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801833:	eb 38                	jmp    80186d <lwip_socket+0x64>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  801835:	83 ec 04             	sub    $0x4,%esp
  801838:	68 11 0a 80 00       	push   $0x800a11
  80183d:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801841:	50                   	push   %eax
  801842:	6a 40                	push   $0x40
  801844:	e8 be 96 00 00       	call   80af07 <netconn_new_with_proto_and_callback>
  801849:	89 c6                	mov    %eax,%esi
    break;
  80184b:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  80184e:	85 f6                	test   %esi,%esi
  801850:	74 63                	je     8018b5 <lwip_socket+0xac>
  i = alloc_socket(conn);
  801852:	89 f0                	mov    %esi,%eax
  801854:	e8 5b f3 ff ff       	call   800bb4 <alloc_socket>
  801859:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  80185b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80185e:	74 66                	je     8018c6 <lwip_socket+0xbd>
  conn->socket = i;
  801860:	89 46 1c             	mov    %eax,0x1c(%esi)
  set_errno(0);
  801863:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80186a:	00 00 00 
}
  80186d:	89 d8                	mov    %ebx,%eax
  80186f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801872:	5b                   	pop    %ebx
  801873:	5e                   	pop    %esi
  801874:	5d                   	pop    %ebp
  801875:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  801876:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  80187d:	0f 94 c0             	sete   %al
  801880:	0f b6 c0             	movzbl %al,%eax
  801883:	83 c0 20             	add    $0x20,%eax
  801886:	83 ec 04             	sub    $0x4,%esp
  801889:	68 11 0a 80 00       	push   $0x800a11
  80188e:	6a 00                	push   $0x0
  801890:	50                   	push   %eax
  801891:	e8 71 96 00 00       	call   80af07 <netconn_new_with_proto_and_callback>
  801896:	89 c6                	mov    %eax,%esi
    break;
  801898:	83 c4 10             	add    $0x10,%esp
  80189b:	eb b1                	jmp    80184e <lwip_socket+0x45>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  80189d:	83 ec 04             	sub    $0x4,%esp
  8018a0:	68 11 0a 80 00       	push   $0x800a11
  8018a5:	6a 00                	push   $0x0
  8018a7:	6a 10                	push   $0x10
  8018a9:	e8 59 96 00 00       	call   80af07 <netconn_new_with_proto_and_callback>
  8018ae:	89 c6                	mov    %eax,%esi
    break;
  8018b0:	83 c4 10             	add    $0x10,%esp
  8018b3:	eb 99                	jmp    80184e <lwip_socket+0x45>
    set_errno(ENOBUFS);
  8018b5:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  8018bc:	00 00 00 
    return -1;
  8018bf:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  8018c4:	eb a7                	jmp    80186d <lwip_socket+0x64>
    netconn_delete(conn);
  8018c6:	83 ec 0c             	sub    $0xc,%esp
  8018c9:	56                   	push   %esi
  8018ca:	e8 17 97 00 00       	call   80afe6 <netconn_delete>
    set_errno(ENFILE);
  8018cf:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  8018d6:	00 00 00 
    return -1;
  8018d9:	83 c4 10             	add    $0x10,%esp
  8018dc:	eb 8f                	jmp    80186d <lwip_socket+0x64>

008018de <lwip_write>:
{
  8018de:	f3 0f 1e fb          	endbr32 
  8018e2:	55                   	push   %ebp
  8018e3:	89 e5                	mov    %esp,%ebp
  8018e5:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  8018e8:	6a 00                	push   $0x0
  8018ea:	ff 75 10             	pushl  0x10(%ebp)
  8018ed:	ff 75 0c             	pushl  0xc(%ebp)
  8018f0:	ff 75 08             	pushl  0x8(%ebp)
  8018f3:	e8 7c fe ff ff       	call   801774 <lwip_send>
}
  8018f8:	c9                   	leave  
  8018f9:	c3                   	ret    

008018fa <lwip_select>:
{
  8018fa:	f3 0f 1e fb          	endbr32 
  8018fe:	55                   	push   %ebp
  8018ff:	89 e5                	mov    %esp,%ebp
  801901:	57                   	push   %edi
  801902:	56                   	push   %esi
  801903:	53                   	push   %ebx
  801904:	83 ec 58             	sub    $0x58,%esp
  801907:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80190a:	8b 75 10             	mov    0x10(%ebp),%esi
  80190d:	8b 7d 14             	mov    0x14(%ebp),%edi
  select_cb.next = 0;
  801910:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801917:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  select_cb.writeset = writeset;
  80191a:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  80191d:	89 7d d0             	mov    %edi,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801920:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  801927:	ff 35 40 50 81 00    	pushl  0x815040
  80192d:	e8 ee 39 00 00       	call   805320 <sys_sem_wait>
  if (readset)
  801932:	83 c4 10             	add    $0x10,%esp
  801935:	85 db                	test   %ebx,%ebx
  801937:	0f 84 0b 01 00 00    	je     801a48 <lwip_select+0x14e>
    lreadset = *readset;
  80193d:	8b 03                	mov    (%ebx),%eax
  80193f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  801942:	85 f6                	test   %esi,%esi
  801944:	0f 84 16 01 00 00    	je     801a60 <lwip_select+0x166>
    lwriteset = *writeset;
  80194a:	8b 06                	mov    (%esi),%eax
  80194c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  80194f:	85 ff                	test   %edi,%edi
  801951:	0f 84 21 01 00 00    	je     801a78 <lwip_select+0x17e>
    lexceptset = *exceptset;
  801957:	8b 07                	mov    (%edi),%eax
  801959:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  80195c:	83 ec 0c             	sub    $0xc,%esp
  80195f:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801962:	50                   	push   %eax
  801963:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801966:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801969:	8b 45 08             	mov    0x8(%ebp),%eax
  80196c:	e8 f0 ee ff ff       	call   800861 <lwip_selscan>
  801971:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  801974:	83 c4 10             	add    $0x10,%esp
  801977:	85 c0                	test   %eax,%eax
  801979:	0f 85 a0 02 00 00    	jne    801c1f <lwip_select+0x325>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  80197f:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801983:	0f 84 ac 02 00 00    	je     801c35 <lwip_select+0x33b>
  801989:	8b 45 18             	mov    0x18(%ebp),%eax
  80198c:	83 38 00             	cmpl   $0x0,(%eax)
  80198f:	75 0e                	jne    80199f <lwip_select+0xa5>
  801991:	8b 40 04             	mov    0x4(%eax),%eax
  801994:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801997:	85 c0                	test   %eax,%eax
  801999:	0f 84 f1 00 00 00    	je     801a90 <lwip_select+0x196>
    select_cb.sem = sys_sem_new(0);
  80199f:	83 ec 0c             	sub    $0xc,%esp
  8019a2:	6a 00                	push   $0x0
  8019a4:	e8 f7 86 00 00       	call   80a0a0 <sys_sem_new>
  8019a9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  8019ac:	a1 48 50 81 00       	mov    0x815048,%eax
  8019b1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  8019b4:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  8019b7:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  8019bc:	83 c4 04             	add    $0x4,%esp
  8019bf:	ff 35 40 50 81 00    	pushl  0x815040
  8019c5:	e8 a3 89 00 00       	call   80a36d <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  8019ca:	8b 45 18             	mov    0x18(%ebp),%eax
  8019cd:	8b 40 04             	mov    0x4(%eax),%eax
  8019d0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  8019d3:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  8019d9:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8019de:	89 c8                	mov    %ecx,%eax
  8019e0:	f7 ea                	imul   %edx
  8019e2:	c1 fa 06             	sar    $0x6,%edx
  8019e5:	c1 f9 1f             	sar    $0x1f,%ecx
  8019e8:	29 ca                	sub    %ecx,%edx
  8019ea:	8b 45 18             	mov    0x18(%ebp),%eax
  8019ed:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
  8019f3:	83 c4 10             	add    $0x10,%esp
  8019f6:	01 d0                	add    %edx,%eax
  8019f8:	ba 01 00 00 00       	mov    $0x1,%edx
  8019fd:	0f 44 c2             	cmove  %edx,%eax
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801a00:	83 ec 08             	sub    $0x8,%esp
  801a03:	50                   	push   %eax
  801a04:	ff 75 d8             	pushl  -0x28(%ebp)
  801a07:	e8 ee 3a 00 00       	call   8054fa <sys_sem_wait_timeout>
  801a0c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  801a0f:	83 c4 04             	add    $0x4,%esp
  801a12:	ff 35 40 50 81 00    	pushl  0x815040
  801a18:	e8 03 39 00 00       	call   805320 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801a1d:	a1 48 50 81 00       	mov    0x815048,%eax
  801a22:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  801a25:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  801a28:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  801a2a:	39 d0                	cmp    %edx,%eax
  801a2c:	0f 84 ba 00 00 00    	je     801aec <lwip_select+0x1f2>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801a32:	85 c0                	test   %eax,%eax
  801a34:	0f 84 c1 00 00 00    	je     801afb <lwip_select+0x201>
        if (p_selcb->next == &select_cb) {
  801a3a:	8b 10                	mov    (%eax),%edx
  801a3c:	39 ca                	cmp    %ecx,%edx
  801a3e:	0f 84 b2 00 00 00    	je     801af6 <lwip_select+0x1fc>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801a44:	89 d0                	mov    %edx,%eax
  801a46:	eb ea                	jmp    801a32 <lwip_select+0x138>
    FD_ZERO(&lreadset);
  801a48:	83 ec 04             	sub    $0x4,%esp
  801a4b:	6a 04                	push   $0x4
  801a4d:	6a 00                	push   $0x0
  801a4f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801a52:	50                   	push   %eax
  801a53:	e8 82 d7 00 00       	call   80f1da <memset>
  801a58:	83 c4 10             	add    $0x10,%esp
  801a5b:	e9 e2 fe ff ff       	jmp    801942 <lwip_select+0x48>
    FD_ZERO(&lwriteset);
  801a60:	83 ec 04             	sub    $0x4,%esp
  801a63:	6a 04                	push   $0x4
  801a65:	6a 00                	push   $0x0
  801a67:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801a6a:	50                   	push   %eax
  801a6b:	e8 6a d7 00 00       	call   80f1da <memset>
  801a70:	83 c4 10             	add    $0x10,%esp
  801a73:	e9 d7 fe ff ff       	jmp    80194f <lwip_select+0x55>
    FD_ZERO(&lexceptset);
  801a78:	83 ec 04             	sub    $0x4,%esp
  801a7b:	6a 04                	push   $0x4
  801a7d:	6a 00                	push   $0x0
  801a7f:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a82:	50                   	push   %eax
  801a83:	e8 52 d7 00 00       	call   80f1da <memset>
  801a88:	83 c4 10             	add    $0x10,%esp
  801a8b:	e9 cc fe ff ff       	jmp    80195c <lwip_select+0x62>
      sys_sem_signal(selectsem);
  801a90:	83 ec 0c             	sub    $0xc,%esp
  801a93:	ff 35 40 50 81 00    	pushl  0x815040
  801a99:	e8 cf 88 00 00       	call   80a36d <sys_sem_signal>
      if (readset)
  801a9e:	83 c4 10             	add    $0x10,%esp
  801aa1:	85 db                	test   %ebx,%ebx
  801aa3:	74 10                	je     801ab5 <lwip_select+0x1bb>
        FD_ZERO(readset);
  801aa5:	83 ec 04             	sub    $0x4,%esp
  801aa8:	6a 04                	push   $0x4
  801aaa:	6a 00                	push   $0x0
  801aac:	53                   	push   %ebx
  801aad:	e8 28 d7 00 00       	call   80f1da <memset>
  801ab2:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801ab5:	85 f6                	test   %esi,%esi
  801ab7:	74 10                	je     801ac9 <lwip_select+0x1cf>
        FD_ZERO(writeset);
  801ab9:	83 ec 04             	sub    $0x4,%esp
  801abc:	6a 04                	push   $0x4
  801abe:	6a 00                	push   $0x0
  801ac0:	56                   	push   %esi
  801ac1:	e8 14 d7 00 00       	call   80f1da <memset>
  801ac6:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801ac9:	85 ff                	test   %edi,%edi
  801acb:	74 10                	je     801add <lwip_select+0x1e3>
        FD_ZERO(exceptset);
  801acd:	83 ec 04             	sub    $0x4,%esp
  801ad0:	6a 04                	push   $0x4
  801ad2:	6a 00                	push   $0x0
  801ad4:	57                   	push   %edi
  801ad5:	e8 00 d7 00 00       	call   80f1da <memset>
  801ada:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801add:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801ae4:	00 00 00 
      return 0;
  801ae7:	e9 98 00 00 00       	jmp    801b84 <lwip_select+0x28a>
      select_cb_list = select_cb.next;
  801aec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801aef:	a3 48 50 81 00       	mov    %eax,0x815048
  801af4:	eb 05                	jmp    801afb <lwip_select+0x201>
          p_selcb->next = select_cb.next;
  801af6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801af9:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  801afb:	83 ec 0c             	sub    $0xc,%esp
  801afe:	ff 35 40 50 81 00    	pushl  0x815040
  801b04:	e8 64 88 00 00       	call   80a36d <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  801b09:	83 c4 04             	add    $0x4,%esp
  801b0c:	ff 75 d8             	pushl  -0x28(%ebp)
  801b0f:	e8 11 86 00 00       	call   80a125 <sys_sem_free>
    if (i == 0)  {
  801b14:	83 c4 10             	add    $0x10,%esp
  801b17:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801b1b:	74 72                	je     801b8f <lwip_select+0x295>
    if (readset)
  801b1d:	85 db                	test   %ebx,%ebx
  801b1f:	0f 84 b2 00 00 00    	je     801bd7 <lwip_select+0x2dd>
      lreadset = *readset;
  801b25:	8b 03                	mov    (%ebx),%eax
  801b27:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  801b2a:	85 f6                	test   %esi,%esi
  801b2c:	0f 84 bd 00 00 00    	je     801bef <lwip_select+0x2f5>
      lwriteset = *writeset;
  801b32:	8b 06                	mov    (%esi),%eax
  801b34:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  801b37:	85 ff                	test   %edi,%edi
  801b39:	0f 84 c8 00 00 00    	je     801c07 <lwip_select+0x30d>
      lexceptset = *exceptset;
  801b3f:	8b 07                	mov    (%edi),%eax
  801b41:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801b44:	83 ec 0c             	sub    $0xc,%esp
  801b47:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b4a:	50                   	push   %eax
  801b4b:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801b4e:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801b51:	8b 45 08             	mov    0x8(%ebp),%eax
  801b54:	e8 08 ed ff ff       	call   800861 <lwip_selscan>
  801b59:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801b5c:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801b5f:	85 db                	test   %ebx,%ebx
  801b61:	74 05                	je     801b68 <lwip_select+0x26e>
    *readset = lreadset;
  801b63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801b66:	89 03                	mov    %eax,(%ebx)
  if (writeset)
  801b68:	85 f6                	test   %esi,%esi
  801b6a:	74 05                	je     801b71 <lwip_select+0x277>
    *writeset = lwriteset;
  801b6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801b6f:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801b71:	85 ff                	test   %edi,%edi
  801b73:	74 05                	je     801b7a <lwip_select+0x280>
    *exceptset = lexceptset;
  801b75:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801b78:	89 07                	mov    %eax,(%edi)
  set_errno(0);
  801b7a:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801b81:	00 00 00 
}
  801b84:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801b87:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801b8a:	5b                   	pop    %ebx
  801b8b:	5e                   	pop    %esi
  801b8c:	5f                   	pop    %edi
  801b8d:	5d                   	pop    %ebp
  801b8e:	c3                   	ret    
      if (readset)
  801b8f:	85 db                	test   %ebx,%ebx
  801b91:	74 10                	je     801ba3 <lwip_select+0x2a9>
        FD_ZERO(readset);
  801b93:	83 ec 04             	sub    $0x4,%esp
  801b96:	6a 04                	push   $0x4
  801b98:	6a 00                	push   $0x0
  801b9a:	53                   	push   %ebx
  801b9b:	e8 3a d6 00 00       	call   80f1da <memset>
  801ba0:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801ba3:	85 f6                	test   %esi,%esi
  801ba5:	74 10                	je     801bb7 <lwip_select+0x2bd>
        FD_ZERO(writeset);
  801ba7:	83 ec 04             	sub    $0x4,%esp
  801baa:	6a 04                	push   $0x4
  801bac:	6a 00                	push   $0x0
  801bae:	56                   	push   %esi
  801baf:	e8 26 d6 00 00       	call   80f1da <memset>
  801bb4:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801bb7:	85 ff                	test   %edi,%edi
  801bb9:	74 10                	je     801bcb <lwip_select+0x2d1>
        FD_ZERO(exceptset);
  801bbb:	83 ec 04             	sub    $0x4,%esp
  801bbe:	6a 04                	push   $0x4
  801bc0:	6a 00                	push   $0x0
  801bc2:	57                   	push   %edi
  801bc3:	e8 12 d6 00 00       	call   80f1da <memset>
  801bc8:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801bcb:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801bd2:	00 00 00 
      return 0;
  801bd5:	eb ad                	jmp    801b84 <lwip_select+0x28a>
      FD_ZERO(&lreadset);
  801bd7:	83 ec 04             	sub    $0x4,%esp
  801bda:	6a 04                	push   $0x4
  801bdc:	6a 00                	push   $0x0
  801bde:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801be1:	50                   	push   %eax
  801be2:	e8 f3 d5 00 00       	call   80f1da <memset>
  801be7:	83 c4 10             	add    $0x10,%esp
  801bea:	e9 3b ff ff ff       	jmp    801b2a <lwip_select+0x230>
      FD_ZERO(&lwriteset);
  801bef:	83 ec 04             	sub    $0x4,%esp
  801bf2:	6a 04                	push   $0x4
  801bf4:	6a 00                	push   $0x0
  801bf6:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801bf9:	50                   	push   %eax
  801bfa:	e8 db d5 00 00       	call   80f1da <memset>
  801bff:	83 c4 10             	add    $0x10,%esp
  801c02:	e9 30 ff ff ff       	jmp    801b37 <lwip_select+0x23d>
      FD_ZERO(&lexceptset);
  801c07:	83 ec 04             	sub    $0x4,%esp
  801c0a:	6a 04                	push   $0x4
  801c0c:	6a 00                	push   $0x0
  801c0e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801c11:	50                   	push   %eax
  801c12:	e8 c3 d5 00 00       	call   80f1da <memset>
  801c17:	83 c4 10             	add    $0x10,%esp
  801c1a:	e9 25 ff ff ff       	jmp    801b44 <lwip_select+0x24a>
    sys_sem_signal(selectsem);
  801c1f:	83 ec 0c             	sub    $0xc,%esp
  801c22:	ff 35 40 50 81 00    	pushl  0x815040
  801c28:	e8 40 87 00 00       	call   80a36d <sys_sem_signal>
  801c2d:	83 c4 10             	add    $0x10,%esp
  801c30:	e9 2a ff ff ff       	jmp    801b5f <lwip_select+0x265>
    select_cb.sem = sys_sem_new(0);
  801c35:	83 ec 0c             	sub    $0xc,%esp
  801c38:	6a 00                	push   $0x0
  801c3a:	e8 61 84 00 00       	call   80a0a0 <sys_sem_new>
  801c3f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801c42:	a1 48 50 81 00       	mov    0x815048,%eax
  801c47:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801c4a:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801c4d:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  801c52:	83 c4 04             	add    $0x4,%esp
  801c55:	ff 35 40 50 81 00    	pushl  0x815040
  801c5b:	e8 0d 87 00 00       	call   80a36d <sys_sem_signal>
  801c60:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801c63:	b8 00 00 00 00       	mov    $0x0,%eax
  801c68:	e9 93 fd ff ff       	jmp    801a00 <lwip_select+0x106>

00801c6d <lwip_shutdown>:
{
  801c6d:	f3 0f 1e fb          	endbr32 
  801c71:	55                   	push   %ebp
  801c72:	89 e5                	mov    %esp,%ebp
  801c74:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801c77:	ff 75 08             	pushl  0x8(%ebp)
  801c7a:	e8 1d f5 ff ff       	call   80119c <lwip_close>
}
  801c7f:	c9                   	leave  
  801c80:	c3                   	ret    

00801c81 <lwip_getpeername>:
{
  801c81:	f3 0f 1e fb          	endbr32 
  801c85:	55                   	push   %ebp
  801c86:	89 e5                	mov    %esp,%ebp
  801c88:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801c8b:	6a 00                	push   $0x0
  801c8d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801c90:	8b 55 0c             	mov    0xc(%ebp),%edx
  801c93:	8b 45 08             	mov    0x8(%ebp),%eax
  801c96:	e8 cb ec ff ff       	call   800966 <lwip_getaddrname>
}
  801c9b:	c9                   	leave  
  801c9c:	c3                   	ret    

00801c9d <lwip_getsockname>:
{
  801c9d:	f3 0f 1e fb          	endbr32 
  801ca1:	55                   	push   %ebp
  801ca2:	89 e5                	mov    %esp,%ebp
  801ca4:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801ca7:	6a 01                	push   $0x1
  801ca9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801cac:	8b 55 0c             	mov    0xc(%ebp),%edx
  801caf:	8b 45 08             	mov    0x8(%ebp),%eax
  801cb2:	e8 af ec ff ff       	call   800966 <lwip_getaddrname>
}
  801cb7:	c9                   	leave  
  801cb8:	c3                   	ret    

00801cb9 <lwip_getsockopt>:
{
  801cb9:	f3 0f 1e fb          	endbr32 
  801cbd:	55                   	push   %ebp
  801cbe:	89 e5                	mov    %esp,%ebp
  801cc0:	57                   	push   %edi
  801cc1:	56                   	push   %esi
  801cc2:	53                   	push   %ebx
  801cc3:	83 ec 2c             	sub    $0x2c,%esp
  801cc6:	8b 75 0c             	mov    0xc(%ebp),%esi
  801cc9:	8b 7d 18             	mov    0x18(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801ccc:	8b 45 08             	mov    0x8(%ebp),%eax
  801ccf:	e8 4e eb ff ff       	call   800822 <get_socket>
  if (!sock)
  801cd4:	85 c0                	test   %eax,%eax
  801cd6:	0f 84 b0 01 00 00    	je     801e8c <lwip_getsockopt+0x1d3>
  801cdc:	89 c3                	mov    %eax,%ebx
  if ((NULL == optval) || (NULL == optlen)) {
  801cde:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801ce2:	74 37                	je     801d1b <lwip_getsockopt+0x62>
  801ce4:	85 ff                	test   %edi,%edi
  801ce6:	74 33                	je     801d1b <lwip_getsockopt+0x62>
  switch (level) {
  801ce8:	83 fe 06             	cmp    $0x6,%esi
  801ceb:	0f 84 39 01 00 00    	je     801e2a <lwip_getsockopt+0x171>
  801cf1:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801cf7:	74 3d                	je     801d36 <lwip_getsockopt+0x7d>
  801cf9:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cfe:	85 f6                	test   %esi,%esi
  801d00:	0f 84 ac 00 00 00    	je     801db2 <lwip_getsockopt+0xf9>
    sock_set_errno(sock, err);
  801d06:	0f be c0             	movsbl %al,%eax
  801d09:	89 43 10             	mov    %eax,0x10(%ebx)
  801d0c:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801d11:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d16:	e9 07 01 00 00       	jmp    801e22 <lwip_getsockopt+0x169>
    sock_set_errno(sock, EFAULT);
  801d1b:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801d22:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801d29:	00 00 00 
    return -1;
  801d2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d31:	e9 ec 00 00 00       	jmp    801e22 <lwip_getsockopt+0x169>
  801d36:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801d3d:	7e 34                	jle    801d73 <lwip_getsockopt+0xba>
  801d3f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d44:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801d4b:	75 b9                	jne    801d06 <lwip_getsockopt+0x4d>
        err = EINVAL;
  801d4d:	83 3f 04             	cmpl   $0x4,(%edi)
  801d50:	19 c0                	sbb    %eax,%eax
  801d52:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801d55:	8b 13                	mov    (%ebx),%edx
  801d57:	83 3a 20             	cmpl   $0x20,(%edx)
  801d5a:	0f 85 fa 00 00 00    	jne    801e5a <lwip_getsockopt+0x1a1>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801d60:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801d63:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801d67:	0f 85 f7 00 00 00    	jne    801e64 <lwip_getsockopt+0x1ab>
  if (err != ERR_OK) {
  801d6d:	84 c0                	test   %al,%al
  801d6f:	74 59                	je     801dca <lwip_getsockopt+0x111>
  801d71:	eb 93                	jmp    801d06 <lwip_getsockopt+0x4d>
  801d73:	81 7d 10 06 10 00 00 	cmpl   $0x1006,0x10(%ebp)
  801d7a:	7f 27                	jg     801da3 <lwip_getsockopt+0xea>
  801d7c:	8b 45 10             	mov    0x10(%ebp),%eax
  801d7f:	8d 48 fe             	lea    -0x2(%eax),%ecx
  801d82:	83 f9 1e             	cmp    $0x1e,%ecx
  801d85:	0f 87 c5 00 00 00    	ja     801e50 <lwip_getsockopt+0x197>
  801d8b:	b8 01 00 00 00       	mov    $0x1,%eax
  801d90:	d3 e0                	shl    %cl,%eax
  801d92:	a9 41 00 00 40       	test   $0x40000041,%eax
  801d97:	75 0a                	jne    801da3 <lwip_getsockopt+0xea>
  801d99:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d9e:	e9 63 ff ff ff       	jmp    801d06 <lwip_getsockopt+0x4d>
      if (*optlen < sizeof(int)) {
  801da3:	83 3f 03             	cmpl   $0x3,(%edi)
  801da6:	77 22                	ja     801dca <lwip_getsockopt+0x111>
        err = EINVAL;
  801da8:	b8 16 00 00 00       	mov    $0x16,%eax
  801dad:	e9 54 ff ff ff       	jmp    801d06 <lwip_getsockopt+0x4d>
  801db2:	8b 45 10             	mov    0x10(%ebp),%eax
  801db5:	83 e8 01             	sub    $0x1,%eax
  801db8:	83 f8 01             	cmp    $0x1,%eax
  801dbb:	0f 87 ad 00 00 00    	ja     801e6e <lwip_getsockopt+0x1b5>
      if (*optlen < sizeof(int)) {
  801dc1:	83 3f 03             	cmpl   $0x3,(%edi)
  801dc4:	0f 86 ae 00 00 00    	jbe    801e78 <lwip_getsockopt+0x1bf>
  data.sock = sock;
  801dca:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801dcd:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801dd0:	8b 45 10             	mov    0x10(%ebp),%eax
  801dd3:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801dd6:	8b 45 14             	mov    0x14(%ebp),%eax
  801dd9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801ddc:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801ddf:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801de3:	83 ec 04             	sub    $0x4,%esp
  801de6:	6a 01                	push   $0x1
  801de8:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801deb:	50                   	push   %eax
  801dec:	68 5c 0c 80 00       	push   $0x800c5c
  801df1:	e8 09 06 00 00       	call   8023ff <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801df6:	83 c4 08             	add    $0x8,%esp
  801df9:	6a 00                	push   $0x0
  801dfb:	8b 03                	mov    (%ebx),%eax
  801dfd:	ff 70 10             	pushl  0x10(%eax)
  801e00:	e8 dc 85 00 00       	call   80a3e1 <sys_arch_sem_wait>
  err = data.err;
  801e05:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801e09:	0f be d0             	movsbl %al,%edx
  801e0c:	89 53 10             	mov    %edx,0x10(%ebx)
  801e0f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801e15:	83 c4 10             	add    $0x10,%esp
  801e18:	84 c0                	test   %al,%al
  801e1a:	0f 95 c0             	setne  %al
  801e1d:	0f b6 c0             	movzbl %al,%eax
  801e20:	f7 d8                	neg    %eax
}
  801e22:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801e25:	5b                   	pop    %ebx
  801e26:	5e                   	pop    %esi
  801e27:	5f                   	pop    %edi
  801e28:	5d                   	pop    %ebp
  801e29:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801e2a:	83 3f 03             	cmpl   $0x3,(%edi)
  801e2d:	76 53                	jbe    801e82 <lwip_getsockopt+0x1c9>
    if (sock->conn->type != NETCONN_TCP)
  801e2f:	8b 10                	mov    (%eax),%edx
      return 0;
  801e31:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801e36:	83 3a 10             	cmpl   $0x10,(%edx)
  801e39:	75 e7                	jne    801e22 <lwip_getsockopt+0x169>
  801e3b:	8b 45 10             	mov    0x10(%ebp),%eax
  801e3e:	83 e8 01             	sub    $0x1,%eax
  801e41:	83 f8 01             	cmp    $0x1,%eax
  801e44:	76 84                	jbe    801dca <lwip_getsockopt+0x111>
      err = ENOPROTOOPT;
  801e46:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e4b:	e9 b6 fe ff ff       	jmp    801d06 <lwip_getsockopt+0x4d>
  801e50:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e55:	e9 ac fe ff ff       	jmp    801d06 <lwip_getsockopt+0x4d>
        err = EAFNOSUPPORT;
  801e5a:	b8 61 00 00 00       	mov    $0x61,%eax
  801e5f:	e9 a2 fe ff ff       	jmp    801d06 <lwip_getsockopt+0x4d>
  801e64:	b8 61 00 00 00       	mov    $0x61,%eax
  801e69:	e9 98 fe ff ff       	jmp    801d06 <lwip_getsockopt+0x4d>
      err = ENOPROTOOPT;
  801e6e:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e73:	e9 8e fe ff ff       	jmp    801d06 <lwip_getsockopt+0x4d>
        err = EINVAL;
  801e78:	b8 16 00 00 00       	mov    $0x16,%eax
  801e7d:	e9 84 fe ff ff       	jmp    801d06 <lwip_getsockopt+0x4d>
      err = EINVAL;
  801e82:	b8 16 00 00 00       	mov    $0x16,%eax
  801e87:	e9 7a fe ff ff       	jmp    801d06 <lwip_getsockopt+0x4d>
    return -1;
  801e8c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e91:	eb 8f                	jmp    801e22 <lwip_getsockopt+0x169>

00801e93 <lwip_setsockopt>:
{
  801e93:	f3 0f 1e fb          	endbr32 
  801e97:	55                   	push   %ebp
  801e98:	89 e5                	mov    %esp,%ebp
  801e9a:	57                   	push   %edi
  801e9b:	56                   	push   %esi
  801e9c:	53                   	push   %ebx
  801e9d:	83 ec 2c             	sub    $0x2c,%esp
  801ea0:	8b 75 0c             	mov    0xc(%ebp),%esi
  801ea3:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801ea6:	8b 45 08             	mov    0x8(%ebp),%eax
  801ea9:	e8 74 e9 ff ff       	call   800822 <get_socket>
  if (!sock)
  801eae:	85 c0                	test   %eax,%eax
  801eb0:	0f 84 69 01 00 00    	je     80201f <lwip_setsockopt+0x18c>
  801eb6:	89 c3                	mov    %eax,%ebx
  if (NULL == optval) {
  801eb8:	85 ff                	test   %edi,%edi
  801eba:	74 2c                	je     801ee8 <lwip_setsockopt+0x55>
  switch (level) {
  801ebc:	83 fe 06             	cmp    $0x6,%esi
  801ebf:	0f 84 01 01 00 00    	je     801fc6 <lwip_setsockopt+0x133>
  801ec5:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801ecb:	74 36                	je     801f03 <lwip_setsockopt+0x70>
  801ecd:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ed2:	85 f6                	test   %esi,%esi
  801ed4:	74 7b                	je     801f51 <lwip_setsockopt+0xbe>
    sock_set_errno(sock, err);
  801ed6:	89 43 10             	mov    %eax,0x10(%ebx)
  801ed9:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801ede:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ee3:	e9 d6 00 00 00       	jmp    801fbe <lwip_setsockopt+0x12b>
    sock_set_errno(sock, EFAULT);
  801ee8:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801eef:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801ef6:	00 00 00 
    return -1;
  801ef9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801efe:	e9 bb 00 00 00       	jmp    801fbe <lwip_setsockopt+0x12b>
  801f03:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801f07:	74 14                	je     801f1d <lwip_setsockopt+0x8a>
  801f09:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801f10:	74 18                	je     801f2a <lwip_setsockopt+0x97>
  801f12:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f17:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801f1b:	75 b9                	jne    801ed6 <lwip_setsockopt+0x43>
      if (optlen < sizeof(int)) {
  801f1d:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801f21:	77 47                	ja     801f6a <lwip_setsockopt+0xd7>
        err = EINVAL;
  801f23:	b8 16 00 00 00       	mov    $0x16,%eax
  801f28:	eb ac                	jmp    801ed6 <lwip_setsockopt+0x43>
        err = EINVAL;
  801f2a:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801f2e:	19 c0                	sbb    %eax,%eax
  801f30:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801f33:	8b 13                	mov    (%ebx),%edx
  801f35:	83 3a 20             	cmpl   $0x20,(%edx)
  801f38:	0f 85 af 00 00 00    	jne    801fed <lwip_setsockopt+0x15a>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801f3e:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801f41:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801f45:	0f 85 ac 00 00 00    	jne    801ff7 <lwip_setsockopt+0x164>
  if (err != ERR_OK) {
  801f4b:	85 c0                	test   %eax,%eax
  801f4d:	74 1b                	je     801f6a <lwip_setsockopt+0xd7>
  801f4f:	eb 85                	jmp    801ed6 <lwip_setsockopt+0x43>
  801f51:	8b 45 10             	mov    0x10(%ebp),%eax
  801f54:	83 e8 01             	sub    $0x1,%eax
  801f57:	83 f8 01             	cmp    $0x1,%eax
  801f5a:	0f 87 a1 00 00 00    	ja     802001 <lwip_setsockopt+0x16e>
      if (optlen < sizeof(int)) {
  801f60:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801f64:	0f 86 a1 00 00 00    	jbe    80200b <lwip_setsockopt+0x178>
  data.sock = sock;
  801f6a:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801f6d:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801f70:	8b 45 10             	mov    0x10(%ebp),%eax
  801f73:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801f76:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801f79:	8d 45 18             	lea    0x18(%ebp),%eax
  801f7c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801f7f:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801f83:	83 ec 04             	sub    $0x4,%esp
  801f86:	6a 01                	push   $0x1
  801f88:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801f8b:	50                   	push   %eax
  801f8c:	68 ef 0d 80 00       	push   $0x800def
  801f91:	e8 69 04 00 00       	call   8023ff <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801f96:	83 c4 08             	add    $0x8,%esp
  801f99:	6a 00                	push   $0x0
  801f9b:	8b 03                	mov    (%ebx),%eax
  801f9d:	ff 70 10             	pushl  0x10(%eax)
  801fa0:	e8 3c 84 00 00       	call   80a3e1 <sys_arch_sem_wait>
  err = data.err;
  801fa5:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801fa9:	89 43 10             	mov    %eax,0x10(%ebx)
  801fac:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801fb1:	83 c4 10             	add    $0x10,%esp
  801fb4:	85 c0                	test   %eax,%eax
  801fb6:	0f 95 c0             	setne  %al
  801fb9:	0f b6 c0             	movzbl %al,%eax
  801fbc:	f7 d8                	neg    %eax
}
  801fbe:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801fc1:	5b                   	pop    %ebx
  801fc2:	5e                   	pop    %esi
  801fc3:	5f                   	pop    %edi
  801fc4:	5d                   	pop    %ebp
  801fc5:	c3                   	ret    
    if (optlen < sizeof(int)) {
  801fc6:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801fca:	76 49                	jbe    802015 <lwip_setsockopt+0x182>
    if (sock->conn->type != NETCONN_TCP)
  801fcc:	8b 10                	mov    (%eax),%edx
      return 0;
  801fce:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801fd3:	83 3a 10             	cmpl   $0x10,(%edx)
  801fd6:	75 e6                	jne    801fbe <lwip_setsockopt+0x12b>
  801fd8:	8b 45 10             	mov    0x10(%ebp),%eax
  801fdb:	83 e8 01             	sub    $0x1,%eax
  801fde:	83 f8 01             	cmp    $0x1,%eax
  801fe1:	76 87                	jbe    801f6a <lwip_setsockopt+0xd7>
      err = ENOPROTOOPT;
  801fe3:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801fe8:	e9 e9 fe ff ff       	jmp    801ed6 <lwip_setsockopt+0x43>
        err = EAFNOSUPPORT;
  801fed:	b8 61 00 00 00       	mov    $0x61,%eax
  801ff2:	e9 df fe ff ff       	jmp    801ed6 <lwip_setsockopt+0x43>
  801ff7:	b8 61 00 00 00       	mov    $0x61,%eax
  801ffc:	e9 d5 fe ff ff       	jmp    801ed6 <lwip_setsockopt+0x43>
        err = ENOPROTOOPT;
  802001:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802006:	e9 cb fe ff ff       	jmp    801ed6 <lwip_setsockopt+0x43>
        err = EINVAL;
  80200b:	b8 16 00 00 00       	mov    $0x16,%eax
  802010:	e9 c1 fe ff ff       	jmp    801ed6 <lwip_setsockopt+0x43>
      err = EINVAL;
  802015:	b8 16 00 00 00       	mov    $0x16,%eax
  80201a:	e9 b7 fe ff ff       	jmp    801ed6 <lwip_setsockopt+0x43>
    return -1;
  80201f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802024:	eb 98                	jmp    801fbe <lwip_setsockopt+0x12b>

00802026 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  802026:	f3 0f 1e fb          	endbr32 
  80202a:	55                   	push   %ebp
  80202b:	89 e5                	mov    %esp,%ebp
  80202d:	56                   	push   %esi
  80202e:	53                   	push   %ebx
  80202f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  802032:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  802035:	8b 45 08             	mov    0x8(%ebp),%eax
  802038:	e8 e5 e7 ff ff       	call   800822 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  80203d:	85 c0                	test   %eax,%eax
  80203f:	0f 84 b4 00 00 00    	je     8020f9 <lwip_ioctl+0xd3>
    return -1;

  switch (cmd) {
  802045:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  80204b:	74 5d                	je     8020aa <lwip_ioctl+0x84>
  80204d:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  802053:	0f 85 88 00 00 00    	jne    8020e1 <lwip_ioctl+0xbb>
  case FIONREAD:
    if (!argp) {
  802059:	85 f6                	test   %esi,%esi
  80205b:	74 35                	je     802092 <lwip_ioctl+0x6c>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80205d:	8b 10                	mov    (%eax),%edx
  80205f:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  802063:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  802066:	8b 48 04             	mov    0x4(%eax),%ecx
  802069:	85 c9                	test   %ecx,%ecx
  80206b:	74 0d                	je     80207a <lwip_ioctl+0x54>
      buflen = netbuf_len(sock->lastdata);
  80206d:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  80206f:	66 2b 50 08          	sub    0x8(%eax),%dx
  802073:	66 03 51 08          	add    0x8(%ecx),%dx
  802077:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  80207a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802081:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  802088:	00 00 00 
    return 0;
  80208b:	b8 00 00 00 00       	mov    $0x0,%eax
  802090:	eb 4b                	jmp    8020dd <lwip_ioctl+0xb7>
      sock_set_errno(sock, EINVAL);
  802092:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  802099:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  8020a0:	00 00 00 
      return -1;
  8020a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020a8:	eb 33                	jmp    8020dd <lwip_ioctl+0xb7>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8020aa:	85 f6                	test   %esi,%esi
  8020ac:	74 0e                	je     8020bc <lwip_ioctl+0x96>
  8020ae:	83 3e 00             	cmpl   $0x0,(%esi)
  8020b1:	74 09                	je     8020bc <lwip_ioctl+0x96>
      sock->flags |= O_NONBLOCK;
  8020b3:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  8020b7:	80 ce 08             	or     $0x8,%dh
  8020ba:	eb 07                	jmp    8020c3 <lwip_ioctl+0x9d>
    else
      sock->flags &= ~O_NONBLOCK;
  8020bc:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  8020c0:	80 e6 f7             	and    $0xf7,%dh
  8020c3:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  8020c7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8020ce:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8020d5:	00 00 00 
    return 0;
  8020d8:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  8020dd:	5b                   	pop    %ebx
  8020de:	5e                   	pop    %esi
  8020df:	5d                   	pop    %ebp
  8020e0:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  8020e1:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  8020e8:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  8020ef:	00 00 00 
    return -1;
  8020f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020f7:	eb e4                	jmp    8020dd <lwip_ioctl+0xb7>
    return -1;
  8020f9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020fe:	eb dd                	jmp    8020dd <lwip_ioctl+0xb7>

00802100 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  802100:	f3 0f 1e fb          	endbr32 
  802104:	55                   	push   %ebp
  802105:	89 e5                	mov    %esp,%ebp
  802107:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  80210a:	e8 26 42 00 00       	call   806335 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80210f:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  802116:	74 19                	je     802131 <tcpip_tcp_timer+0x31>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802118:	83 ec 04             	sub    $0x4,%esp
  80211b:	6a 00                	push   $0x0
  80211d:	68 00 21 80 00       	push   $0x802100
  802122:	68 fa 00 00 00       	push   $0xfa
  802127:	e8 89 32 00 00       	call   8053b5 <sys_timeout>
  80212c:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  80212f:	c9                   	leave  
  802130:	c3                   	ret    
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802131:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  802138:	75 de                	jne    802118 <tcpip_tcp_timer+0x18>
    tcpip_tcp_timer_active = 0;
  80213a:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  802141:	00 00 00 
}
  802144:	eb e9                	jmp    80212f <tcpip_tcp_timer+0x2f>

00802146 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  802146:	f3 0f 1e fb          	endbr32 
  80214a:	55                   	push   %ebp
  80214b:	89 e5                	mov    %esp,%ebp
  80214d:	53                   	push   %ebx
  80214e:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802151:	6a 00                	push   $0x0
  802153:	68 07 23 80 00       	push   $0x802307
  802158:	68 e8 03 00 00       	push   $0x3e8
  80215d:	e8 53 32 00 00       	call   8053b5 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802162:	83 c4 0c             	add    $0xc,%esp
  802165:	6a 00                	push   $0x0
  802167:	68 df 22 80 00       	push   $0x8022df
  80216c:	68 88 13 00 00       	push   $0x1388
  802171:	e8 3f 32 00 00       	call   8053b5 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802176:	83 c4 0c             	add    $0xc,%esp
  802179:	6a 00                	push   $0x0
  80217b:	68 b7 22 80 00       	push   $0x8022b7
  802180:	68 60 ea 00 00       	push   $0xea60
  802185:	e8 2b 32 00 00       	call   8053b5 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80218a:	83 c4 0c             	add    $0xc,%esp
  80218d:	6a 00                	push   $0x0
  80218f:	68 8f 22 80 00       	push   $0x80228f
  802194:	68 f4 01 00 00       	push   $0x1f4
  802199:	e8 17 32 00 00       	call   8053b5 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80219e:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  8021a3:	83 c4 10             	add    $0x10,%esp
  8021a6:	85 c0                	test   %eax,%eax
  8021a8:	74 0e                	je     8021b8 <tcpip_thread+0x72>
    tcpip_init_done(tcpip_init_done_arg);
  8021aa:	83 ec 0c             	sub    $0xc,%esp
  8021ad:	ff 35 e4 52 81 00    	pushl  0x8152e4
  8021b3:	ff d0                	call   *%eax
  8021b5:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8021b8:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8021bb:	eb 44                	jmp    802201 <tcpip_thread+0xbb>
    switch (msg->type) {
  8021bd:	83 f8 03             	cmp    $0x3,%eax
  8021c0:	75 3f                	jne    802201 <tcpip_thread+0xbb>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8021c2:	8b 42 08             	mov    0x8(%edx),%eax
  8021c5:	83 f8 ff             	cmp    $0xffffffff,%eax
  8021c8:	0f 84 ab 00 00 00    	je     802279 <tcpip_thread+0x133>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8021ce:	83 ec 04             	sub    $0x4,%esp
  8021d1:	ff 72 10             	pushl  0x10(%edx)
  8021d4:	ff 72 0c             	pushl  0xc(%edx)
  8021d7:	50                   	push   %eax
  8021d8:	e8 d8 31 00 00       	call   8053b5 <sys_timeout>
  8021dd:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8021e0:	83 ec 08             	sub    $0x8,%esp
  8021e3:	ff 75 f4             	pushl  -0xc(%ebp)
  8021e6:	6a 08                	push   $0x8
  8021e8:	e8 ab 24 00 00       	call   804698 <memp_free>
      break;
  8021ed:	83 c4 10             	add    $0x10,%esp
  8021f0:	eb 0f                	jmp    802201 <tcpip_thread+0xbb>
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  8021f2:	8b 42 08             	mov    0x8(%edx),%eax
  8021f5:	83 ec 0c             	sub    $0xc,%esp
  8021f8:	8d 50 04             	lea    0x4(%eax),%edx
  8021fb:	52                   	push   %edx
  8021fc:	ff 10                	call   *(%eax)
      break;
  8021fe:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  802201:	83 ec 08             	sub    $0x8,%esp
  802204:	53                   	push   %ebx
  802205:	ff 35 00 40 81 00    	pushl  0x814000
  80220b:	e8 75 30 00 00       	call   805285 <sys_mbox_fetch>
    switch (msg->type) {
  802210:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802213:	8b 02                	mov    (%edx),%eax
  802215:	83 c4 10             	add    $0x10,%esp
  802218:	83 f8 02             	cmp    $0x2,%eax
  80221b:	74 41                	je     80225e <tcpip_thread+0x118>
  80221d:	77 9e                	ja     8021bd <tcpip_thread+0x77>
  80221f:	85 c0                	test   %eax,%eax
  802221:	74 cf                	je     8021f2 <tcpip_thread+0xac>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802223:	8b 42 0c             	mov    0xc(%edx),%eax
  802226:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  80222a:	74 21                	je     80224d <tcpip_thread+0x107>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80222c:	83 ec 08             	sub    $0x8,%esp
  80222f:	50                   	push   %eax
  802230:	ff 72 08             	pushl  0x8(%edx)
  802233:	e8 af 7c 00 00       	call   809ee7 <ethernet_input>
  802238:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  80223b:	83 ec 08             	sub    $0x8,%esp
  80223e:	ff 75 f4             	pushl  -0xc(%ebp)
  802241:	6a 09                	push   $0x9
  802243:	e8 50 24 00 00       	call   804698 <memp_free>
      break;
  802248:	83 c4 10             	add    $0x10,%esp
  80224b:	eb b4                	jmp    802201 <tcpip_thread+0xbb>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  80224d:	83 ec 08             	sub    $0x8,%esp
  802250:	50                   	push   %eax
  802251:	ff 72 08             	pushl  0x8(%edx)
  802254:	e8 26 45 00 00       	call   80677f <ip_input>
  802259:	83 c4 10             	add    $0x10,%esp
  80225c:	eb dd                	jmp    80223b <tcpip_thread+0xf5>
      msg->msg.cb.f(msg->msg.cb.ctx);
  80225e:	83 ec 0c             	sub    $0xc,%esp
  802261:	ff 72 0c             	pushl  0xc(%edx)
  802264:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802267:	83 c4 08             	add    $0x8,%esp
  80226a:	ff 75 f4             	pushl  -0xc(%ebp)
  80226d:	6a 08                	push   $0x8
  80226f:	e8 24 24 00 00       	call   804698 <memp_free>
      break;
  802274:	83 c4 10             	add    $0x10,%esp
  802277:	eb 88                	jmp    802201 <tcpip_thread+0xbb>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  802279:	83 ec 08             	sub    $0x8,%esp
  80227c:	ff 72 10             	pushl  0x10(%edx)
  80227f:	ff 72 0c             	pushl  0xc(%edx)
  802282:	e8 ed 31 00 00       	call   805474 <sys_untimeout>
  802287:	83 c4 10             	add    $0x10,%esp
  80228a:	e9 51 ff ff ff       	jmp    8021e0 <tcpip_thread+0x9a>

0080228f <dhcp_timer_fine>:
{
  80228f:	f3 0f 1e fb          	endbr32 
  802293:	55                   	push   %ebp
  802294:	89 e5                	mov    %esp,%ebp
  802296:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  802299:	e8 a1 1b 00 00       	call   803e3f <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80229e:	83 ec 04             	sub    $0x4,%esp
  8022a1:	6a 00                	push   $0x0
  8022a3:	68 8f 22 80 00       	push   $0x80228f
  8022a8:	68 f4 01 00 00       	push   $0x1f4
  8022ad:	e8 03 31 00 00       	call   8053b5 <sys_timeout>
}
  8022b2:	83 c4 10             	add    $0x10,%esp
  8022b5:	c9                   	leave  
  8022b6:	c3                   	ret    

008022b7 <dhcp_timer_coarse>:
{
  8022b7:	f3 0f 1e fb          	endbr32 
  8022bb:	55                   	push   %ebp
  8022bc:	89 e5                	mov    %esp,%ebp
  8022be:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  8022c1:	e8 a5 19 00 00       	call   803c6b <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8022c6:	83 ec 04             	sub    $0x4,%esp
  8022c9:	6a 00                	push   $0x0
  8022cb:	68 b7 22 80 00       	push   $0x8022b7
  8022d0:	68 60 ea 00 00       	push   $0xea60
  8022d5:	e8 db 30 00 00       	call   8053b5 <sys_timeout>
}
  8022da:	83 c4 10             	add    $0x10,%esp
  8022dd:	c9                   	leave  
  8022de:	c3                   	ret    

008022df <arp_timer>:
{
  8022df:	f3 0f 1e fb          	endbr32 
  8022e3:	55                   	push   %ebp
  8022e4:	89 e5                	mov    %esp,%ebp
  8022e6:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  8022e9:	e8 a9 74 00 00       	call   809797 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8022ee:	83 ec 04             	sub    $0x4,%esp
  8022f1:	6a 00                	push   $0x0
  8022f3:	68 df 22 80 00       	push   $0x8022df
  8022f8:	68 88 13 00 00       	push   $0x1388
  8022fd:	e8 b3 30 00 00       	call   8053b5 <sys_timeout>
}
  802302:	83 c4 10             	add    $0x10,%esp
  802305:	c9                   	leave  
  802306:	c3                   	ret    

00802307 <ip_reass_timer>:
{
  802307:	f3 0f 1e fb          	endbr32 
  80230b:	55                   	push   %ebp
  80230c:	89 e5                	mov    %esp,%ebp
  80230e:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  802311:	e8 59 4b 00 00       	call   806e6f <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802316:	83 ec 04             	sub    $0x4,%esp
  802319:	6a 00                	push   $0x0
  80231b:	68 07 23 80 00       	push   $0x802307
  802320:	68 e8 03 00 00       	push   $0x3e8
  802325:	e8 8b 30 00 00       	call   8053b5 <sys_timeout>
}
  80232a:	83 c4 10             	add    $0x10,%esp
  80232d:	c9                   	leave  
  80232e:	c3                   	ret    

0080232f <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  80232f:	f3 0f 1e fb          	endbr32 
  802333:	55                   	push   %ebp
  802334:	89 e5                	mov    %esp,%ebp
  802336:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802339:	ff 75 08             	pushl  0x8(%ebp)
  80233c:	e8 da 26 00 00       	call   804a1b <pbuf_free>
}
  802341:	83 c4 10             	add    $0x10,%esp
  802344:	c9                   	leave  
  802345:	c3                   	ret    

00802346 <tcp_timer_needed>:
{
  802346:	f3 0f 1e fb          	endbr32 
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  80234a:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  802351:	75 38                	jne    80238b <tcp_timer_needed+0x45>
  802353:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  80235a:	74 26                	je     802382 <tcp_timer_needed+0x3c>
{
  80235c:	55                   	push   %ebp
  80235d:	89 e5                	mov    %esp,%ebp
  80235f:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  802362:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  802369:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80236c:	6a 00                	push   $0x0
  80236e:	68 00 21 80 00       	push   $0x802100
  802373:	68 fa 00 00 00       	push   $0xfa
  802378:	e8 38 30 00 00       	call   8053b5 <sys_timeout>
  80237d:	83 c4 10             	add    $0x10,%esp
}
  802380:	c9                   	leave  
  802381:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802382:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  802389:	75 d1                	jne    80235c <tcp_timer_needed+0x16>
  80238b:	c3                   	ret    

0080238c <tcpip_input>:
{
  80238c:	f3 0f 1e fb          	endbr32 
  if (mbox != SYS_MBOX_NULL) {
  802390:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802397:	74 59                	je     8023f2 <tcpip_input+0x66>
{
  802399:	55                   	push   %ebp
  80239a:	89 e5                	mov    %esp,%ebp
  80239c:	53                   	push   %ebx
  80239d:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8023a0:	6a 09                	push   $0x9
  8023a2:	e8 97 22 00 00       	call   80463e <memp_malloc>
  8023a7:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8023a9:	83 c4 10             	add    $0x10,%esp
  8023ac:	85 c0                	test   %eax,%eax
  8023ae:	74 48                	je     8023f8 <tcpip_input+0x6c>
    msg->type = TCPIP_MSG_INPKT;
  8023b0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8023b6:	8b 45 08             	mov    0x8(%ebp),%eax
  8023b9:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8023bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8023bf:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8023c2:	83 ec 08             	sub    $0x8,%esp
  8023c5:	53                   	push   %ebx
  8023c6:	ff 35 00 40 81 00    	pushl  0x814000
  8023cc:	e8 24 81 00 00       	call   80a4f5 <sys_mbox_trypost>
  8023d1:	83 c4 10             	add    $0x10,%esp
  8023d4:	84 c0                	test   %al,%al
  8023d6:	75 05                	jne    8023dd <tcpip_input+0x51>
}
  8023d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8023db:	c9                   	leave  
  8023dc:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8023dd:	83 ec 08             	sub    $0x8,%esp
  8023e0:	53                   	push   %ebx
  8023e1:	6a 09                	push   $0x9
  8023e3:	e8 b0 22 00 00       	call   804698 <memp_free>
      return ERR_MEM;
  8023e8:	83 c4 10             	add    $0x10,%esp
  8023eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8023f0:	eb e6                	jmp    8023d8 <tcpip_input+0x4c>
  return ERR_VAL;
  8023f2:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8023f7:	c3                   	ret    
      return ERR_MEM;
  8023f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8023fd:	eb d9                	jmp    8023d8 <tcpip_input+0x4c>

008023ff <tcpip_callback_with_block>:
{
  8023ff:	f3 0f 1e fb          	endbr32 
  802403:	55                   	push   %ebp
  802404:	89 e5                	mov    %esp,%ebp
  802406:	56                   	push   %esi
  802407:	53                   	push   %ebx
  802408:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  80240b:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802412:	74 76                	je     80248a <tcpip_callback_with_block+0x8b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802414:	83 ec 0c             	sub    $0xc,%esp
  802417:	6a 08                	push   $0x8
  802419:	e8 20 22 00 00       	call   80463e <memp_malloc>
  80241e:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802420:	83 c4 10             	add    $0x10,%esp
  802423:	85 c0                	test   %eax,%eax
  802425:	74 6a                	je     802491 <tcpip_callback_with_block+0x92>
    msg->type = TCPIP_MSG_CALLBACK;
  802427:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80242d:	8b 45 08             	mov    0x8(%ebp),%eax
  802430:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802433:	8b 45 0c             	mov    0xc(%ebp),%eax
  802436:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  802439:	89 f0                	mov    %esi,%eax
  80243b:	84 c0                	test   %al,%al
  80243d:	75 1d                	jne    80245c <tcpip_callback_with_block+0x5d>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80243f:	83 ec 08             	sub    $0x8,%esp
  802442:	53                   	push   %ebx
  802443:	ff 35 00 40 81 00    	pushl  0x814000
  802449:	e8 a7 80 00 00       	call   80a4f5 <sys_mbox_trypost>
  80244e:	83 c4 10             	add    $0x10,%esp
  802451:	84 c0                	test   %al,%al
  802453:	75 20                	jne    802475 <tcpip_callback_with_block+0x76>
}
  802455:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802458:	5b                   	pop    %ebx
  802459:	5e                   	pop    %esi
  80245a:	5d                   	pop    %ebp
  80245b:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  80245c:	83 ec 08             	sub    $0x8,%esp
  80245f:	53                   	push   %ebx
  802460:	ff 35 00 40 81 00    	pushl  0x814000
  802466:	e8 53 81 00 00       	call   80a5be <sys_mbox_post>
  80246b:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  80246e:	b8 00 00 00 00       	mov    $0x0,%eax
  802473:	eb e0                	jmp    802455 <tcpip_callback_with_block+0x56>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  802475:	83 ec 08             	sub    $0x8,%esp
  802478:	53                   	push   %ebx
  802479:	6a 08                	push   $0x8
  80247b:	e8 18 22 00 00       	call   804698 <memp_free>
        return ERR_MEM;
  802480:	83 c4 10             	add    $0x10,%esp
  802483:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802488:	eb cb                	jmp    802455 <tcpip_callback_with_block+0x56>
  return ERR_VAL;
  80248a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80248f:	eb c4                	jmp    802455 <tcpip_callback_with_block+0x56>
      return ERR_MEM;
  802491:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802496:	eb bd                	jmp    802455 <tcpip_callback_with_block+0x56>

00802498 <tcpip_timeout>:
{
  802498:	f3 0f 1e fb          	endbr32 
  if (mbox != SYS_MBOX_NULL) {
  80249c:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8024a3:	74 45                	je     8024ea <tcpip_timeout+0x52>
{
  8024a5:	55                   	push   %ebp
  8024a6:	89 e5                	mov    %esp,%ebp
  8024a8:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8024ab:	6a 08                	push   $0x8
  8024ad:	e8 8c 21 00 00       	call   80463e <memp_malloc>
    if (msg == NULL) {
  8024b2:	83 c4 10             	add    $0x10,%esp
  8024b5:	85 c0                	test   %eax,%eax
  8024b7:	74 37                	je     8024f0 <tcpip_timeout+0x58>
    msg->type = TCPIP_MSG_TIMEOUT;
  8024b9:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8024bf:	8b 55 08             	mov    0x8(%ebp),%edx
  8024c2:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8024c5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8024c8:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8024cb:	8b 55 10             	mov    0x10(%ebp),%edx
  8024ce:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8024d1:	83 ec 08             	sub    $0x8,%esp
  8024d4:	50                   	push   %eax
  8024d5:	ff 35 00 40 81 00    	pushl  0x814000
  8024db:	e8 de 80 00 00       	call   80a5be <sys_mbox_post>
    return ERR_OK;
  8024e0:	83 c4 10             	add    $0x10,%esp
  8024e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8024e8:	c9                   	leave  
  8024e9:	c3                   	ret    
  return ERR_VAL;
  8024ea:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8024ef:	c3                   	ret    
      return ERR_MEM;
  8024f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8024f5:	eb f1                	jmp    8024e8 <tcpip_timeout+0x50>

008024f7 <tcpip_apimsg>:
{
  8024f7:	f3 0f 1e fb          	endbr32 
  8024fb:	55                   	push   %ebp
  8024fc:	89 e5                	mov    %esp,%ebp
  8024fe:	53                   	push   %ebx
  8024ff:	83 ec 24             	sub    $0x24,%esp
  802502:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  802505:	a1 00 40 81 00       	mov    0x814000,%eax
  80250a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80250d:	74 34                	je     802543 <tcpip_apimsg+0x4c>
    msg.type = TCPIP_MSG_API;
  80250f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802516:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802519:	83 ec 08             	sub    $0x8,%esp
  80251c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80251f:	52                   	push   %edx
  802520:	50                   	push   %eax
  802521:	e8 98 80 00 00       	call   80a5be <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802526:	83 c4 08             	add    $0x8,%esp
  802529:	6a 00                	push   $0x0
  80252b:	8b 43 04             	mov    0x4(%ebx),%eax
  80252e:	ff 70 10             	pushl  0x10(%eax)
  802531:	e8 ab 7e 00 00       	call   80a3e1 <sys_arch_sem_wait>
    return ERR_OK;
  802536:	83 c4 10             	add    $0x10,%esp
  802539:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80253e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802541:	c9                   	leave  
  802542:	c3                   	ret    
  return ERR_VAL;
  802543:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  802548:	eb f4                	jmp    80253e <tcpip_apimsg+0x47>

0080254a <tcpip_init>:
{
  80254a:	f3 0f 1e fb          	endbr32 
  80254e:	55                   	push   %ebp
  80254f:	89 e5                	mov    %esp,%ebp
  802551:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  802554:	e8 96 03 00 00       	call   8028ef <lwip_init>
  tcpip_init_done = initfunc;
  802559:	8b 45 08             	mov    0x8(%ebp),%eax
  80255c:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  802561:	8b 45 0c             	mov    0xc(%ebp),%eax
  802564:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  802569:	83 ec 0c             	sub    $0xc,%esp
  80256c:	6a 00                	push   $0x0
  80256e:	e8 e2 7c 00 00       	call   80a255 <sys_mbox_new>
  802573:	a3 00 40 81 00       	mov    %eax,0x814000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  802578:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80257f:	6a 00                	push   $0x0
  802581:	6a 00                	push   $0x0
  802583:	68 46 21 80 00       	push   $0x802146
  802588:	68 5c 15 81 00       	push   $0x81155c
  80258d:	e8 6b 81 00 00       	call   80a6fd <sys_thread_new>
}
  802592:	83 c4 20             	add    $0x20,%esp
  802595:	c9                   	leave  
  802596:	c3                   	ret    

00802597 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  802597:	f3 0f 1e fb          	endbr32 
  80259b:	55                   	push   %ebp
  80259c:	89 e5                	mov    %esp,%ebp
  80259e:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8025a1:	6a 00                	push   $0x0
  8025a3:	ff 75 08             	pushl  0x8(%ebp)
  8025a6:	68 2f 23 80 00       	push   $0x80232f
  8025ab:	e8 4f fe ff ff       	call   8023ff <tcpip_callback_with_block>
}
  8025b0:	c9                   	leave  
  8025b1:	c3                   	ret    

008025b2 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8025b2:	f3 0f 1e fb          	endbr32 
  8025b6:	55                   	push   %ebp
  8025b7:	89 e5                	mov    %esp,%ebp
  8025b9:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8025bc:	6a 00                	push   $0x0
  8025be:	ff 75 08             	pushl  0x8(%ebp)
  8025c1:	68 e6 40 80 00       	push   $0x8040e6
  8025c6:	e8 34 fe ff ff       	call   8023ff <tcpip_callback_with_block>
}
  8025cb:	c9                   	leave  
  8025cc:	c3                   	ret    

008025cd <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8025cd:	f3 0f 1e fb          	endbr32 
  8025d1:	55                   	push   %ebp
  8025d2:	89 e5                	mov    %esp,%ebp
  8025d4:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8025d7:	6a 06                	push   $0x6
  8025d9:	e8 60 20 00 00       	call   80463e <memp_malloc>
  if (buf != NULL) {
  8025de:	83 c4 10             	add    $0x10,%esp
  8025e1:	85 c0                	test   %eax,%eax
  8025e3:	74 14                	je     8025f9 <netbuf_new+0x2c>
    buf->p = NULL;
  8025e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8025eb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8025f2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  8025f9:	c9                   	leave  
  8025fa:	c3                   	ret    

008025fb <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8025fb:	f3 0f 1e fb          	endbr32 
  8025ff:	55                   	push   %ebp
  802600:	89 e5                	mov    %esp,%ebp
  802602:	53                   	push   %ebx
  802603:	83 ec 04             	sub    $0x4,%esp
  802606:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802609:	85 db                	test   %ebx,%ebx
  80260b:	74 2d                	je     80263a <netbuf_delete+0x3f>
    if (buf->p != NULL) {
  80260d:	8b 03                	mov    (%ebx),%eax
  80260f:	85 c0                	test   %eax,%eax
  802611:	74 19                	je     80262c <netbuf_delete+0x31>
      pbuf_free(buf->p);
  802613:	83 ec 0c             	sub    $0xc,%esp
  802616:	50                   	push   %eax
  802617:	e8 ff 23 00 00       	call   804a1b <pbuf_free>
      buf->p = buf->ptr = NULL;
  80261c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802623:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802629:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  80262c:	83 ec 08             	sub    $0x8,%esp
  80262f:	53                   	push   %ebx
  802630:	6a 06                	push   $0x6
  802632:	e8 61 20 00 00       	call   804698 <memp_free>
  802637:	83 c4 10             	add    $0x10,%esp
  }
}
  80263a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80263d:	c9                   	leave  
  80263e:	c3                   	ret    

0080263f <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80263f:	f3 0f 1e fb          	endbr32 
  802643:	55                   	push   %ebp
  802644:	89 e5                	mov    %esp,%ebp
  802646:	56                   	push   %esi
  802647:	53                   	push   %ebx
  802648:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80264b:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80264e:	85 db                	test   %ebx,%ebx
  802650:	74 3e                	je     802690 <netbuf_alloc+0x51>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802652:	8b 03                	mov    (%ebx),%eax
  802654:	85 c0                	test   %eax,%eax
  802656:	74 0c                	je     802664 <netbuf_alloc+0x25>
    pbuf_free(buf->p);
  802658:	83 ec 0c             	sub    $0xc,%esp
  80265b:	50                   	push   %eax
  80265c:	e8 ba 23 00 00       	call   804a1b <pbuf_free>
  802661:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  802664:	83 ec 04             	sub    $0x4,%esp
  802667:	6a 00                	push   $0x0
  802669:	0f b7 c6             	movzwl %si,%eax
  80266c:	50                   	push   %eax
  80266d:	6a 00                	push   $0x0
  80266f:	e8 71 24 00 00       	call   804ae5 <pbuf_alloc>
  802674:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802676:	83 c4 10             	add    $0x10,%esp
  802679:	85 c0                	test   %eax,%eax
  80267b:	74 0c                	je     802689 <netbuf_alloc+0x4a>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  80267d:	66 39 70 0a          	cmp    %si,0xa(%eax)
  802681:	72 21                	jb     8026a4 <netbuf_alloc+0x65>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  802683:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  802686:	8b 40 04             	mov    0x4(%eax),%eax
}
  802689:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80268c:	5b                   	pop    %ebx
  80268d:	5e                   	pop    %esi
  80268e:	5d                   	pop    %ebp
  80268f:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802690:	83 ec 04             	sub    $0x4,%esp
  802693:	68 69 15 81 00       	push   $0x811569
  802698:	6a 63                	push   $0x63
  80269a:	68 83 15 81 00       	push   $0x811583
  80269f:	e8 93 c2 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  8026a4:	83 ec 04             	sub    $0x4,%esp
  8026a7:	68 50 16 81 00       	push   $0x811650
  8026ac:	6a 6d                	push   $0x6d
  8026ae:	68 83 15 81 00       	push   $0x811583
  8026b3:	e8 7f c2 00 00       	call   80e937 <_panic>

008026b8 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8026b8:	f3 0f 1e fb          	endbr32 
  8026bc:	55                   	push   %ebp
  8026bd:	89 e5                	mov    %esp,%ebp
  8026bf:	53                   	push   %ebx
  8026c0:	83 ec 04             	sub    $0x4,%esp
  8026c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8026c6:	85 db                	test   %ebx,%ebx
  8026c8:	74 24                	je     8026ee <netbuf_free+0x36>
  if (buf->p != NULL) {
  8026ca:	8b 03                	mov    (%ebx),%eax
  8026cc:	85 c0                	test   %eax,%eax
  8026ce:	74 0c                	je     8026dc <netbuf_free+0x24>
    pbuf_free(buf->p);
  8026d0:	83 ec 0c             	sub    $0xc,%esp
  8026d3:	50                   	push   %eax
  8026d4:	e8 42 23 00 00       	call   804a1b <pbuf_free>
  8026d9:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  8026dc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8026e3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8026e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8026ec:	c9                   	leave  
  8026ed:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8026ee:	83 ec 04             	sub    $0x4,%esp
  8026f1:	68 99 15 81 00       	push   $0x811599
  8026f6:	6a 7b                	push   $0x7b
  8026f8:	68 83 15 81 00       	push   $0x811583
  8026fd:	e8 35 c2 00 00       	call   80e937 <_panic>

00802702 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802702:	f3 0f 1e fb          	endbr32 
  802706:	55                   	push   %ebp
  802707:	89 e5                	mov    %esp,%ebp
  802709:	56                   	push   %esi
  80270a:	53                   	push   %ebx
  80270b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80270e:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802711:	85 db                	test   %ebx,%ebx
  802713:	74 4c                	je     802761 <netbuf_ref+0x5f>
  if (buf->p != NULL) {
  802715:	8b 03                	mov    (%ebx),%eax
  802717:	85 c0                	test   %eax,%eax
  802719:	74 0c                	je     802727 <netbuf_ref+0x25>
    pbuf_free(buf->p);
  80271b:	83 ec 0c             	sub    $0xc,%esp
  80271e:	50                   	push   %eax
  80271f:	e8 f7 22 00 00       	call   804a1b <pbuf_free>
  802724:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802727:	83 ec 04             	sub    $0x4,%esp
  80272a:	6a 02                	push   $0x2
  80272c:	6a 00                	push   $0x0
  80272e:	6a 00                	push   $0x0
  802730:	e8 b0 23 00 00       	call   804ae5 <pbuf_alloc>
  802735:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802737:	83 c4 10             	add    $0x10,%esp
  80273a:	85 c0                	test   %eax,%eax
  80273c:	74 3a                	je     802778 <netbuf_ref+0x76>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  80273e:	8b 55 0c             	mov    0xc(%ebp),%edx
  802741:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802744:	8b 03                	mov    (%ebx),%eax
  802746:	66 89 70 08          	mov    %si,0x8(%eax)
  80274a:	8b 03                	mov    (%ebx),%eax
  80274c:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802750:	8b 03                	mov    (%ebx),%eax
  802752:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  802755:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80275a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80275d:	5b                   	pop    %ebx
  80275e:	5e                   	pop    %esi
  80275f:	5d                   	pop    %ebp
  802760:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802761:	83 ec 04             	sub    $0x4,%esp
  802764:	68 b2 15 81 00       	push   $0x8115b2
  802769:	68 8e 00 00 00       	push   $0x8e
  80276e:	68 83 15 81 00       	push   $0x811583
  802773:	e8 bf c1 00 00       	call   80e937 <_panic>
    buf->ptr = NULL;
  802778:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  80277f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802784:	eb d4                	jmp    80275a <netbuf_ref+0x58>

00802786 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  802786:	f3 0f 1e fb          	endbr32 
  80278a:	55                   	push   %ebp
  80278b:	89 e5                	mov    %esp,%ebp
  80278d:	56                   	push   %esi
  80278e:	53                   	push   %ebx
  80278f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802792:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802795:	85 db                	test   %ebx,%ebx
  802797:	74 2a                	je     8027c3 <netbuf_chain+0x3d>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802799:	85 f6                	test   %esi,%esi
  80279b:	74 3d                	je     8027da <netbuf_chain+0x54>
  pbuf_chain(head->p, tail->p);
  80279d:	83 ec 08             	sub    $0x8,%esp
  8027a0:	ff 36                	pushl  (%esi)
  8027a2:	ff 33                	pushl  (%ebx)
  8027a4:	e8 54 27 00 00       	call   804efd <pbuf_chain>
  head->ptr = head->p;
  8027a9:	8b 03                	mov    (%ebx),%eax
  8027ab:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8027ae:	83 c4 08             	add    $0x8,%esp
  8027b1:	56                   	push   %esi
  8027b2:	6a 06                	push   $0x6
  8027b4:	e8 df 1e 00 00       	call   804698 <memp_free>
  8027b9:	83 c4 10             	add    $0x10,%esp
}
  8027bc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8027bf:	5b                   	pop    %ebx
  8027c0:	5e                   	pop    %esi
  8027c1:	5d                   	pop    %ebp
  8027c2:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8027c3:	83 ec 04             	sub    $0x4,%esp
  8027c6:	68 ca 15 81 00       	push   $0x8115ca
  8027cb:	68 a6 00 00 00       	push   $0xa6
  8027d0:	68 83 15 81 00       	push   $0x811583
  8027d5:	e8 5d c1 00 00       	call   80e937 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8027da:	83 ec 04             	sub    $0x4,%esp
  8027dd:	68 e3 15 81 00       	push   $0x8115e3
  8027e2:	68 a7 00 00 00       	push   $0xa7
  8027e7:	68 83 15 81 00       	push   $0x811583
  8027ec:	e8 46 c1 00 00       	call   80e937 <_panic>

008027f1 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8027f1:	f3 0f 1e fb          	endbr32 
  8027f5:	55                   	push   %ebp
  8027f6:	89 e5                	mov    %esp,%ebp
  8027f8:	53                   	push   %ebx
  8027f9:	83 ec 04             	sub    $0x4,%esp
  8027fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8027ff:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802802:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802805:	85 c0                	test   %eax,%eax
  802807:	74 28                	je     802831 <netbuf_data+0x40>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802809:	85 c9                	test   %ecx,%ecx
  80280b:	74 3b                	je     802848 <netbuf_data+0x57>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80280d:	85 d2                	test   %edx,%edx
  80280f:	74 4e                	je     80285f <netbuf_data+0x6e>

  if (buf->ptr == NULL) {
  802811:	8b 58 04             	mov    0x4(%eax),%ebx
  802814:	85 db                	test   %ebx,%ebx
  802816:	74 5e                	je     802876 <netbuf_data+0x85>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802818:	8b 5b 04             	mov    0x4(%ebx),%ebx
  80281b:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  80281d:	8b 40 04             	mov    0x4(%eax),%eax
  802820:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802824:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802827:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80282c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80282f:	c9                   	leave  
  802830:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802831:	83 ec 04             	sub    $0x4,%esp
  802834:	68 fe 15 81 00       	push   $0x8115fe
  802839:	68 b9 00 00 00       	push   $0xb9
  80283e:	68 83 15 81 00       	push   $0x811583
  802843:	e8 ef c0 00 00       	call   80e937 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802848:	83 ec 04             	sub    $0x4,%esp
  80284b:	68 17 16 81 00       	push   $0x811617
  802850:	68 ba 00 00 00       	push   $0xba
  802855:	68 83 15 81 00       	push   $0x811583
  80285a:	e8 d8 c0 00 00       	call   80e937 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80285f:	83 ec 04             	sub    $0x4,%esp
  802862:	68 34 16 81 00       	push   $0x811634
  802867:	68 bb 00 00 00       	push   $0xbb
  80286c:	68 83 15 81 00       	push   $0x811583
  802871:	e8 c1 c0 00 00       	call   80e937 <_panic>
    return ERR_BUF;
  802876:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80287b:	eb af                	jmp    80282c <netbuf_data+0x3b>

0080287d <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  80287d:	f3 0f 1e fb          	endbr32 
  802881:	55                   	push   %ebp
  802882:	89 e5                	mov    %esp,%ebp
  802884:	83 ec 08             	sub    $0x8,%esp
  802887:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  80288a:	85 c0                	test   %eax,%eax
  80288c:	74 14                	je     8028a2 <netbuf_next+0x25>
  if (buf->ptr->next == NULL) {
  80288e:	8b 50 04             	mov    0x4(%eax),%edx
  802891:	8b 12                	mov    (%edx),%edx
  802893:	85 d2                	test   %edx,%edx
  802895:	74 22                	je     8028b9 <netbuf_next+0x3c>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802897:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  80289a:	83 3a 00             	cmpl   $0x0,(%edx)
  80289d:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  8028a0:	c9                   	leave  
  8028a1:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8028a2:	83 ec 04             	sub    $0x4,%esp
  8028a5:	68 99 15 81 00       	push   $0x811599
  8028aa:	68 d2 00 00 00       	push   $0xd2
  8028af:	68 83 15 81 00       	push   $0x811583
  8028b4:	e8 7e c0 00 00       	call   80e937 <_panic>
    return -1;
  8028b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8028be:	eb e0                	jmp    8028a0 <netbuf_next+0x23>

008028c0 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8028c0:	f3 0f 1e fb          	endbr32 
  8028c4:	55                   	push   %ebp
  8028c5:	89 e5                	mov    %esp,%ebp
  8028c7:	83 ec 08             	sub    $0x8,%esp
  8028ca:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8028cd:	85 c0                	test   %eax,%eax
  8028cf:	74 07                	je     8028d8 <netbuf_first+0x18>
  buf->ptr = buf->p;
  8028d1:	8b 10                	mov    (%eax),%edx
  8028d3:	89 50 04             	mov    %edx,0x4(%eax)
}
  8028d6:	c9                   	leave  
  8028d7:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8028d8:	83 ec 04             	sub    $0x4,%esp
  8028db:	68 99 15 81 00       	push   $0x811599
  8028e0:	68 e7 00 00 00       	push   $0xe7
  8028e5:	68 83 15 81 00       	push   $0x811583
  8028ea:	e8 48 c0 00 00       	call   80e937 <_panic>

008028ef <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8028ef:	f3 0f 1e fb          	endbr32 
  8028f3:	55                   	push   %ebp
  8028f4:	89 e5                	mov    %esp,%ebp
  8028f6:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  8028f9:	e8 01 77 00 00       	call   809fff <sys_init>
  mem_init();
  8028fe:	e8 79 17 00 00       	call   80407c <mem_init>
  memp_init();
  802903:	e8 d6 1c 00 00       	call   8045de <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802908:	e8 f3 e5 ff ff       	call   800f00 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80290d:	c9                   	leave  
  80290e:	c3                   	ret    

0080290f <dhcp_set_state>:
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
  80290f:	38 10                	cmp    %dl,(%eax)
  802911:	74 06                	je     802919 <dhcp_set_state+0xa>
    dhcp->state = new_state;
  802913:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802915:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802919:	c3                   	ret    

0080291a <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80291a:	55                   	push   %ebp
  80291b:	89 e5                	mov    %esp,%ebp
  80291d:	57                   	push   %edi
  80291e:	56                   	push   %esi
  80291f:	53                   	push   %ebx
  802920:	83 ec 0c             	sub    $0xc,%esp
  802923:	89 45 e8             	mov    %eax,-0x18(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802926:	8b 48 14             	mov    0x14(%eax),%ecx
  802929:	85 c9                	test   %ecx,%ecx
  80292b:	74 19                	je     802946 <dhcp_get_option_ptr+0x2c>
  80292d:	89 d6                	mov    %edx,%esi
  80292f:	0f b7 78 18          	movzwl 0x18(%eax),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  802933:	b8 00 00 00 00       	mov    $0x0,%eax
  u8_t overload = DHCP_OVERLOAD_NONE;
  802938:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80293c:	66 85 ff             	test   %di,%di
  80293f:	75 2f                	jne    802970 <dhcp_get_option_ptr+0x56>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802941:	b9 00 00 00 00       	mov    $0x0,%ecx
}
  802946:	89 c8                	mov    %ecx,%eax
  802948:	83 c4 0c             	add    $0xc,%esp
  80294b:	5b                   	pop    %ebx
  80294c:	5e                   	pop    %esi
  80294d:	5f                   	pop    %edi
  80294e:	5d                   	pop    %ebp
  80294f:	c3                   	ret    
        offset += 2;
  802950:	8d 50 02             	lea    0x2(%eax),%edx
        overload = options[offset++];
  802953:	83 c0 03             	add    $0x3,%eax
  802956:	0f b7 d2             	movzwl %dx,%edx
  802959:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
  80295d:	88 5d ef             	mov    %bl,-0x11(%ebp)
  802960:	eb 0e                	jmp    802970 <dhcp_get_option_ptr+0x56>
        offset++;
  802962:	8d 50 01             	lea    0x1(%eax),%edx
        offset += 1 + options[offset];
  802965:	0f b7 d2             	movzwl %dx,%edx
  802968:	0f b6 14 11          	movzbl (%ecx,%edx,1),%edx
  80296c:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802970:	66 39 c7             	cmp    %ax,%di
  802973:	76 22                	jbe    802997 <dhcp_get_option_ptr+0x7d>
  802975:	0f b7 d8             	movzwl %ax,%ebx
  802978:	01 cb                	add    %ecx,%ebx
  80297a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  80297d:	0f b6 13             	movzbl (%ebx),%edx
  802980:	80 fa ff             	cmp    $0xff,%dl
  802983:	74 12                	je     802997 <dhcp_get_option_ptr+0x7d>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802985:	80 fa 34             	cmp    $0x34,%dl
  802988:	74 c6                	je     802950 <dhcp_get_option_ptr+0x36>
      else if (options[offset] == option_type) {
  80298a:	89 f3                	mov    %esi,%ebx
  80298c:	38 da                	cmp    %bl,%dl
  80298e:	75 d2                	jne    802962 <dhcp_get_option_ptr+0x48>
  802990:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802993:	89 d9                	mov    %ebx,%ecx
  802995:	eb af                	jmp    802946 <dhcp_get_option_ptr+0x2c>
  return NULL;
  802997:	b9 00 00 00 00       	mov    $0x0,%ecx
    if (overload != DHCP_OVERLOAD_NONE) {
  80299c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  8029a0:	84 c0                	test   %al,%al
  8029a2:	74 a2                	je     802946 <dhcp_get_option_ptr+0x2c>
      if (overload == DHCP_OVERLOAD_FILE) {
  8029a4:	3c 01                	cmp    $0x1,%al
  8029a6:	74 54                	je     8029fc <dhcp_get_option_ptr+0xe2>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8029a8:	80 7d ef 02          	cmpb   $0x2,-0x11(%ebp)
  8029ac:	74 5e                	je     802a0c <dhcp_get_option_ptr+0xf2>
        options = (u8_t *)&dhcp->msg_in->sname;
  8029ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8029b1:	8b 58 10             	mov    0x10(%eax),%ebx
  8029b4:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8029b7:	bf c0 00 00 00       	mov    $0xc0,%edi
      offset = 0;
  8029bc:	ba 00 00 00 00       	mov    $0x0,%edx
  8029c1:	89 f0                	mov    %esi,%eax
  8029c3:	88 45 f0             	mov    %al,-0x10(%ebp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8029c6:	0f b7 ca             	movzwl %dx,%ecx
  8029c9:	01 d9                	add    %ebx,%ecx
  8029cb:	0f b6 31             	movzbl (%ecx),%esi
  8029ce:	89 f0                	mov    %esi,%eax
  8029d0:	3c ff                	cmp    $0xff,%al
  8029d2:	74 48                	je     802a1c <dhcp_get_option_ptr+0x102>
        if (options[offset] == option_type) {
  8029d4:	89 f0                	mov    %esi,%eax
  8029d6:	3a 45 f0             	cmp    -0x10(%ebp),%al
  8029d9:	0f 84 67 ff ff ff    	je     802946 <dhcp_get_option_ptr+0x2c>
          offset++;
  8029df:	8d 4a 01             	lea    0x1(%edx),%ecx
          offset += 1 + options[offset];
  8029e2:	0f b7 c9             	movzwl %cx,%ecx
  8029e5:	0f b6 0c 0b          	movzbl (%ebx,%ecx,1),%ecx
  8029e9:	8d 54 0a 02          	lea    0x2(%edx,%ecx,1),%edx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8029ed:	66 39 d7             	cmp    %dx,%di
  8029f0:	77 d4                	ja     8029c6 <dhcp_get_option_ptr+0xac>
  return NULL;
  8029f2:	b9 00 00 00 00       	mov    $0x0,%ecx
  8029f7:	e9 4a ff ff ff       	jmp    802946 <dhcp_get_option_ptr+0x2c>
        options = (u8_t *)&dhcp->msg_in->file;
  8029fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8029ff:	8b 58 10             	mov    0x10(%eax),%ebx
  802a02:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  802a05:	bf 80 00 00 00       	mov    $0x80,%edi
  802a0a:	eb b0                	jmp    8029bc <dhcp_get_option_ptr+0xa2>
        options = (u8_t *)&dhcp->msg_in->sname;
  802a0c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  802a0f:	8b 58 10             	mov    0x10(%eax),%ebx
  802a12:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  802a15:	bf 40 00 00 00       	mov    $0x40,%edi
  802a1a:	eb a0                	jmp    8029bc <dhcp_get_option_ptr+0xa2>
  return NULL;
  802a1c:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a21:	e9 20 ff ff ff       	jmp    802946 <dhcp_get_option_ptr+0x2c>

00802a26 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802a26:	89 c2                	mov    %eax,%edx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802a28:	0f b6 00             	movzbl (%eax),%eax
  802a2b:	c1 e0 18             	shl    $0x18,%eax
  802a2e:	89 c1                	mov    %eax,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802a30:	0f b6 42 01          	movzbl 0x1(%edx),%eax
  802a34:	c1 e0 10             	shl    $0x10,%eax
  802a37:	09 c8                	or     %ecx,%eax
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802a39:	0f b6 4a 03          	movzbl 0x3(%edx),%ecx
  802a3d:	09 c8                	or     %ecx,%eax
  value |= (u32_t)(*ptr++) << 8;
  802a3f:	0f b6 52 02          	movzbl 0x2(%edx),%edx
  802a43:	c1 e2 08             	shl    $0x8,%edx
  value |= (u32_t)(*ptr++);
  802a46:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802a48:	c3                   	ret    

00802a49 <dhcp_option_byte>:
{
  802a49:	55                   	push   %ebp
  802a4a:	89 e5                	mov    %esp,%ebp
  802a4c:	56                   	push   %esi
  802a4d:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a4e:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a52:	66 83 f9 43          	cmp    $0x43,%cx
  802a56:	77 1b                	ja     802a73 <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802a58:	8b 58 20             	mov    0x20(%eax),%ebx
  802a5b:	8d 71 01             	lea    0x1(%ecx),%esi
  802a5e:	66 89 70 24          	mov    %si,0x24(%eax)
  802a62:	0f b7 c9             	movzwl %cx,%ecx
  802a65:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802a6c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802a6f:	5b                   	pop    %ebx
  802a70:	5e                   	pop    %esi
  802a71:	5d                   	pop    %ebp
  802a72:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a73:	83 ec 04             	sub    $0x4,%esp
  802a76:	68 74 16 81 00       	push   $0x811674
  802a7b:	68 65 04 00 00       	push   $0x465
  802a80:	68 c2 19 81 00       	push   $0x8119c2
  802a85:	e8 ad be 00 00       	call   80e937 <_panic>

00802a8a <dhcp_option>:
{
  802a8a:	55                   	push   %ebp
  802a8b:	89 e5                	mov    %esp,%ebp
  802a8d:	57                   	push   %edi
  802a8e:	56                   	push   %esi
  802a8f:	53                   	push   %ebx
  802a90:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802a93:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802a97:	0f b6 f9             	movzbl %cl,%edi
  802a9a:	0f b7 f3             	movzwl %bx,%esi
  802a9d:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802aa1:	83 fe 44             	cmp    $0x44,%esi
  802aa4:	77 34                	ja     802ada <dhcp_option+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802aa6:	8b 70 20             	mov    0x20(%eax),%esi
  802aa9:	8d 7b 01             	lea    0x1(%ebx),%edi
  802aac:	66 89 78 24          	mov    %di,0x24(%eax)
  802ab0:	0f b7 db             	movzwl %bx,%ebx
  802ab3:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802aba:	8b 58 20             	mov    0x20(%eax),%ebx
  802abd:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802ac1:	8d 72 01             	lea    0x1(%edx),%esi
  802ac4:	66 89 70 24          	mov    %si,0x24(%eax)
  802ac8:	0f b7 d2             	movzwl %dx,%edx
  802acb:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  802ad2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802ad5:	5b                   	pop    %ebx
  802ad6:	5e                   	pop    %esi
  802ad7:	5f                   	pop    %edi
  802ad8:	5d                   	pop    %ebp
  802ad9:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802ada:	83 ec 04             	sub    $0x4,%esp
  802add:	68 b0 16 81 00       	push   $0x8116b0
  802ae2:	68 5a 04 00 00       	push   $0x45a
  802ae7:	68 c2 19 81 00       	push   $0x8119c2
  802aec:	e8 46 be 00 00       	call   80e937 <_panic>

00802af1 <dhcp_option_short>:
{
  802af1:	55                   	push   %ebp
  802af2:	89 e5                	mov    %esp,%ebp
  802af4:	56                   	push   %esi
  802af5:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802af6:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802afa:	0f b7 d9             	movzwl %cx,%ebx
  802afd:	83 c3 02             	add    $0x2,%ebx
  802b00:	83 fb 44             	cmp    $0x44,%ebx
  802b03:	77 33                	ja     802b38 <dhcp_option_short+0x47>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802b05:	8b 58 20             	mov    0x20(%eax),%ebx
  802b08:	8d 71 01             	lea    0x1(%ecx),%esi
  802b0b:	66 89 70 24          	mov    %si,0x24(%eax)
  802b0f:	0f b7 c9             	movzwl %cx,%ecx
  802b12:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802b19:	8b 58 20             	mov    0x20(%eax),%ebx
  802b1c:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b20:	8d 71 01             	lea    0x1(%ecx),%esi
  802b23:	66 89 70 24          	mov    %si,0x24(%eax)
  802b27:	0f b7 c9             	movzwl %cx,%ecx
  802b2a:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802b31:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802b34:	5b                   	pop    %ebx
  802b35:	5e                   	pop    %esi
  802b36:	5d                   	pop    %ebp
  802b37:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802b38:	83 ec 04             	sub    $0x4,%esp
  802b3b:	68 f8 16 81 00       	push   $0x8116f8
  802b40:	68 6c 04 00 00       	push   $0x46c
  802b45:	68 c2 19 81 00       	push   $0x8119c2
  802b4a:	e8 e8 bd 00 00       	call   80e937 <_panic>

00802b4f <dhcp_option_trailer>:
{
  802b4f:	55                   	push   %ebp
  802b50:	89 e5                	mov    %esp,%ebp
  802b52:	53                   	push   %ebx
  802b53:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802b56:	85 c0                	test   %eax,%eax
  802b58:	74 25                	je     802b7f <dhcp_option_trailer+0x30>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802b5a:	8b 48 20             	mov    0x20(%eax),%ecx
  802b5d:	85 c9                	test   %ecx,%ecx
  802b5f:	74 35                	je     802b96 <dhcp_option_trailer+0x47>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802b61:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802b65:	66 83 fa 43          	cmp    $0x43,%dx
  802b69:	77 42                	ja     802bad <dhcp_option_trailer+0x5e>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802b6b:	8d 5a 01             	lea    0x1(%edx),%ebx
  802b6e:	66 89 58 24          	mov    %bx,0x24(%eax)
  802b72:	0f b7 d2             	movzwl %dx,%edx
  802b75:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802b7c:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802b7d:	eb 5a                	jmp    802bd9 <dhcp_option_trailer+0x8a>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802b7f:	83 ec 04             	sub    $0x4,%esp
  802b82:	68 3c 17 81 00       	push   $0x81173c
  802b87:	68 80 05 00 00       	push   $0x580
  802b8c:	68 c2 19 81 00       	push   $0x8119c2
  802b91:	e8 a1 bd 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802b96:	83 ec 04             	sub    $0x4,%esp
  802b99:	68 60 17 81 00       	push   $0x811760
  802b9e:	68 81 05 00 00       	push   $0x581
  802ba3:	68 c2 19 81 00       	push   $0x8119c2
  802ba8:	e8 8a bd 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802bad:	83 ec 04             	sub    $0x4,%esp
  802bb0:	68 8c 17 81 00       	push   $0x81178c
  802bb5:	68 82 05 00 00       	push   $0x582
  802bba:	68 c2 19 81 00       	push   $0x8119c2
  802bbf:	e8 73 bd 00 00       	call   80e937 <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802bc4:	8b 48 20             	mov    0x20(%eax),%ecx
  802bc7:	8d 5a 01             	lea    0x1(%edx),%ebx
  802bca:	66 89 58 24          	mov    %bx,0x24(%eax)
  802bce:	0f b7 d2             	movzwl %dx,%edx
  802bd1:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802bd8:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802bd9:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802bdd:	66 83 fa 43          	cmp    $0x43,%dx
  802be1:	76 e1                	jbe    802bc4 <dhcp_option_trailer+0x75>
  802be3:	f6 c2 03             	test   $0x3,%dl
  802be6:	74 17                	je     802bff <dhcp_option_trailer+0xb0>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802be8:	83 ec 04             	sub    $0x4,%esp
  802beb:	68 8c 17 81 00       	push   $0x81178c
  802bf0:	68 87 05 00 00       	push   $0x587
  802bf5:	68 c2 19 81 00       	push   $0x8119c2
  802bfa:	e8 38 bd 00 00       	call   80e937 <_panic>
}
  802bff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802c02:	c9                   	leave  
  802c03:	c3                   	ret    

00802c04 <dhcp_option_long>:
{
  802c04:	55                   	push   %ebp
  802c05:	89 e5                	mov    %esp,%ebp
  802c07:	56                   	push   %esi
  802c08:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802c09:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c0d:	0f b7 d9             	movzwl %cx,%ebx
  802c10:	83 c3 04             	add    $0x4,%ebx
  802c13:	83 fb 44             	cmp    $0x44,%ebx
  802c16:	77 6d                	ja     802c85 <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802c18:	8d 71 01             	lea    0x1(%ecx),%esi
  802c1b:	66 89 70 24          	mov    %si,0x24(%eax)
  802c1f:	0f b7 c9             	movzwl %cx,%ecx
  802c22:	89 d3                	mov    %edx,%ebx
  802c24:	c1 eb 18             	shr    $0x18,%ebx
  802c27:	8b 70 20             	mov    0x20(%eax),%esi
  802c2a:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802c31:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c35:	8d 71 01             	lea    0x1(%ecx),%esi
  802c38:	66 89 70 24          	mov    %si,0x24(%eax)
  802c3c:	0f b7 c9             	movzwl %cx,%ecx
  802c3f:	89 d3                	mov    %edx,%ebx
  802c41:	c1 eb 10             	shr    $0x10,%ebx
  802c44:	8b 70 20             	mov    0x20(%eax),%esi
  802c47:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802c4e:	8b 58 20             	mov    0x20(%eax),%ebx
  802c51:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c55:	8d 71 01             	lea    0x1(%ecx),%esi
  802c58:	66 89 70 24          	mov    %si,0x24(%eax)
  802c5c:	0f b7 c9             	movzwl %cx,%ecx
  802c5f:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802c66:	8b 58 20             	mov    0x20(%eax),%ebx
  802c69:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c6d:	8d 71 01             	lea    0x1(%ecx),%esi
  802c70:	66 89 70 24          	mov    %si,0x24(%eax)
  802c74:	0f b7 c9             	movzwl %cx,%ecx
  802c77:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802c7e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802c81:	5b                   	pop    %ebx
  802c82:	5e                   	pop    %esi
  802c83:	5d                   	pop    %ebp
  802c84:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802c85:	83 ec 04             	sub    $0x4,%esp
  802c88:	68 cc 17 81 00       	push   $0x8117cc
  802c8d:	68 74 04 00 00       	push   $0x474
  802c92:	68 c2 19 81 00       	push   $0x8119c2
  802c97:	e8 9b bc 00 00       	call   80e937 <_panic>

00802c9c <dhcp_create_request>:
{
  802c9c:	55                   	push   %ebp
  802c9d:	89 e5                	mov    %esp,%ebp
  802c9f:	57                   	push   %edi
  802ca0:	56                   	push   %esi
  802ca1:	53                   	push   %ebx
  802ca2:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802ca5:	85 c0                	test   %eax,%eax
  802ca7:	0f 84 d8 00 00 00    	je     802d85 <dhcp_create_request+0xe9>
  802cad:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802caf:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802cb2:	85 db                	test   %ebx,%ebx
  802cb4:	0f 84 e2 00 00 00    	je     802d9c <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802cba:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802cbe:	0f 85 ef 00 00 00    	jne    802db3 <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802cc4:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802cc8:	0f 85 fc 00 00 00    	jne    802dca <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802cce:	83 ec 04             	sub    $0x4,%esp
  802cd1:	6a 00                	push   $0x0
  802cd3:	68 34 01 00 00       	push   $0x134
  802cd8:	6a 00                	push   $0x0
  802cda:	e8 06 1e 00 00       	call   804ae5 <pbuf_alloc>
  802cdf:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802ce2:	83 c4 10             	add    $0x10,%esp
  802ce5:	85 c0                	test   %eax,%eax
  802ce7:	0f 84 9b 01 00 00    	je     802e88 <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802ced:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802cf3:	0f 86 e8 00 00 00    	jbe    802de1 <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802cf9:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802cff:	8d 4a 01             	lea    0x1(%edx),%ecx
  802d02:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802d08:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802d0b:	8b 40 04             	mov    0x4(%eax),%eax
  802d0e:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802d11:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802d14:	8b 43 20             	mov    0x20(%ebx),%eax
  802d17:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802d1b:	8b 43 20             	mov    0x20(%ebx),%eax
  802d1e:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802d22:	8b 43 20             	mov    0x20(%ebx),%eax
  802d25:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802d29:	8b 7b 20             	mov    0x20(%ebx),%edi
  802d2c:	83 ec 0c             	sub    $0xc,%esp
  802d2f:	ff 73 04             	pushl  0x4(%ebx)
  802d32:	e8 3e 4c 00 00       	call   807975 <htonl>
  802d37:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802d3a:	8b 43 20             	mov    0x20(%ebx),%eax
  802d3d:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802d43:	8b 43 20             	mov    0x20(%ebx),%eax
  802d46:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802d4c:	8b 43 20             	mov    0x20(%ebx),%eax
  802d4f:	8b 56 04             	mov    0x4(%esi),%edx
  802d52:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802d55:	8b 43 20             	mov    0x20(%ebx),%eax
  802d58:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802d5f:	8b 43 20             	mov    0x20(%ebx),%eax
  802d62:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802d69:	8b 43 20             	mov    0x20(%ebx),%eax
  802d6c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802d73:	83 c4 10             	add    $0x10,%esp
  802d76:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802d7b:	bf 00 00 00 00       	mov    $0x0,%edi
  802d80:	e9 82 00 00 00       	jmp    802e07 <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802d85:	83 ec 04             	sub    $0x4,%esp
  802d88:	68 0c 18 81 00       	push   $0x81180c
  802d8d:	68 2d 05 00 00       	push   $0x52d
  802d92:	68 c2 19 81 00       	push   $0x8119c2
  802d97:	e8 9b bb 00 00       	call   80e937 <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802d9c:	83 ec 04             	sub    $0x4,%esp
  802d9f:	68 30 18 81 00       	push   $0x811830
  802da4:	68 2f 05 00 00       	push   $0x52f
  802da9:	68 c2 19 81 00       	push   $0x8119c2
  802dae:	e8 84 bb 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802db3:	83 ec 04             	sub    $0x4,%esp
  802db6:	68 54 18 81 00       	push   $0x811854
  802dbb:	68 30 05 00 00       	push   $0x530
  802dc0:	68 c2 19 81 00       	push   $0x8119c2
  802dc5:	e8 6d bb 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802dca:	83 ec 04             	sub    $0x4,%esp
  802dcd:	68 80 18 81 00       	push   $0x811880
  802dd2:	68 31 05 00 00       	push   $0x531
  802dd7:	68 c2 19 81 00       	push   $0x8119c2
  802ddc:	e8 56 bb 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802de1:	83 ec 04             	sub    $0x4,%esp
  802de4:	68 ac 18 81 00       	push   $0x8118ac
  802de9:	68 37 05 00 00       	push   $0x537
  802dee:	68 c2 19 81 00       	push   $0x8119c2
  802df3:	e8 3f bb 00 00       	call   80e937 <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802df8:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802dfb:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  802dff:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802e02:	83 f8 10             	cmp    $0x10,%eax
  802e05:	74 12                	je     802e19 <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802e07:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802e0b:	89 fa                	mov    %edi,%edx
  802e0d:	66 39 c1             	cmp    %ax,%cx
  802e10:	76 e6                	jbe    802df8 <dhcp_create_request+0x15c>
  802e12:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802e17:	eb df                	jmp    802df8 <dhcp_create_request+0x15c>
  802e19:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802e1e:	8b 53 20             	mov    0x20(%ebx),%edx
  802e21:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802e26:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802e29:	83 f8 40             	cmp    $0x40,%eax
  802e2c:	75 f0                	jne    802e1e <dhcp_create_request+0x182>
  802e2e:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802e33:	8b 53 20             	mov    0x20(%ebx),%edx
  802e36:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802e3b:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802e3e:	3d 80 00 00 00       	cmp    $0x80,%eax
  802e43:	75 ee                	jne    802e33 <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802e45:	8b 73 20             	mov    0x20(%ebx),%esi
  802e48:	83 ec 0c             	sub    $0xc,%esp
  802e4b:	68 63 53 82 63       	push   $0x63825363
  802e50:	e8 20 4b 00 00       	call   807975 <htonl>
  802e55:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802e5b:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802e61:	83 c4 10             	add    $0x10,%esp
  802e64:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802e69:	8b 53 20             	mov    0x20(%ebx),%edx
  802e6c:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802e73:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802e76:	83 f8 44             	cmp    $0x44,%eax
  802e79:	75 ee                	jne    802e69 <dhcp_create_request+0x1cd>
  return ERR_OK;
  802e7b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802e80:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802e83:	5b                   	pop    %ebx
  802e84:	5e                   	pop    %esi
  802e85:	5f                   	pop    %edi
  802e86:	5d                   	pop    %ebp
  802e87:	c3                   	ret    
    return ERR_MEM;
  802e88:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802e8d:	eb f1                	jmp    802e80 <dhcp_create_request+0x1e4>

00802e8f <dhcp_delete_request>:
{
  802e8f:	55                   	push   %ebp
  802e90:	89 e5                	mov    %esp,%ebp
  802e92:	53                   	push   %ebx
  802e93:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802e96:	85 c0                	test   %eax,%eax
  802e98:	74 33                	je     802ecd <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802e9a:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802e9d:	85 db                	test   %ebx,%ebx
  802e9f:	74 43                	je     802ee4 <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802ea1:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802ea4:	85 c0                	test   %eax,%eax
  802ea6:	74 53                	je     802efb <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802ea8:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802eac:	74 64                	je     802f12 <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802eae:	83 ec 0c             	sub    $0xc,%esp
  802eb1:	50                   	push   %eax
  802eb2:	e8 64 1b 00 00       	call   804a1b <pbuf_free>
  dhcp->p_out = NULL;
  802eb7:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802ebe:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802ec5:	83 c4 10             	add    $0x10,%esp
}
  802ec8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802ecb:	c9                   	leave  
  802ecc:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802ecd:	83 ec 04             	sub    $0x4,%esp
  802ed0:	68 f0 18 81 00       	push   $0x8118f0
  802ed5:	68 69 05 00 00       	push   $0x569
  802eda:	68 c2 19 81 00       	push   $0x8119c2
  802edf:	e8 53 ba 00 00       	call   80e937 <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802ee4:	83 ec 04             	sub    $0x4,%esp
  802ee7:	68 14 19 81 00       	push   $0x811914
  802eec:	68 6b 05 00 00       	push   $0x56b
  802ef1:	68 c2 19 81 00       	push   $0x8119c2
  802ef6:	e8 3c ba 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802efb:	83 ec 04             	sub    $0x4,%esp
  802efe:	68 38 19 81 00       	push   $0x811938
  802f03:	68 6c 05 00 00       	push   $0x56c
  802f08:	68 c2 19 81 00       	push   $0x8119c2
  802f0d:	e8 25 ba 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802f12:	83 ec 04             	sub    $0x4,%esp
  802f15:	68 64 19 81 00       	push   $0x811964
  802f1a:	68 6d 05 00 00       	push   $0x56d
  802f1f:	68 c2 19 81 00       	push   $0x8119c2
  802f24:	e8 0e ba 00 00       	call   80e937 <_panic>

00802f29 <dhcp_rebind>:
{
  802f29:	55                   	push   %ebp
  802f2a:	89 e5                	mov    %esp,%ebp
  802f2c:	57                   	push   %edi
  802f2d:	56                   	push   %esi
  802f2e:	53                   	push   %ebx
  802f2f:	83 ec 0c             	sub    $0xc,%esp
  802f32:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f34:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802f37:	ba 04 00 00 00       	mov    $0x4,%edx
  802f3c:	89 d8                	mov    %ebx,%eax
  802f3e:	e8 cc f9 ff ff       	call   80290f <dhcp_set_state>
  result = dhcp_create_request(netif);
  802f43:	89 f8                	mov    %edi,%eax
  802f45:	e8 52 fd ff ff       	call   802c9c <dhcp_create_request>
  802f4a:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f4c:	84 c0                	test   %al,%al
  802f4e:	74 3e                	je     802f8e <dhcp_rebind+0x65>
  dhcp->tries++;
  802f50:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802f54:	83 c0 01             	add    $0x1,%eax
  802f57:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802f5a:	ba 10 27 00 00       	mov    $0x2710,%edx
  802f5f:	3c 09                	cmp    $0x9,%al
  802f61:	77 08                	ja     802f6b <dhcp_rebind+0x42>
  802f63:	0f b6 d0             	movzbl %al,%edx
  802f66:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802f6b:	0f b7 d2             	movzwl %dx,%edx
  802f6e:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802f74:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802f79:	89 d0                	mov    %edx,%eax
  802f7b:	f7 e9                	imul   %ecx
  802f7d:	c1 fa 05             	sar    $0x5,%edx
  802f80:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802f84:	89 f0                	mov    %esi,%eax
  802f86:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802f89:	5b                   	pop    %ebx
  802f8a:	5e                   	pop    %esi
  802f8b:	5f                   	pop    %edi
  802f8c:	5d                   	pop    %ebp
  802f8d:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802f8e:	b9 01 00 00 00       	mov    $0x1,%ecx
  802f93:	ba 35 00 00 00       	mov    $0x35,%edx
  802f98:	89 d8                	mov    %ebx,%eax
  802f9a:	e8 eb fa ff ff       	call   802a8a <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802f9f:	ba 03 00 00 00       	mov    $0x3,%edx
  802fa4:	89 d8                	mov    %ebx,%eax
  802fa6:	e8 9e fa ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802fab:	b9 02 00 00 00       	mov    $0x2,%ecx
  802fb0:	ba 39 00 00 00       	mov    $0x39,%edx
  802fb5:	89 d8                	mov    %ebx,%eax
  802fb7:	e8 ce fa ff ff       	call   802a8a <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802fbc:	ba 40 02 00 00       	mov    $0x240,%edx
  802fc1:	89 d8                	mov    %ebx,%eax
  802fc3:	e8 29 fb ff ff       	call   802af1 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  802fc8:	89 d8                	mov    %ebx,%eax
  802fca:	e8 80 fb ff ff       	call   802b4f <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802fcf:	83 ec 08             	sub    $0x8,%esp
  802fd2:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802fd6:	66 05 f0 00          	add    $0xf0,%ax
  802fda:	0f b7 c0             	movzwl %ax,%eax
  802fdd:	50                   	push   %eax
  802fde:	ff 73 1c             	pushl  0x1c(%ebx)
  802fe1:	e8 5e 1d 00 00       	call   804d44 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802fe6:	83 c4 0c             	add    $0xc,%esp
  802fe9:	6a 43                	push   $0x43
  802feb:	68 68 22 81 00       	push   $0x812268
  802ff0:	ff 73 08             	pushl  0x8(%ebx)
  802ff3:	e8 c0 61 00 00       	call   8091b8 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802ff8:	89 3c 24             	mov    %edi,(%esp)
  802ffb:	6a 43                	push   $0x43
  802ffd:	68 64 22 81 00       	push   $0x812264
  803002:	ff 73 1c             	pushl  0x1c(%ebx)
  803005:	ff 73 08             	pushl  0x8(%ebx)
  803008:	e8 aa 5f 00 00       	call   808fb7 <udp_sendto_if>
    dhcp_delete_request(netif);
  80300d:	83 c4 20             	add    $0x20,%esp
  803010:	89 f8                	mov    %edi,%eax
  803012:	e8 78 fe ff ff       	call   802e8f <dhcp_delete_request>
  803017:	e9 34 ff ff ff       	jmp    802f50 <dhcp_rebind+0x27>

0080301c <dhcp_discover>:
{
  80301c:	55                   	push   %ebp
  80301d:	89 e5                	mov    %esp,%ebp
  80301f:	57                   	push   %edi
  803020:	56                   	push   %esi
  803021:	53                   	push   %ebx
  803022:	83 ec 0c             	sub    $0xc,%esp
  803025:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803027:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  80302a:	a1 68 22 81 00       	mov    0x812268,%eax
  80302f:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  803032:	89 f8                	mov    %edi,%eax
  803034:	e8 63 fc ff ff       	call   802c9c <dhcp_create_request>
  803039:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80303b:	84 c0                	test   %al,%al
  80303d:	74 41                	je     803080 <dhcp_discover+0x64>
  dhcp->tries++;
  80303f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803043:	83 c0 01             	add    $0x1,%eax
  803046:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  803049:	ba 10 27 00 00       	mov    $0x2710,%edx
  80304e:	3c 03                	cmp    $0x3,%al
  803050:	77 0b                	ja     80305d <dhcp_discover+0x41>
  803052:	0f b6 d0             	movzbl %al,%edx
  803055:	83 c2 01             	add    $0x1,%edx
  803058:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80305d:	0f b7 d2             	movzwl %dx,%edx
  803060:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803066:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80306b:	89 d0                	mov    %edx,%eax
  80306d:	f7 e9                	imul   %ecx
  80306f:	c1 fa 05             	sar    $0x5,%edx
  803072:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803076:	89 f0                	mov    %esi,%eax
  803078:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80307b:	5b                   	pop    %ebx
  80307c:	5e                   	pop    %esi
  80307d:	5f                   	pop    %edi
  80307e:	5d                   	pop    %ebp
  80307f:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803080:	b9 01 00 00 00       	mov    $0x1,%ecx
  803085:	ba 35 00 00 00       	mov    $0x35,%edx
  80308a:	89 d8                	mov    %ebx,%eax
  80308c:	e8 f9 f9 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  803091:	ba 01 00 00 00       	mov    $0x1,%edx
  803096:	89 d8                	mov    %ebx,%eax
  803098:	e8 ac f9 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80309d:	b9 02 00 00 00       	mov    $0x2,%ecx
  8030a2:	ba 39 00 00 00       	mov    $0x39,%edx
  8030a7:	89 d8                	mov    %ebx,%eax
  8030a9:	e8 dc f9 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8030ae:	ba 40 02 00 00       	mov    $0x240,%edx
  8030b3:	89 d8                	mov    %ebx,%eax
  8030b5:	e8 37 fa ff ff       	call   802af1 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8030ba:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030bf:	ba 37 00 00 00       	mov    $0x37,%edx
  8030c4:	89 d8                	mov    %ebx,%eax
  8030c6:	e8 bf f9 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8030cb:	ba 01 00 00 00       	mov    $0x1,%edx
  8030d0:	89 d8                	mov    %ebx,%eax
  8030d2:	e8 72 f9 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8030d7:	ba 03 00 00 00       	mov    $0x3,%edx
  8030dc:	89 d8                	mov    %ebx,%eax
  8030de:	e8 66 f9 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8030e3:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8030e8:	89 d8                	mov    %ebx,%eax
  8030ea:	e8 5a f9 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8030ef:	ba 06 00 00 00       	mov    $0x6,%edx
  8030f4:	89 d8                	mov    %ebx,%eax
  8030f6:	e8 4e f9 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  8030fb:	89 d8                	mov    %ebx,%eax
  8030fd:	e8 4d fa ff ff       	call   802b4f <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803102:	83 ec 08             	sub    $0x8,%esp
  803105:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803109:	66 05 f0 00          	add    $0xf0,%ax
  80310d:	0f b7 c0             	movzwl %ax,%eax
  803110:	50                   	push   %eax
  803111:	ff 73 1c             	pushl  0x1c(%ebx)
  803114:	e8 2b 1c 00 00       	call   804d44 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803119:	83 c4 0c             	add    $0xc,%esp
  80311c:	6a 43                	push   $0x43
  80311e:	68 68 22 81 00       	push   $0x812268
  803123:	ff 73 08             	pushl  0x8(%ebx)
  803126:	e8 8d 60 00 00       	call   8091b8 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80312b:	89 3c 24             	mov    %edi,(%esp)
  80312e:	6a 43                	push   $0x43
  803130:	68 64 22 81 00       	push   $0x812264
  803135:	ff 73 1c             	pushl  0x1c(%ebx)
  803138:	ff 73 08             	pushl  0x8(%ebx)
  80313b:	e8 77 5e 00 00       	call   808fb7 <udp_sendto_if>
    dhcp_delete_request(netif);
  803140:	83 c4 20             	add    $0x20,%esp
  803143:	89 f8                	mov    %edi,%eax
  803145:	e8 45 fd ff ff       	call   802e8f <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80314a:	ba 06 00 00 00       	mov    $0x6,%edx
  80314f:	89 d8                	mov    %ebx,%eax
  803151:	e8 b9 f7 ff ff       	call   80290f <dhcp_set_state>
  803156:	e9 e4 fe ff ff       	jmp    80303f <dhcp_discover+0x23>

0080315b <dhcp_select>:
{
  80315b:	55                   	push   %ebp
  80315c:	89 e5                	mov    %esp,%ebp
  80315e:	57                   	push   %edi
  80315f:	56                   	push   %esi
  803160:	53                   	push   %ebx
  803161:	83 ec 0c             	sub    $0xc,%esp
  803164:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803166:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  803169:	e8 2e fb ff ff       	call   802c9c <dhcp_create_request>
  80316e:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803170:	84 c0                	test   %al,%al
  803172:	74 3e                	je     8031b2 <dhcp_select+0x57>
  dhcp->tries++;
  803174:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803178:	83 c0 01             	add    $0x1,%eax
  80317b:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  80317e:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  803183:	3c 03                	cmp    $0x3,%al
  803185:	77 08                	ja     80318f <dhcp_select+0x34>
  803187:	0f b6 d0             	movzbl %al,%edx
  80318a:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80318f:	0f b7 d2             	movzwl %dx,%edx
  803192:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803198:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80319d:	89 d0                	mov    %edx,%eax
  80319f:	f7 e9                	imul   %ecx
  8031a1:	c1 fa 05             	sar    $0x5,%edx
  8031a4:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  8031a8:	89 f0                	mov    %esi,%eax
  8031aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8031ad:	5b                   	pop    %ebx
  8031ae:	5e                   	pop    %esi
  8031af:	5f                   	pop    %edi
  8031b0:	5d                   	pop    %ebp
  8031b1:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8031b2:	b9 01 00 00 00       	mov    $0x1,%ecx
  8031b7:	ba 35 00 00 00       	mov    $0x35,%edx
  8031bc:	89 d8                	mov    %ebx,%eax
  8031be:	e8 c7 f8 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8031c3:	ba 03 00 00 00       	mov    $0x3,%edx
  8031c8:	89 d8                	mov    %ebx,%eax
  8031ca:	e8 7a f8 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8031cf:	b9 02 00 00 00       	mov    $0x2,%ecx
  8031d4:	ba 39 00 00 00       	mov    $0x39,%edx
  8031d9:	89 d8                	mov    %ebx,%eax
  8031db:	e8 aa f8 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8031e0:	ba 40 02 00 00       	mov    $0x240,%edx
  8031e5:	89 d8                	mov    %ebx,%eax
  8031e7:	e8 05 f9 ff ff       	call   802af1 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8031ec:	b9 04 00 00 00       	mov    $0x4,%ecx
  8031f1:	ba 32 00 00 00       	mov    $0x32,%edx
  8031f6:	89 d8                	mov    %ebx,%eax
  8031f8:	e8 8d f8 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8031fd:	83 ec 0c             	sub    $0xc,%esp
  803200:	ff 73 30             	pushl  0x30(%ebx)
  803203:	e8 9a 49 00 00       	call   807ba2 <ntohl>
  803208:	89 c2                	mov    %eax,%edx
  80320a:	89 d8                	mov    %ebx,%eax
  80320c:	e8 f3 f9 ff ff       	call   802c04 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  803211:	b9 04 00 00 00       	mov    $0x4,%ecx
  803216:	ba 36 00 00 00       	mov    $0x36,%edx
  80321b:	89 d8                	mov    %ebx,%eax
  80321d:	e8 68 f8 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  803222:	83 c4 04             	add    $0x4,%esp
  803225:	ff 73 2c             	pushl  0x2c(%ebx)
  803228:	e8 75 49 00 00       	call   807ba2 <ntohl>
  80322d:	89 c2                	mov    %eax,%edx
  80322f:	89 d8                	mov    %ebx,%eax
  803231:	e8 ce f9 ff ff       	call   802c04 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803236:	b9 04 00 00 00       	mov    $0x4,%ecx
  80323b:	ba 37 00 00 00       	mov    $0x37,%edx
  803240:	89 d8                	mov    %ebx,%eax
  803242:	e8 43 f8 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803247:	ba 01 00 00 00       	mov    $0x1,%edx
  80324c:	89 d8                	mov    %ebx,%eax
  80324e:	e8 f6 f7 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803253:	ba 03 00 00 00       	mov    $0x3,%edx
  803258:	89 d8                	mov    %ebx,%eax
  80325a:	e8 ea f7 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80325f:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803264:	89 d8                	mov    %ebx,%eax
  803266:	e8 de f7 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80326b:	ba 06 00 00 00       	mov    $0x6,%edx
  803270:	89 d8                	mov    %ebx,%eax
  803272:	e8 d2 f7 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803277:	89 d8                	mov    %ebx,%eax
  803279:	e8 d1 f8 ff ff       	call   802b4f <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80327e:	83 c4 08             	add    $0x8,%esp
  803281:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803285:	66 05 f0 00          	add    $0xf0,%ax
  803289:	0f b7 c0             	movzwl %ax,%eax
  80328c:	50                   	push   %eax
  80328d:	ff 73 1c             	pushl  0x1c(%ebx)
  803290:	e8 af 1a 00 00       	call   804d44 <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803295:	89 3c 24             	mov    %edi,(%esp)
  803298:	6a 43                	push   $0x43
  80329a:	68 64 22 81 00       	push   $0x812264
  80329f:	ff 73 1c             	pushl  0x1c(%ebx)
  8032a2:	ff 73 08             	pushl  0x8(%ebx)
  8032a5:	e8 0d 5d 00 00       	call   808fb7 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8032aa:	83 c4 1c             	add    $0x1c,%esp
  8032ad:	6a 43                	push   $0x43
  8032af:	68 68 22 81 00       	push   $0x812268
  8032b4:	ff 73 08             	pushl  0x8(%ebx)
  8032b7:	e8 fc 5e 00 00       	call   8091b8 <udp_connect>
    dhcp_delete_request(netif);
  8032bc:	89 f8                	mov    %edi,%eax
  8032be:	e8 cc fb ff ff       	call   802e8f <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8032c3:	ba 01 00 00 00       	mov    $0x1,%edx
  8032c8:	89 d8                	mov    %ebx,%eax
  8032ca:	e8 40 f6 ff ff       	call   80290f <dhcp_set_state>
  8032cf:	83 c4 10             	add    $0x10,%esp
  8032d2:	e9 9d fe ff ff       	jmp    803174 <dhcp_select+0x19>

008032d7 <dhcp_check>:
{
  8032d7:	55                   	push   %ebp
  8032d8:	89 e5                	mov    %esp,%ebp
  8032da:	53                   	push   %ebx
  8032db:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  8032de:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8032e1:	6a 00                	push   $0x0
  8032e3:	8d 53 30             	lea    0x30(%ebx),%edx
  8032e6:	52                   	push   %edx
  8032e7:	50                   	push   %eax
  8032e8:	e8 cc 68 00 00       	call   809bb9 <etharp_query>
  dhcp->tries++;
  8032ed:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8032f1:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8032f7:	ba 08 00 00 00       	mov    $0x8,%edx
  8032fc:	89 d8                	mov    %ebx,%eax
  8032fe:	e8 0c f6 ff ff       	call   80290f <dhcp_set_state>
}
  803303:	83 c4 10             	add    $0x10,%esp
  803306:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803309:	c9                   	leave  
  80330a:	c3                   	ret    

0080330b <dhcp_bind>:
{
  80330b:	55                   	push   %ebp
  80330c:	89 e5                	mov    %esp,%ebp
  80330e:	56                   	push   %esi
  80330f:	53                   	push   %ebx
  803310:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803313:	85 c0                	test   %eax,%eax
  803315:	0f 84 d9 00 00 00    	je     8033f4 <dhcp_bind+0xe9>
  80331b:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  80331d:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803320:	85 db                	test   %ebx,%ebx
  803322:	0f 84 e3 00 00 00    	je     80340b <dhcp_bind+0x100>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803328:	8b 53 50             	mov    0x50(%ebx),%edx
  80332b:	83 fa ff             	cmp    $0xffffffff,%edx
  80332e:	74 2f                	je     80335f <dhcp_bind+0x54>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803330:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  803333:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803339:	0f 87 7e 01 00 00    	ja     8034bd <dhcp_bind+0x1b2>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80333f:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803344:	89 d0                	mov    %edx,%eax
  803346:	f7 e1                	mul    %ecx
  803348:	89 d0                	mov    %edx,%eax
  80334a:	c1 e8 05             	shr    $0x5,%eax
    if (dhcp->t1_timeout == 0) {
  80334d:	f7 c2 e0 ff 1f 00    	test   $0x1fffe0,%edx
  803353:	0f 85 c9 00 00 00    	jne    803422 <dhcp_bind+0x117>
      dhcp->t1_timeout = 1;
  803359:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80335f:	8b 53 54             	mov    0x54(%ebx),%edx
  803362:	83 fa ff             	cmp    $0xffffffff,%edx
  803365:	74 2f                	je     803396 <dhcp_bind+0x8b>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803367:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  80336a:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803370:	0f 87 3c 01 00 00    	ja     8034b2 <dhcp_bind+0x1a7>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803376:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80337b:	89 d0                	mov    %edx,%eax
  80337d:	f7 e1                	mul    %ecx
  80337f:	89 d0                	mov    %edx,%eax
  803381:	c1 e8 05             	shr    $0x5,%eax
    if (dhcp->t2_timeout == 0) {
  803384:	f7 c2 e0 ff 1f 00    	test   $0x1fffe0,%edx
  80338a:	0f 85 9b 00 00 00    	jne    80342b <dhcp_bind+0x120>
      dhcp->t2_timeout = 1;
  803390:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803396:	8b 43 34             	mov    0x34(%ebx),%eax
  803399:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  80339c:	85 c0                	test   %eax,%eax
  80339e:	0f 84 90 00 00 00    	je     803434 <dhcp_bind+0x129>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8033a4:	8b 43 38             	mov    0x38(%ebx),%eax
  8033a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  8033aa:	85 c0                	test   %eax,%eax
  8033ac:	0f 84 e2 00 00 00    	je     803494 <dhcp_bind+0x189>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8033b2:	83 ec 08             	sub    $0x8,%esp
  8033b5:	8d 43 30             	lea    0x30(%ebx),%eax
  8033b8:	50                   	push   %eax
  8033b9:	56                   	push   %esi
  8033ba:	e8 a2 13 00 00       	call   804761 <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  8033bf:	83 c4 08             	add    $0x8,%esp
  8033c2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8033c5:	50                   	push   %eax
  8033c6:	56                   	push   %esi
  8033c7:	e8 ea 14 00 00       	call   8048b6 <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  8033cc:	83 c4 08             	add    $0x8,%esp
  8033cf:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8033d2:	50                   	push   %eax
  8033d3:	56                   	push   %esi
  8033d4:	e8 c0 14 00 00       	call   804899 <netif_set_gw>
  netif_set_up(netif);
  8033d9:	89 34 24             	mov    %esi,(%esp)
  8033dc:	e8 03 15 00 00       	call   8048e4 <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  8033e1:	ba 0a 00 00 00       	mov    $0xa,%edx
  8033e6:	89 d8                	mov    %ebx,%eax
  8033e8:	e8 22 f5 ff ff       	call   80290f <dhcp_set_state>
}
  8033ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8033f0:	5b                   	pop    %ebx
  8033f1:	5e                   	pop    %esi
  8033f2:	5d                   	pop    %ebp
  8033f3:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8033f4:	83 ec 04             	sub    $0x4,%esp
  8033f7:	68 d7 19 81 00       	push   $0x8119d7
  8033fc:	68 3d 03 00 00       	push   $0x33d
  803401:	68 c2 19 81 00       	push   $0x8119c2
  803406:	e8 2c b5 00 00       	call   80e937 <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80340b:	83 ec 04             	sub    $0x4,%esp
  80340e:	68 f0 19 81 00       	push   $0x8119f0
  803413:	68 3f 03 00 00       	push   $0x33f
  803418:	68 c2 19 81 00       	push   $0x8119c2
  80341d:	e8 15 b5 00 00       	call   80e937 <_panic>
    dhcp->t1_timeout = (u16_t)timeout;
  803422:	66 89 43 28          	mov    %ax,0x28(%ebx)
  803426:	e9 34 ff ff ff       	jmp    80335f <dhcp_bind+0x54>
    dhcp->t2_timeout = (u16_t)timeout;
  80342b:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
  80342f:	e9 62 ff ff ff       	jmp    803396 <dhcp_bind+0x8b>
    u8_t first_octet = ip4_addr1(&sn_mask);
  803434:	83 ec 0c             	sub    $0xc,%esp
  803437:	6a 00                	push   $0x0
  803439:	e8 64 47 00 00       	call   807ba2 <ntohl>
  80343e:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803441:	83 c4 10             	add    $0x10,%esp
  803444:	84 c0                	test   %al,%al
  803446:	79 1c                	jns    803464 <dhcp_bind+0x159>
    } else if (first_octet >= 192) {
  803448:	3c bf                	cmp    $0xbf,%al
  80344a:	76 30                	jbe    80347c <dhcp_bind+0x171>
      sn_mask.addr = htonl(0xffffff00);
  80344c:	83 ec 0c             	sub    $0xc,%esp
  80344f:	68 00 ff ff ff       	push   $0xffffff00
  803454:	e8 1c 45 00 00       	call   807975 <htonl>
  803459:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80345c:	83 c4 10             	add    $0x10,%esp
  80345f:	e9 40 ff ff ff       	jmp    8033a4 <dhcp_bind+0x99>
      sn_mask.addr = htonl(0xff000000);
  803464:	83 ec 0c             	sub    $0xc,%esp
  803467:	68 00 00 00 ff       	push   $0xff000000
  80346c:	e8 04 45 00 00       	call   807975 <htonl>
  803471:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803474:	83 c4 10             	add    $0x10,%esp
  803477:	e9 28 ff ff ff       	jmp    8033a4 <dhcp_bind+0x99>
      sn_mask.addr = htonl(0xffff0000);
  80347c:	83 ec 0c             	sub    $0xc,%esp
  80347f:	68 00 00 ff ff       	push   $0xffff0000
  803484:	e8 ec 44 00 00       	call   807975 <htonl>
  803489:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80348c:	83 c4 10             	add    $0x10,%esp
  80348f:	e9 10 ff ff ff       	jmp    8033a4 <dhcp_bind+0x99>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  803494:	8b 43 30             	mov    0x30(%ebx),%eax
  803497:	23 45 f4             	and    -0xc(%ebp),%eax
  80349a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  80349d:	83 ec 0c             	sub    $0xc,%esp
  8034a0:	6a 01                	push   $0x1
  8034a2:	e8 ce 44 00 00       	call   807975 <htonl>
  8034a7:	09 45 f0             	or     %eax,-0x10(%ebp)
  8034aa:	83 c4 10             	add    $0x10,%esp
  8034ad:	e9 00 ff ff ff       	jmp    8033b2 <dhcp_bind+0xa7>
    dhcp->t2_timeout = (u16_t)timeout;
  8034b2:	66 c7 43 2a ff ff    	movw   $0xffff,0x2a(%ebx)
  8034b8:	e9 d9 fe ff ff       	jmp    803396 <dhcp_bind+0x8b>
    dhcp->t1_timeout = (u16_t)timeout;
  8034bd:	66 c7 43 28 ff ff    	movw   $0xffff,0x28(%ebx)
  8034c3:	e9 97 fe ff ff       	jmp    80335f <dhcp_bind+0x54>

008034c8 <dhcp_free_reply>:
{
  8034c8:	55                   	push   %ebp
  8034c9:	89 e5                	mov    %esp,%ebp
  8034cb:	53                   	push   %ebx
  8034cc:	83 ec 04             	sub    $0x4,%esp
  8034cf:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  8034d1:	8b 40 10             	mov    0x10(%eax),%eax
  8034d4:	85 c0                	test   %eax,%eax
  8034d6:	74 13                	je     8034eb <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  8034d8:	83 ec 0c             	sub    $0xc,%esp
  8034db:	50                   	push   %eax
  8034dc:	e8 05 0c 00 00       	call   8040e6 <mem_free>
    dhcp->msg_in = NULL;
  8034e1:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8034e8:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  8034eb:	8b 43 14             	mov    0x14(%ebx),%eax
  8034ee:	85 c0                	test   %eax,%eax
  8034f0:	74 19                	je     80350b <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  8034f2:	83 ec 0c             	sub    $0xc,%esp
  8034f5:	50                   	push   %eax
  8034f6:	e8 eb 0b 00 00       	call   8040e6 <mem_free>
    dhcp->options_in = NULL;
  8034fb:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803502:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  803508:	83 c4 10             	add    $0x10,%esp
}
  80350b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80350e:	c9                   	leave  
  80350f:	c3                   	ret    

00803510 <dhcp_recv>:
{
  803510:	f3 0f 1e fb          	endbr32 
  803514:	55                   	push   %ebp
  803515:	89 e5                	mov    %esp,%ebp
  803517:	57                   	push   %edi
  803518:	56                   	push   %esi
  803519:	53                   	push   %ebx
  80351a:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp = netif->dhcp;
  80351d:	8b 45 08             	mov    0x8(%ebp),%eax
  803520:	8b 78 20             	mov    0x20(%eax),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  803523:	8b 45 10             	mov    0x10(%ebp),%eax
  803526:	8b 70 04             	mov    0x4(%eax),%esi
  803529:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  dhcp->p = p;
  80352c:	89 47 0c             	mov    %eax,0xc(%edi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80352f:	80 3e 02             	cmpb   $0x2,(%esi)
  803532:	75 26                	jne    80355a <dhcp_recv+0x4a>
  803534:	8b 45 08             	mov    0x8(%ebp),%eax
  803537:	83 c0 25             	add    $0x25,%eax
  80353a:	8d 56 1c             	lea    0x1c(%esi),%edx
  80353d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  803540:	0f b6 71 24          	movzbl 0x24(%ecx),%esi
  803544:	01 c6                	add    %eax,%esi
  for (i = 0; i < netif->hwaddr_len; i++) {
  803546:	39 f0                	cmp    %esi,%eax
  803548:	74 2a                	je     803574 <dhcp_recv+0x64>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80354a:	0f b6 18             	movzbl (%eax),%ebx
  80354d:	0f b6 0a             	movzbl (%edx),%ecx
  803550:	83 c0 01             	add    $0x1,%eax
  803553:	83 c2 01             	add    $0x1,%edx
  803556:	38 cb                	cmp    %cl,%bl
  803558:	74 ec                	je     803546 <dhcp_recv+0x36>
  pbuf_free(p);
  80355a:	83 ec 0c             	sub    $0xc,%esp
  80355d:	ff 75 10             	pushl  0x10(%ebp)
  803560:	e8 b6 14 00 00       	call   804a1b <pbuf_free>
  dhcp->p = NULL;
  803565:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  80356c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80356f:	5b                   	pop    %ebx
  803570:	5e                   	pop    %esi
  803571:	5f                   	pop    %edi
  803572:	5d                   	pop    %ebp
  803573:	c3                   	ret    
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  803574:	83 ec 0c             	sub    $0xc,%esp
  803577:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80357a:	ff 70 04             	pushl  0x4(%eax)
  80357d:	e8 20 46 00 00       	call   807ba2 <ntohl>
  803582:	83 c4 10             	add    $0x10,%esp
  803585:	3b 47 04             	cmp    0x4(%edi),%eax
  803588:	75 d0                	jne    80355a <dhcp_recv+0x4a>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80358a:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  80358e:	0f 84 17 01 00 00    	je     8036ab <dhcp_recv+0x19b>
  dhcp_free_reply(dhcp);
  803594:	89 f8                	mov    %edi,%eax
  803596:	e8 2d ff ff ff       	call   8034c8 <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80359b:	8b 47 0c             	mov    0xc(%edi),%eax
  80359e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8035a2:	66 3d f0 00          	cmp    $0xf0,%ax
  8035a6:	76 1e                	jbe    8035c6 <dhcp_recv+0xb6>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035a8:	66 2d f0 00          	sub    $0xf0,%ax
  8035ac:	66 89 47 18          	mov    %ax,0x18(%edi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8035b0:	83 ec 0c             	sub    $0xc,%esp
  8035b3:	0f b7 c0             	movzwl %ax,%eax
  8035b6:	50                   	push   %eax
  8035b7:	e8 21 0e 00 00       	call   8043dd <mem_malloc>
  8035bc:	89 47 14             	mov    %eax,0x14(%edi)
    if (dhcp->options_in == NULL) {
  8035bf:	83 c4 10             	add    $0x10,%esp
  8035c2:	85 c0                	test   %eax,%eax
  8035c4:	74 94                	je     80355a <dhcp_recv+0x4a>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035c6:	83 ec 0c             	sub    $0xc,%esp
  8035c9:	68 f0 00 00 00       	push   $0xf0
  8035ce:	e8 0a 0e 00 00       	call   8043dd <mem_malloc>
  8035d3:	89 47 10             	mov    %eax,0x10(%edi)
  if (dhcp->msg_in == NULL) {
  8035d6:	83 c4 10             	add    $0x10,%esp
  8035d9:	85 c0                	test   %eax,%eax
  8035db:	0f 84 e1 00 00 00    	je     8036c2 <dhcp_recv+0x1b2>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8035e1:	6a 00                	push   $0x0
  8035e3:	68 f0 00 00 00       	push   $0xf0
  8035e8:	50                   	push   %eax
  8035e9:	ff 77 0c             	pushl  0xc(%edi)
  8035ec:	e8 b3 1b 00 00       	call   8051a4 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035f1:	83 c4 10             	add    $0x10,%esp
  8035f4:	66 3d f0 00          	cmp    $0xf0,%ax
  8035f8:	0f 85 de 00 00 00    	jne    8036dc <dhcp_recv+0x1cc>
  if (dhcp->options_in != NULL) {
  8035fe:	8b 47 14             	mov    0x14(%edi),%eax
  803601:	85 c0                	test   %eax,%eax
  803603:	74 20                	je     803625 <dhcp_recv+0x115>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803605:	68 f0 00 00 00       	push   $0xf0
  80360a:	0f b7 57 18          	movzwl 0x18(%edi),%edx
  80360e:	52                   	push   %edx
  80360f:	50                   	push   %eax
  803610:	ff 77 0c             	pushl  0xc(%edi)
  803613:	e8 8c 1b 00 00       	call   8051a4 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803618:	83 c4 10             	add    $0x10,%esp
  80361b:	66 3b 47 18          	cmp    0x18(%edi),%ax
  80361f:	0f 85 ce 00 00 00    	jne    8036f3 <dhcp_recv+0x1e3>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803625:	ba 35 00 00 00       	mov    $0x35,%edx
  80362a:	89 f8                	mov    %edi,%eax
  80362c:	e8 e9 f2 ff ff       	call   80291a <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  803631:	85 c0                	test   %eax,%eax
  803633:	0f 84 21 ff ff ff    	je     80355a <dhcp_recv+0x4a>
  return *ptr;
  803639:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  80363d:	3c 05                	cmp    $0x5,%al
  80363f:	0f 84 c5 00 00 00    	je     80370a <dhcp_recv+0x1fa>
  else if ((msg_type == DHCP_NAK) &&
  803645:	3c 06                	cmp    $0x6,%al
  803647:	0f 84 5a 02 00 00    	je     8038a7 <dhcp_recv+0x397>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80364d:	3c 02                	cmp    $0x2,%al
  80364f:	0f 85 05 ff ff ff    	jne    80355a <dhcp_recv+0x4a>
  803655:	80 3f 06             	cmpb   $0x6,(%edi)
  803658:	0f 85 fc fe ff ff    	jne    80355a <dhcp_recv+0x4a>
    dhcp->request_timeout = 0;
  80365e:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803664:	8b 45 08             	mov    0x8(%ebp),%eax
  803667:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  80366a:	ba 36 00 00 00       	mov    $0x36,%edx
  80366f:	89 d8                	mov    %ebx,%eax
  803671:	e8 a4 f2 ff ff       	call   80291a <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803676:	85 c0                	test   %eax,%eax
  803678:	0f 84 dc fe ff ff    	je     80355a <dhcp_recv+0x4a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80367e:	83 c0 02             	add    $0x2,%eax
  803681:	e8 a0 f3 ff ff       	call   802a26 <dhcp_get_option_long>
  803686:	83 ec 0c             	sub    $0xc,%esp
  803689:	50                   	push   %eax
  80368a:	e8 e6 42 00 00       	call   807975 <htonl>
  80368f:	89 43 2c             	mov    %eax,0x2c(%ebx)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803692:	8b 43 10             	mov    0x10(%ebx),%eax
  803695:	8b 40 10             	mov    0x10(%eax),%eax
  803698:	89 43 30             	mov    %eax,0x30(%ebx)
    dhcp_select(netif);
  80369b:	8b 45 08             	mov    0x8(%ebp),%eax
  80369e:	e8 b8 fa ff ff       	call   80315b <dhcp_select>
  8036a3:	83 c4 10             	add    $0x10,%esp
  8036a6:	e9 af fe ff ff       	jmp    80355a <dhcp_recv+0x4a>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8036ab:	83 ec 04             	sub    $0x4,%esp
  8036ae:	68 08 1a 81 00       	push   $0x811a08
  8036b3:	68 8a 04 00 00       	push   $0x48a
  8036b8:	68 c2 19 81 00       	push   $0x8119c2
  8036bd:	e8 75 b2 00 00       	call   80e937 <_panic>
    mem_free((void *)dhcp->options_in);
  8036c2:	83 ec 0c             	sub    $0xc,%esp
  8036c5:	ff 77 14             	pushl  0x14(%edi)
  8036c8:	e8 19 0a 00 00       	call   8040e6 <mem_free>
    dhcp->options_in = NULL;
  8036cd:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
    return ERR_MEM;
  8036d4:	83 c4 10             	add    $0x10,%esp
  8036d7:	e9 7e fe ff ff       	jmp    80355a <dhcp_recv+0x4a>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8036dc:	83 ec 04             	sub    $0x4,%esp
  8036df:	68 90 19 81 00       	push   $0x811990
  8036e4:	68 a0 04 00 00       	push   $0x4a0
  8036e9:	68 c2 19 81 00       	push   $0x8119c2
  8036ee:	e8 44 b2 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8036f3:	83 ec 04             	sub    $0x4,%esp
  8036f6:	68 18 1a 81 00       	push   $0x811a18
  8036fb:	68 a7 04 00 00       	push   $0x4a7
  803700:	68 c2 19 81 00       	push   $0x8119c2
  803705:	e8 2d b2 00 00       	call   80e937 <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  80370a:	0f b6 07             	movzbl (%edi),%eax
  80370d:	3c 01                	cmp    $0x1,%al
  80370f:	74 1e                	je     80372f <dhcp_recv+0x21f>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803711:	83 e8 03             	sub    $0x3,%eax
  803714:	3c 02                	cmp    $0x2,%al
  803716:	0f 87 3e fe ff ff    	ja     80355a <dhcp_recv+0x4a>
      dhcp->request_timeout = 0;
  80371c:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  803722:	8b 45 08             	mov    0x8(%ebp),%eax
  803725:	e8 e1 fb ff ff       	call   80330b <dhcp_bind>
  80372a:	e9 2b fe ff ff       	jmp    80355a <dhcp_recv+0x4a>
  struct dhcp *dhcp = netif->dhcp;
  80372f:	8b 45 08             	mov    0x8(%ebp),%eax
  803732:	8b 70 20             	mov    0x20(%eax),%esi
  dhcp->offered_sn_mask.addr = 0;
  803735:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  80373c:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  803743:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  80374a:	ba 33 00 00 00       	mov    $0x33,%edx
  80374f:	89 f0                	mov    %esi,%eax
  803751:	e8 c4 f1 ff ff       	call   80291a <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803756:	85 c0                	test   %eax,%eax
  803758:	74 0b                	je     803765 <dhcp_recv+0x255>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80375a:	83 c0 02             	add    $0x2,%eax
  80375d:	e8 c4 f2 ff ff       	call   802a26 <dhcp_get_option_long>
  803762:	89 46 4c             	mov    %eax,0x4c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803765:	ba 3a 00 00 00       	mov    $0x3a,%edx
  80376a:	89 f0                	mov    %esi,%eax
  80376c:	e8 a9 f1 ff ff       	call   80291a <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803771:	85 c0                	test   %eax,%eax
  803773:	0f 84 dc 00 00 00    	je     803855 <dhcp_recv+0x345>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  803779:	83 c0 02             	add    $0x2,%eax
  80377c:	e8 a5 f2 ff ff       	call   802a26 <dhcp_get_option_long>
  803781:	89 46 50             	mov    %eax,0x50(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803784:	ba 3b 00 00 00       	mov    $0x3b,%edx
  803789:	89 f0                	mov    %esi,%eax
  80378b:	e8 8a f1 ff ff       	call   80291a <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803790:	85 c0                	test   %eax,%eax
  803792:	0f 84 c7 00 00 00    	je     80385f <dhcp_recv+0x34f>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  803798:	83 c0 02             	add    $0x2,%eax
  80379b:	e8 86 f2 ff ff       	call   802a26 <dhcp_get_option_long>
  8037a0:	89 46 54             	mov    %eax,0x54(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8037a3:	8b 46 10             	mov    0x10(%esi),%eax
  8037a6:	8b 40 10             	mov    0x10(%eax),%eax
  8037a9:	89 46 30             	mov    %eax,0x30(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8037ac:	ba 01 00 00 00       	mov    $0x1,%edx
  8037b1:	89 f0                	mov    %esi,%eax
  8037b3:	e8 62 f1 ff ff       	call   80291a <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8037b8:	85 c0                	test   %eax,%eax
  8037ba:	74 17                	je     8037d3 <dhcp_recv+0x2c3>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8037bc:	83 c0 02             	add    $0x2,%eax
  8037bf:	e8 62 f2 ff ff       	call   802a26 <dhcp_get_option_long>
  8037c4:	83 ec 0c             	sub    $0xc,%esp
  8037c7:	50                   	push   %eax
  8037c8:	e8 a8 41 00 00       	call   807975 <htonl>
  8037cd:	89 46 34             	mov    %eax,0x34(%esi)
  8037d0:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8037d3:	ba 03 00 00 00       	mov    $0x3,%edx
  8037d8:	89 f0                	mov    %esi,%eax
  8037da:	e8 3b f1 ff ff       	call   80291a <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8037df:	85 c0                	test   %eax,%eax
  8037e1:	74 17                	je     8037fa <dhcp_recv+0x2ea>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8037e3:	83 c0 02             	add    $0x2,%eax
  8037e6:	e8 3b f2 ff ff       	call   802a26 <dhcp_get_option_long>
  8037eb:	83 ec 0c             	sub    $0xc,%esp
  8037ee:	50                   	push   %eax
  8037ef:	e8 81 41 00 00       	call   807975 <htonl>
  8037f4:	89 46 38             	mov    %eax,0x38(%esi)
  8037f7:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  8037fa:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8037ff:	89 f0                	mov    %esi,%eax
  803801:	e8 14 f1 ff ff       	call   80291a <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803806:	85 c0                	test   %eax,%eax
  803808:	74 17                	je     803821 <dhcp_recv+0x311>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80380a:	83 c0 02             	add    $0x2,%eax
  80380d:	e8 14 f2 ff ff       	call   802a26 <dhcp_get_option_long>
  803812:	83 ec 0c             	sub    $0xc,%esp
  803815:	50                   	push   %eax
  803816:	e8 5a 41 00 00       	call   807975 <htonl>
  80381b:	89 46 3c             	mov    %eax,0x3c(%esi)
  80381e:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803821:	ba 06 00 00 00       	mov    $0x6,%edx
  803826:	89 f0                	mov    %esi,%eax
  803828:	e8 ed f0 ff ff       	call   80291a <dhcp_get_option_ptr>
  80382d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (option_ptr != NULL) {
  803830:	85 c0                	test   %eax,%eax
  803832:	74 60                	je     803894 <dhcp_recv+0x384>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803834:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803838:	c0 e8 02             	shr    $0x2,%al
  80383b:	0f b6 d0             	movzbl %al,%edx
  80383e:	3c 02                	cmp    $0x2,%al
  803840:	b8 02 00 00 00       	mov    $0x2,%eax
  803845:	0f 46 c2             	cmovbe %edx,%eax
  803848:	89 46 40             	mov    %eax,0x40(%esi)
{
  80384b:	bb 00 00 00 00       	mov    $0x0,%ebx
  803850:	89 7d e0             	mov    %edi,-0x20(%ebp)
  803853:	eb 34                	jmp    803889 <dhcp_recv+0x379>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803855:	8b 46 4c             	mov    0x4c(%esi),%eax
  803858:	d1 e8                	shr    %eax
  80385a:	e9 22 ff ff ff       	jmp    803781 <dhcp_recv+0x271>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  80385f:	8b 46 4c             	mov    0x4c(%esi),%eax
  803862:	e9 39 ff ff ff       	jmp    8037a0 <dhcp_recv+0x290>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803867:	0f b6 fb             	movzbl %bl,%edi
  80386a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80386d:	8d 44 b8 02          	lea    0x2(%eax,%edi,4),%eax
  803871:	e8 b0 f1 ff ff       	call   802a26 <dhcp_get_option_long>
  803876:	83 ec 0c             	sub    $0xc,%esp
  803879:	50                   	push   %eax
  80387a:	e8 f6 40 00 00       	call   807975 <htonl>
  80387f:	89 44 be 44          	mov    %eax,0x44(%esi,%edi,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  803883:	83 c3 01             	add    $0x1,%ebx
  803886:	83 c4 10             	add    $0x10,%esp
  803889:	0f b6 c3             	movzbl %bl,%eax
  80388c:	3b 46 40             	cmp    0x40(%esi),%eax
  80388f:	72 d6                	jb     803867 <dhcp_recv+0x357>
  803891:	8b 7d e0             	mov    -0x20(%ebp),%edi
      dhcp->request_timeout = 0;
  803894:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_check(netif);
  80389a:	8b 45 08             	mov    0x8(%ebp),%eax
  80389d:	e8 35 fa ff ff       	call   8032d7 <dhcp_check>
  8038a2:	e9 b3 fc ff ff       	jmp    80355a <dhcp_recv+0x4a>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8038a7:	0f b6 07             	movzbl (%edi),%eax
  8038aa:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8038ad:	80 fa 02             	cmp    $0x2,%dl
  8038b0:	76 08                	jbe    8038ba <dhcp_recv+0x3aa>
  8038b2:	3c 01                	cmp    $0x1,%al
  8038b4:	0f 85 a0 fc ff ff    	jne    80355a <dhcp_recv+0x4a>
    dhcp->request_timeout = 0;
  8038ba:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  8038c0:	8b 45 08             	mov    0x8(%ebp),%eax
  8038c3:	8b 58 20             	mov    0x20(%eax),%ebx
  netif_set_down(netif);
  8038c6:	83 ec 0c             	sub    $0xc,%esp
  8038c9:	50                   	push   %eax
  8038ca:	e8 4c 10 00 00       	call   80491b <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8038cf:	83 c4 08             	add    $0x8,%esp
  8038d2:	68 68 22 81 00       	push   $0x812268
  8038d7:	ff 75 08             	pushl  0x8(%ebp)
  8038da:	e8 82 0e 00 00       	call   804761 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8038df:	83 c4 08             	add    $0x8,%esp
  8038e2:	68 68 22 81 00       	push   $0x812268
  8038e7:	ff 75 08             	pushl  0x8(%ebp)
  8038ea:	e8 aa 0f 00 00       	call   804899 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  8038ef:	83 c4 08             	add    $0x8,%esp
  8038f2:	68 68 22 81 00       	push   $0x812268
  8038f7:	ff 75 08             	pushl  0x8(%ebp)
  8038fa:	e8 b7 0f 00 00       	call   8048b6 <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8038ff:	ba 0c 00 00 00       	mov    $0xc,%edx
  803904:	89 d8                	mov    %ebx,%eax
  803906:	e8 04 f0 ff ff       	call   80290f <dhcp_set_state>
  dhcp_discover(netif);
  80390b:	8b 45 08             	mov    0x8(%ebp),%eax
  80390e:	e8 09 f7 ff ff       	call   80301c <dhcp_discover>
}
  803913:	83 c4 10             	add    $0x10,%esp
  803916:	e9 3f fc ff ff       	jmp    80355a <dhcp_recv+0x4a>

0080391b <dhcp_inform>:
{
  80391b:	f3 0f 1e fb          	endbr32 
  80391f:	55                   	push   %ebp
  803920:	89 e5                	mov    %esp,%ebp
  803922:	57                   	push   %edi
  803923:	56                   	push   %esi
  803924:	53                   	push   %ebx
  803925:	83 ec 18             	sub    $0x18,%esp
  803928:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  80392b:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  80392e:	6a 58                	push   $0x58
  803930:	e8 a8 0a 00 00       	call   8043dd <mem_malloc>
  if (dhcp == NULL) {
  803935:	83 c4 10             	add    $0x10,%esp
  803938:	85 c0                	test   %eax,%eax
  80393a:	74 55                	je     803991 <dhcp_inform+0x76>
  80393c:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  80393e:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803941:	83 ec 04             	sub    $0x4,%esp
  803944:	6a 58                	push   $0x58
  803946:	6a 00                	push   $0x0
  803948:	50                   	push   %eax
  803949:	e8 8c b8 00 00       	call   80f1da <memset>
  dhcp->pcb = udp_new();
  80394e:	e8 59 59 00 00       	call   8092ac <udp_new>
  803953:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803956:	83 c4 10             	add    $0x10,%esp
  803959:	85 c0                	test   %eax,%eax
  80395b:	74 3c                	je     803999 <dhcp_inform+0x7e>
  result = dhcp_create_request(netif);
  80395d:	89 f0                	mov    %esi,%eax
  80395f:	e8 38 f3 ff ff       	call   802c9c <dhcp_create_request>
  if (result == ERR_OK) {
  803964:	84 c0                	test   %al,%al
  803966:	74 3f                	je     8039a7 <dhcp_inform+0x8c>
    if (dhcp->pcb != NULL) {
  803968:	8b 43 08             	mov    0x8(%ebx),%eax
  80396b:	85 c0                	test   %eax,%eax
  80396d:	74 0c                	je     80397b <dhcp_inform+0x60>
      udp_remove(dhcp->pcb);
  80396f:	83 ec 0c             	sub    $0xc,%esp
  803972:	50                   	push   %eax
  803973:	e8 ec 58 00 00       	call   809264 <udp_remove>
  803978:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  80397b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803982:	83 ec 0c             	sub    $0xc,%esp
  803985:	53                   	push   %ebx
  803986:	e8 5b 07 00 00       	call   8040e6 <mem_free>
    netif->dhcp = old_dhcp;
  80398b:	89 7e 20             	mov    %edi,0x20(%esi)
  80398e:	83 c4 10             	add    $0x10,%esp
}
  803991:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803994:	5b                   	pop    %ebx
  803995:	5e                   	pop    %esi
  803996:	5f                   	pop    %edi
  803997:	5d                   	pop    %ebp
  803998:	c3                   	ret    
    mem_free((void *)dhcp);
  803999:	83 ec 0c             	sub    $0xc,%esp
  80399c:	53                   	push   %ebx
  80399d:	e8 44 07 00 00       	call   8040e6 <mem_free>
    return;
  8039a2:	83 c4 10             	add    $0x10,%esp
  8039a5:	eb ea                	jmp    803991 <dhcp_inform+0x76>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8039a7:	b9 01 00 00 00       	mov    $0x1,%ecx
  8039ac:	ba 35 00 00 00       	mov    $0x35,%edx
  8039b1:	89 d8                	mov    %ebx,%eax
  8039b3:	e8 d2 f0 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  8039b8:	ba 08 00 00 00       	mov    $0x8,%edx
  8039bd:	89 d8                	mov    %ebx,%eax
  8039bf:	e8 85 f0 ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8039c4:	b9 02 00 00 00       	mov    $0x2,%ecx
  8039c9:	ba 39 00 00 00       	mov    $0x39,%edx
  8039ce:	89 d8                	mov    %ebx,%eax
  8039d0:	e8 b5 f0 ff ff       	call   802a8a <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8039d5:	ba 40 02 00 00       	mov    $0x240,%edx
  8039da:	89 d8                	mov    %ebx,%eax
  8039dc:	e8 10 f1 ff ff       	call   802af1 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  8039e1:	89 d8                	mov    %ebx,%eax
  8039e3:	e8 67 f1 ff ff       	call   802b4f <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8039e8:	83 ec 08             	sub    $0x8,%esp
  8039eb:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8039ef:	66 05 f0 00          	add    $0xf0,%ax
  8039f3:	0f b7 c0             	movzwl %ax,%eax
  8039f6:	50                   	push   %eax
  8039f7:	ff 73 1c             	pushl  0x1c(%ebx)
  8039fa:	e8 45 13 00 00       	call   804d44 <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  8039ff:	83 c4 0c             	add    $0xc,%esp
  803a02:	6a 44                	push   $0x44
  803a04:	68 68 22 81 00       	push   $0x812268
  803a09:	ff 73 08             	pushl  0x8(%ebx)
  803a0c:	e8 e7 54 00 00       	call   808ef8 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803a11:	83 c4 0c             	add    $0xc,%esp
  803a14:	6a 43                	push   $0x43
  803a16:	68 64 22 81 00       	push   $0x812264
  803a1b:	ff 73 08             	pushl  0x8(%ebx)
  803a1e:	e8 95 57 00 00       	call   8091b8 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803a23:	89 34 24             	mov    %esi,(%esp)
  803a26:	6a 43                	push   $0x43
  803a28:	68 64 22 81 00       	push   $0x812264
  803a2d:	ff 73 1c             	pushl  0x1c(%ebx)
  803a30:	ff 73 08             	pushl  0x8(%ebx)
  803a33:	e8 7f 55 00 00       	call   808fb7 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803a38:	83 c4 1c             	add    $0x1c,%esp
  803a3b:	6a 43                	push   $0x43
  803a3d:	68 68 22 81 00       	push   $0x812268
  803a42:	ff 73 08             	pushl  0x8(%ebx)
  803a45:	e8 6e 57 00 00       	call   8091b8 <udp_connect>
    dhcp_delete_request(netif);
  803a4a:	89 f0                	mov    %esi,%eax
  803a4c:	e8 3e f4 ff ff       	call   802e8f <dhcp_delete_request>
  803a51:	83 c4 10             	add    $0x10,%esp
  803a54:	e9 0f ff ff ff       	jmp    803968 <dhcp_inform+0x4d>

00803a59 <dhcp_arp_reply>:
{
  803a59:	f3 0f 1e fb          	endbr32 
  803a5d:	55                   	push   %ebp
  803a5e:	89 e5                	mov    %esp,%ebp
  803a60:	56                   	push   %esi
  803a61:	53                   	push   %ebx
  803a62:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803a65:	85 f6                	test   %esi,%esi
  803a67:	74 13                	je     803a7c <dhcp_arp_reply+0x23>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803a69:	8b 5e 20             	mov    0x20(%esi),%ebx
  803a6c:	85 db                	test   %ebx,%ebx
  803a6e:	74 05                	je     803a75 <dhcp_arp_reply+0x1c>
  803a70:	80 3b 08             	cmpb   $0x8,(%ebx)
  803a73:	74 1e                	je     803a93 <dhcp_arp_reply+0x3a>
}
  803a75:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803a78:	5b                   	pop    %ebx
  803a79:	5e                   	pop    %esi
  803a7a:	5d                   	pop    %ebp
  803a7b:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803a7c:	83 ec 04             	sub    $0x4,%esp
  803a7f:	68 e2 19 81 00       	push   $0x8119e2
  803a84:	68 b5 02 00 00       	push   $0x2b5
  803a89:	68 c2 19 81 00       	push   $0x8119c2
  803a8e:	e8 a4 ae 00 00       	call   80e937 <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803a93:	8b 45 0c             	mov    0xc(%ebp),%eax
  803a96:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803a99:	39 08                	cmp    %ecx,(%eax)
  803a9b:	75 d8                	jne    803a75 <dhcp_arp_reply+0x1c>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803a9d:	ba 0c 00 00 00       	mov    $0xc,%edx
  803aa2:	89 d8                	mov    %ebx,%eax
  803aa4:	e8 66 ee ff ff       	call   80290f <dhcp_set_state>
  result = dhcp_create_request(netif);
  803aa9:	89 f0                	mov    %esi,%eax
  803aab:	e8 ec f1 ff ff       	call   802c9c <dhcp_create_request>
  if (result == ERR_OK) {
  803ab0:	84 c0                	test   %al,%al
  803ab2:	74 0c                	je     803ac0 <dhcp_arp_reply+0x67>
  dhcp->tries++;
  803ab4:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803ab8:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  return result;
  803abe:	eb b5                	jmp    803a75 <dhcp_arp_reply+0x1c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803ac0:	b9 01 00 00 00       	mov    $0x1,%ecx
  803ac5:	ba 35 00 00 00       	mov    $0x35,%edx
  803aca:	89 d8                	mov    %ebx,%eax
  803acc:	e8 b9 ef ff ff       	call   802a8a <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803ad1:	ba 04 00 00 00       	mov    $0x4,%edx
  803ad6:	89 d8                	mov    %ebx,%eax
  803ad8:	e8 6c ef ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803add:	b9 02 00 00 00       	mov    $0x2,%ecx
  803ae2:	ba 39 00 00 00       	mov    $0x39,%edx
  803ae7:	89 d8                	mov    %ebx,%eax
  803ae9:	e8 9c ef ff ff       	call   802a8a <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803aee:	ba 40 02 00 00       	mov    $0x240,%edx
  803af3:	89 d8                	mov    %ebx,%eax
  803af5:	e8 f7 ef ff ff       	call   802af1 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803afa:	b9 04 00 00 00       	mov    $0x4,%ecx
  803aff:	ba 32 00 00 00       	mov    $0x32,%edx
  803b04:	89 d8                	mov    %ebx,%eax
  803b06:	e8 7f ef ff ff       	call   802a8a <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803b0b:	83 ec 0c             	sub    $0xc,%esp
  803b0e:	ff 73 30             	pushl  0x30(%ebx)
  803b11:	e8 8c 40 00 00       	call   807ba2 <ntohl>
  803b16:	89 c2                	mov    %eax,%edx
  803b18:	89 d8                	mov    %ebx,%eax
  803b1a:	e8 e5 f0 ff ff       	call   802c04 <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  803b1f:	89 d8                	mov    %ebx,%eax
  803b21:	e8 29 f0 ff ff       	call   802b4f <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803b26:	83 c4 08             	add    $0x8,%esp
  803b29:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803b2d:	66 05 f0 00          	add    $0xf0,%ax
  803b31:	0f b7 c0             	movzwl %ax,%eax
  803b34:	50                   	push   %eax
  803b35:	ff 73 1c             	pushl  0x1c(%ebx)
  803b38:	e8 07 12 00 00       	call   804d44 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803b3d:	83 c4 0c             	add    $0xc,%esp
  803b40:	6a 43                	push   $0x43
  803b42:	68 68 22 81 00       	push   $0x812268
  803b47:	ff 73 08             	pushl  0x8(%ebx)
  803b4a:	e8 69 56 00 00       	call   8091b8 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803b4f:	89 34 24             	mov    %esi,(%esp)
  803b52:	6a 43                	push   $0x43
  803b54:	68 64 22 81 00       	push   $0x812264
  803b59:	ff 73 1c             	pushl  0x1c(%ebx)
  803b5c:	ff 73 08             	pushl  0x8(%ebx)
  803b5f:	e8 53 54 00 00       	call   808fb7 <udp_sendto_if>
    dhcp_delete_request(netif);
  803b64:	83 c4 20             	add    $0x20,%esp
  803b67:	89 f0                	mov    %esi,%eax
  803b69:	e8 21 f3 ff ff       	call   802e8f <dhcp_delete_request>
  803b6e:	e9 41 ff ff ff       	jmp    803ab4 <dhcp_arp_reply+0x5b>

00803b73 <dhcp_renew>:
{
  803b73:	f3 0f 1e fb          	endbr32 
  803b77:	55                   	push   %ebp
  803b78:	89 e5                	mov    %esp,%ebp
  803b7a:	57                   	push   %edi
  803b7b:	56                   	push   %esi
  803b7c:	53                   	push   %ebx
  803b7d:	83 ec 1c             	sub    $0x1c,%esp
  803b80:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803b83:	8b 5f 20             	mov    0x20(%edi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803b86:	ba 05 00 00 00       	mov    $0x5,%edx
  803b8b:	89 d8                	mov    %ebx,%eax
  803b8d:	e8 7d ed ff ff       	call   80290f <dhcp_set_state>
  result = dhcp_create_request(netif);
  803b92:	89 f8                	mov    %edi,%eax
  803b94:	e8 03 f1 ff ff       	call   802c9c <dhcp_create_request>
  803b99:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803b9b:	84 c0                	test   %al,%al
  803b9d:	74 3e                	je     803bdd <dhcp_renew+0x6a>
  dhcp->tries++;
  803b9f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803ba3:	83 c0 01             	add    $0x1,%eax
  803ba6:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803ba9:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803bae:	3c 09                	cmp    $0x9,%al
  803bb0:	77 08                	ja     803bba <dhcp_renew+0x47>
  803bb2:	0f b6 d0             	movzbl %al,%edx
  803bb5:	66 69 d2 d0 07       	imul   $0x7d0,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803bba:	0f b7 d2             	movzwl %dx,%edx
  803bbd:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803bc3:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803bc8:	89 d0                	mov    %edx,%eax
  803bca:	f7 e9                	imul   %ecx
  803bcc:	c1 fa 05             	sar    $0x5,%edx
  803bcf:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803bd3:	89 f0                	mov    %esi,%eax
  803bd5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803bd8:	5b                   	pop    %ebx
  803bd9:	5e                   	pop    %esi
  803bda:	5f                   	pop    %edi
  803bdb:	5d                   	pop    %ebp
  803bdc:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803bdd:	b9 01 00 00 00       	mov    $0x1,%ecx
  803be2:	ba 35 00 00 00       	mov    $0x35,%edx
  803be7:	89 d8                	mov    %ebx,%eax
  803be9:	e8 9c ee ff ff       	call   802a8a <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803bee:	ba 03 00 00 00       	mov    $0x3,%edx
  803bf3:	89 d8                	mov    %ebx,%eax
  803bf5:	e8 4f ee ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803bfa:	b9 02 00 00 00       	mov    $0x2,%ecx
  803bff:	ba 39 00 00 00       	mov    $0x39,%edx
  803c04:	89 d8                	mov    %ebx,%eax
  803c06:	e8 7f ee ff ff       	call   802a8a <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803c0b:	ba 40 02 00 00       	mov    $0x240,%edx
  803c10:	89 d8                	mov    %ebx,%eax
  803c12:	e8 da ee ff ff       	call   802af1 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803c17:	89 d8                	mov    %ebx,%eax
  803c19:	e8 31 ef ff ff       	call   802b4f <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c1e:	83 ec 08             	sub    $0x8,%esp
  803c21:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803c25:	66 05 f0 00          	add    $0xf0,%ax
  803c29:	0f b7 c0             	movzwl %ax,%eax
  803c2c:	50                   	push   %eax
  803c2d:	ff 73 1c             	pushl  0x1c(%ebx)
  803c30:	e8 0f 11 00 00       	call   804d44 <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c35:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c38:	83 c4 0c             	add    $0xc,%esp
  803c3b:	6a 43                	push   $0x43
  803c3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c40:	50                   	push   %eax
  803c41:	ff 73 08             	pushl  0x8(%ebx)
  803c44:	e8 6f 55 00 00       	call   8091b8 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803c49:	89 3c 24             	mov    %edi,(%esp)
  803c4c:	6a 43                	push   $0x43
  803c4e:	ff 75 e4             	pushl  -0x1c(%ebp)
  803c51:	ff 73 1c             	pushl  0x1c(%ebx)
  803c54:	ff 73 08             	pushl  0x8(%ebx)
  803c57:	e8 5b 53 00 00       	call   808fb7 <udp_sendto_if>
    dhcp_delete_request(netif);
  803c5c:	83 c4 20             	add    $0x20,%esp
  803c5f:	89 f8                	mov    %edi,%eax
  803c61:	e8 29 f2 ff ff       	call   802e8f <dhcp_delete_request>
  803c66:	e9 34 ff ff ff       	jmp    803b9f <dhcp_renew+0x2c>

00803c6b <dhcp_coarse_tmr>:
{
  803c6b:	f3 0f 1e fb          	endbr32 
  803c6f:	55                   	push   %ebp
  803c70:	89 e5                	mov    %esp,%ebp
  803c72:	53                   	push   %ebx
  803c73:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803c76:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803c7c:	eb 1d                	jmp    803c9b <dhcp_coarse_tmr+0x30>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803c7e:	8b 43 20             	mov    0x20(%ebx),%eax
  803c81:	0f b6 00             	movzbl (%eax),%eax
  803c84:	89 c2                	mov    %eax,%edx
  803c86:	83 e2 fb             	and    $0xfffffffb,%edx
  803c89:	80 fa 01             	cmp    $0x1,%dl
  803c8c:	74 04                	je     803c92 <dhcp_coarse_tmr+0x27>
  803c8e:	3c 0a                	cmp    $0xa,%al
  803c90:	75 07                	jne    803c99 <dhcp_coarse_tmr+0x2e>
    dhcp_rebind(netif);
  803c92:	89 d8                	mov    %ebx,%eax
  803c94:	e8 90 f2 ff ff       	call   802f29 <dhcp_rebind>
    netif = netif->next;
  803c99:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803c9b:	85 db                	test   %ebx,%ebx
  803c9d:	74 4e                	je     803ced <dhcp_coarse_tmr+0x82>
    if (netif->dhcp != NULL) {
  803c9f:	8b 43 20             	mov    0x20(%ebx),%eax
  803ca2:	85 c0                	test   %eax,%eax
  803ca4:	74 f3                	je     803c99 <dhcp_coarse_tmr+0x2e>
      if (netif->dhcp->t2_timeout-- == 1) {
  803ca6:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803caa:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803cad:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803cb1:	66 83 fa 01          	cmp    $0x1,%dx
  803cb5:	74 c7                	je     803c7e <dhcp_coarse_tmr+0x13>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803cb7:	8b 53 20             	mov    0x20(%ebx),%edx
  803cba:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803cbe:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803cc1:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803cc5:	66 83 f8 01          	cmp    $0x1,%ax
  803cc9:	75 ce                	jne    803c99 <dhcp_coarse_tmr+0x2e>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803ccb:	8b 43 20             	mov    0x20(%ebx),%eax
  803cce:	0f b6 00             	movzbl (%eax),%eax
  803cd1:	89 c2                	mov    %eax,%edx
  803cd3:	83 e2 fb             	and    $0xfffffffb,%edx
  803cd6:	80 fa 01             	cmp    $0x1,%dl
  803cd9:	74 04                	je     803cdf <dhcp_coarse_tmr+0x74>
  803cdb:	3c 0a                	cmp    $0xa,%al
  803cdd:	75 ba                	jne    803c99 <dhcp_coarse_tmr+0x2e>
    dhcp_renew(netif);
  803cdf:	83 ec 0c             	sub    $0xc,%esp
  803ce2:	53                   	push   %ebx
  803ce3:	e8 8b fe ff ff       	call   803b73 <dhcp_renew>
  803ce8:	83 c4 10             	add    $0x10,%esp
  803ceb:	eb ac                	jmp    803c99 <dhcp_coarse_tmr+0x2e>
}
  803ced:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803cf0:	c9                   	leave  
  803cf1:	c3                   	ret    

00803cf2 <dhcp_release>:
{
  803cf2:	f3 0f 1e fb          	endbr32 
  803cf6:	55                   	push   %ebp
  803cf7:	89 e5                	mov    %esp,%ebp
  803cf9:	57                   	push   %edi
  803cfa:	56                   	push   %esi
  803cfb:	53                   	push   %ebx
  803cfc:	83 ec 1c             	sub    $0x1c,%esp
  803cff:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803d02:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803d05:	ba 0d 00 00 00       	mov    $0xd,%edx
  803d0a:	89 d8                	mov    %ebx,%eax
  803d0c:	e8 fe eb ff ff       	call   80290f <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803d11:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803d18:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803d1f:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803d26:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803d2d:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803d34:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803d3b:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803d42:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803d49:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803d50:	89 f0                	mov    %esi,%eax
  803d52:	e8 45 ef ff ff       	call   802c9c <dhcp_create_request>
  803d57:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803d59:	84 c0                	test   %al,%al
  803d5b:	74 71                	je     803dce <dhcp_release+0xdc>
  dhcp->tries++;
  803d5d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803d61:	83 c0 01             	add    $0x1,%eax
  803d64:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803d67:	ba 10 27 00 00       	mov    $0x2710,%edx
  803d6c:	3c 09                	cmp    $0x9,%al
  803d6e:	77 08                	ja     803d78 <dhcp_release+0x86>
  803d70:	0f b6 d0             	movzbl %al,%edx
  803d73:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803d78:	0f b7 d2             	movzwl %dx,%edx
  803d7b:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803d81:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803d86:	89 d0                	mov    %edx,%eax
  803d88:	f7 e9                	imul   %ecx
  803d8a:	c1 fa 05             	sar    $0x5,%edx
  803d8d:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803d91:	83 ec 0c             	sub    $0xc,%esp
  803d94:	56                   	push   %esi
  803d95:	e8 81 0b 00 00       	call   80491b <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803d9a:	83 c4 08             	add    $0x8,%esp
  803d9d:	68 68 22 81 00       	push   $0x812268
  803da2:	56                   	push   %esi
  803da3:	e8 b9 09 00 00       	call   804761 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803da8:	83 c4 08             	add    $0x8,%esp
  803dab:	68 68 22 81 00       	push   $0x812268
  803db0:	56                   	push   %esi
  803db1:	e8 e3 0a 00 00       	call   804899 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803db6:	83 c4 08             	add    $0x8,%esp
  803db9:	68 68 22 81 00       	push   $0x812268
  803dbe:	56                   	push   %esi
  803dbf:	e8 f2 0a 00 00       	call   8048b6 <netif_set_netmask>
}
  803dc4:	89 f8                	mov    %edi,%eax
  803dc6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803dc9:	5b                   	pop    %ebx
  803dca:	5e                   	pop    %esi
  803dcb:	5f                   	pop    %edi
  803dcc:	5d                   	pop    %ebp
  803dcd:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803dce:	b9 01 00 00 00       	mov    $0x1,%ecx
  803dd3:	ba 35 00 00 00       	mov    $0x35,%edx
  803dd8:	89 d8                	mov    %ebx,%eax
  803dda:	e8 ab ec ff ff       	call   802a8a <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803ddf:	ba 07 00 00 00       	mov    $0x7,%edx
  803de4:	89 d8                	mov    %ebx,%eax
  803de6:	e8 5e ec ff ff       	call   802a49 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803deb:	89 d8                	mov    %ebx,%eax
  803ded:	e8 5d ed ff ff       	call   802b4f <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803df2:	83 ec 08             	sub    $0x8,%esp
  803df5:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803df9:	66 05 f0 00          	add    $0xf0,%ax
  803dfd:	0f b7 c0             	movzwl %ax,%eax
  803e00:	50                   	push   %eax
  803e01:	ff 73 1c             	pushl  0x1c(%ebx)
  803e04:	e8 3b 0f 00 00       	call   804d44 <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803e09:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803e0c:	83 c4 0c             	add    $0xc,%esp
  803e0f:	6a 43                	push   $0x43
  803e11:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803e14:	50                   	push   %eax
  803e15:	ff 73 08             	pushl  0x8(%ebx)
  803e18:	e8 9b 53 00 00       	call   8091b8 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803e1d:	89 34 24             	mov    %esi,(%esp)
  803e20:	6a 43                	push   $0x43
  803e22:	ff 75 e4             	pushl  -0x1c(%ebp)
  803e25:	ff 73 1c             	pushl  0x1c(%ebx)
  803e28:	ff 73 08             	pushl  0x8(%ebx)
  803e2b:	e8 87 51 00 00       	call   808fb7 <udp_sendto_if>
    dhcp_delete_request(netif);
  803e30:	83 c4 20             	add    $0x20,%esp
  803e33:	89 f0                	mov    %esi,%eax
  803e35:	e8 55 f0 ff ff       	call   802e8f <dhcp_delete_request>
  803e3a:	e9 1e ff ff ff       	jmp    803d5d <dhcp_release+0x6b>

00803e3f <dhcp_fine_tmr>:
{
  803e3f:	f3 0f 1e fb          	endbr32 
  803e43:	55                   	push   %ebp
  803e44:	89 e5                	mov    %esp,%ebp
  803e46:	53                   	push   %ebx
  803e47:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803e4a:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803e50:	eb 04                	jmp    803e56 <dhcp_fine_tmr+0x17>
      else if (netif->dhcp->request_timeout == 1) {
  803e52:	74 24                	je     803e78 <dhcp_fine_tmr+0x39>
    netif = netif->next;
  803e54:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803e56:	85 db                	test   %ebx,%ebx
  803e58:	0f 84 c4 00 00 00    	je     803f22 <dhcp_fine_tmr+0xe3>
    if (netif->dhcp != NULL) {
  803e5e:	8b 43 20             	mov    0x20(%ebx),%eax
  803e61:	85 c0                	test   %eax,%eax
  803e63:	74 ef                	je     803e54 <dhcp_fine_tmr+0x15>
      if (netif->dhcp->request_timeout > 1) {
  803e65:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803e69:	66 83 fa 01          	cmp    $0x1,%dx
  803e6d:	76 e3                	jbe    803e52 <dhcp_fine_tmr+0x13>
        netif->dhcp->request_timeout--;
  803e6f:	83 ea 01             	sub    $0x1,%edx
  803e72:	66 89 50 26          	mov    %dx,0x26(%eax)
  803e76:	eb dc                	jmp    803e54 <dhcp_fine_tmr+0x15>
        netif->dhcp->request_timeout--;
  803e78:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803e7e:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803e81:	0f b6 02             	movzbl (%edx),%eax
  803e84:	3c 0c                	cmp    $0xc,%al
  803e86:	74 23                	je     803eab <dhcp_fine_tmr+0x6c>
  803e88:	3c 06                	cmp    $0x6,%al
  803e8a:	74 1f                	je     803eab <dhcp_fine_tmr+0x6c>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803e8c:	3c 01                	cmp    $0x1,%al
  803e8e:	74 24                	je     803eb4 <dhcp_fine_tmr+0x75>
  } else if (dhcp->state == DHCP_CHECKING) {
  803e90:	3c 08                	cmp    $0x8,%al
  803e92:	74 47                	je     803edb <dhcp_fine_tmr+0x9c>
  else if (dhcp->state == DHCP_RENEWING) {
  803e94:	3c 05                	cmp    $0x5,%al
  803e96:	74 61                	je     803ef9 <dhcp_fine_tmr+0xba>
  } else if (dhcp->state == DHCP_REBINDING) {
  803e98:	3c 04                	cmp    $0x4,%al
  803e9a:	75 b8                	jne    803e54 <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 8) {
  803e9c:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803ea0:	77 68                	ja     803f0a <dhcp_fine_tmr+0xcb>
      dhcp_rebind(netif);
  803ea2:	89 d8                	mov    %ebx,%eax
  803ea4:	e8 80 f0 ff ff       	call   802f29 <dhcp_rebind>
  803ea9:	eb a9                	jmp    803e54 <dhcp_fine_tmr+0x15>
    dhcp_discover(netif);
  803eab:	89 d8                	mov    %ebx,%eax
  803ead:	e8 6a f1 ff ff       	call   80301c <dhcp_discover>
  803eb2:	eb a0                	jmp    803e54 <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 5) {
  803eb4:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803eb8:	77 09                	ja     803ec3 <dhcp_fine_tmr+0x84>
      dhcp_select(netif);
  803eba:	89 d8                	mov    %ebx,%eax
  803ebc:	e8 9a f2 ff ff       	call   80315b <dhcp_select>
  803ec1:	eb 91                	jmp    803e54 <dhcp_fine_tmr+0x15>
      dhcp_release(netif);
  803ec3:	83 ec 0c             	sub    $0xc,%esp
  803ec6:	53                   	push   %ebx
  803ec7:	e8 26 fe ff ff       	call   803cf2 <dhcp_release>
      dhcp_discover(netif);
  803ecc:	89 d8                	mov    %ebx,%eax
  803ece:	e8 49 f1 ff ff       	call   80301c <dhcp_discover>
  803ed3:	83 c4 10             	add    $0x10,%esp
  803ed6:	e9 79 ff ff ff       	jmp    803e54 <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 1) {
  803edb:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803edf:	76 0c                	jbe    803eed <dhcp_fine_tmr+0xae>
      dhcp_bind(netif);
  803ee1:	89 d8                	mov    %ebx,%eax
  803ee3:	e8 23 f4 ff ff       	call   80330b <dhcp_bind>
  803ee8:	e9 67 ff ff ff       	jmp    803e54 <dhcp_fine_tmr+0x15>
      dhcp_check(netif);
  803eed:	89 d8                	mov    %ebx,%eax
  803eef:	e8 e3 f3 ff ff       	call   8032d7 <dhcp_check>
  803ef4:	e9 5b ff ff ff       	jmp    803e54 <dhcp_fine_tmr+0x15>
    dhcp_renew(netif);
  803ef9:	83 ec 0c             	sub    $0xc,%esp
  803efc:	53                   	push   %ebx
  803efd:	e8 71 fc ff ff       	call   803b73 <dhcp_renew>
  803f02:	83 c4 10             	add    $0x10,%esp
  803f05:	e9 4a ff ff ff       	jmp    803e54 <dhcp_fine_tmr+0x15>
      dhcp_release(netif);
  803f0a:	83 ec 0c             	sub    $0xc,%esp
  803f0d:	53                   	push   %ebx
  803f0e:	e8 df fd ff ff       	call   803cf2 <dhcp_release>
      dhcp_discover(netif);
  803f13:	89 d8                	mov    %ebx,%eax
  803f15:	e8 02 f1 ff ff       	call   80301c <dhcp_discover>
  803f1a:	83 c4 10             	add    $0x10,%esp
  803f1d:	e9 32 ff ff ff       	jmp    803e54 <dhcp_fine_tmr+0x15>
}
  803f22:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803f25:	c9                   	leave  
  803f26:	c3                   	ret    

00803f27 <dhcp_stop>:
{
  803f27:	f3 0f 1e fb          	endbr32 
  803f2b:	55                   	push   %ebp
  803f2c:	89 e5                	mov    %esp,%ebp
  803f2e:	56                   	push   %esi
  803f2f:	53                   	push   %ebx
  803f30:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803f33:	8b 5e 20             	mov    0x20(%esi),%ebx
  netif->flags &= ~NETIF_FLAG_DHCP;
  803f36:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)
  if (dhcp != NULL) {
  803f3a:	85 db                	test   %ebx,%ebx
  803f3c:	74 4e                	je     803f8c <dhcp_stop+0x65>
    if (dhcp->pcb != NULL) {
  803f3e:	8b 43 08             	mov    0x8(%ebx),%eax
  803f41:	85 c0                	test   %eax,%eax
  803f43:	74 13                	je     803f58 <dhcp_stop+0x31>
      udp_remove(dhcp->pcb);
  803f45:	83 ec 0c             	sub    $0xc,%esp
  803f48:	50                   	push   %eax
  803f49:	e8 16 53 00 00       	call   809264 <udp_remove>
      dhcp->pcb = NULL;
  803f4e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803f55:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803f58:	8b 43 0c             	mov    0xc(%ebx),%eax
  803f5b:	85 c0                	test   %eax,%eax
  803f5d:	74 13                	je     803f72 <dhcp_stop+0x4b>
      pbuf_free(dhcp->p);
  803f5f:	83 ec 0c             	sub    $0xc,%esp
  803f62:	50                   	push   %eax
  803f63:	e8 b3 0a 00 00       	call   804a1b <pbuf_free>
      dhcp->p = NULL;
  803f68:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803f6f:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803f72:	89 d8                	mov    %ebx,%eax
  803f74:	e8 4f f5 ff ff       	call   8034c8 <dhcp_free_reply>
    mem_free((void *)dhcp);
  803f79:	83 ec 0c             	sub    $0xc,%esp
  803f7c:	53                   	push   %ebx
  803f7d:	e8 64 01 00 00       	call   8040e6 <mem_free>
    netif->dhcp = NULL;
  803f82:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803f89:	83 c4 10             	add    $0x10,%esp
}
  803f8c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803f8f:	5b                   	pop    %ebx
  803f90:	5e                   	pop    %esi
  803f91:	5d                   	pop    %ebp
  803f92:	c3                   	ret    

00803f93 <dhcp_start>:
{
  803f93:	f3 0f 1e fb          	endbr32 
  803f97:	55                   	push   %ebp
  803f98:	89 e5                	mov    %esp,%ebp
  803f9a:	56                   	push   %esi
  803f9b:	53                   	push   %ebx
  803f9c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803f9f:	85 db                	test   %ebx,%ebx
  803fa1:	74 73                	je     804016 <dhcp_start+0x83>
  dhcp = netif->dhcp;
  803fa3:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803fa6:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803faa:	85 f6                	test   %esi,%esi
  803fac:	74 7f                	je     80402d <dhcp_start+0x9a>
  memset(dhcp, 0, sizeof(struct dhcp));
  803fae:	83 ec 04             	sub    $0x4,%esp
  803fb1:	6a 58                	push   $0x58
  803fb3:	6a 00                	push   $0x0
  803fb5:	56                   	push   %esi
  803fb6:	e8 1f b2 00 00       	call   80f1da <memset>
  dhcp->pcb = udp_new();
  803fbb:	e8 ec 52 00 00       	call   8092ac <udp_new>
  803fc0:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803fc3:	83 c4 10             	add    $0x10,%esp
  803fc6:	85 c0                	test   %eax,%eax
  803fc8:	74 7e                	je     804048 <dhcp_start+0xb5>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803fca:	83 ec 04             	sub    $0x4,%esp
  803fcd:	6a 44                	push   $0x44
  803fcf:	68 68 22 81 00       	push   $0x812268
  803fd4:	50                   	push   %eax
  803fd5:	e8 1e 4f 00 00       	call   808ef8 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803fda:	83 c4 0c             	add    $0xc,%esp
  803fdd:	6a 43                	push   $0x43
  803fdf:	68 68 22 81 00       	push   $0x812268
  803fe4:	ff 76 08             	pushl  0x8(%esi)
  803fe7:	e8 cc 51 00 00       	call   8091b8 <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803fec:	83 c4 0c             	add    $0xc,%esp
  803fef:	53                   	push   %ebx
  803ff0:	68 10 35 80 00       	push   $0x803510
  803ff5:	ff 76 08             	pushl  0x8(%esi)
  803ff8:	e8 4f 52 00 00       	call   80924c <udp_recv>
  result = dhcp_discover(netif);
  803ffd:	89 d8                	mov    %ebx,%eax
  803fff:	e8 18 f0 ff ff       	call   80301c <dhcp_discover>
  if (result != ERR_OK) {
  804004:	83 c4 10             	add    $0x10,%esp
  804007:	84 c0                	test   %al,%al
  804009:	75 57                	jne    804062 <dhcp_start+0xcf>
  netif->flags |= NETIF_FLAG_DHCP;
  80400b:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  80400f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804012:	5b                   	pop    %ebx
  804013:	5e                   	pop    %esi
  804014:	5d                   	pop    %ebp
  804015:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  804016:	83 ec 04             	sub    $0x4,%esp
  804019:	68 e2 19 81 00       	push   $0x8119e2
  80401e:	68 38 02 00 00       	push   $0x238
  804023:	68 c2 19 81 00       	push   $0x8119c2
  804028:	e8 0a a9 00 00       	call   80e937 <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  80402d:	83 ec 0c             	sub    $0xc,%esp
  804030:	6a 58                	push   $0x58
  804032:	e8 a6 03 00 00       	call   8043dd <mem_malloc>
  804037:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  804039:	83 c4 10             	add    $0x10,%esp
  80403c:	85 c0                	test   %eax,%eax
  80403e:	74 35                	je     804075 <dhcp_start+0xe2>
    netif->dhcp = dhcp;
  804040:	89 43 20             	mov    %eax,0x20(%ebx)
  804043:	e9 66 ff ff ff       	jmp    803fae <dhcp_start+0x1b>
    mem_free((void *)dhcp);
  804048:	83 ec 0c             	sub    $0xc,%esp
  80404b:	56                   	push   %esi
  80404c:	e8 95 00 00 00       	call   8040e6 <mem_free>
    netif->dhcp = dhcp = NULL;
  804051:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  804058:	83 c4 10             	add    $0x10,%esp
  80405b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804060:	eb ad                	jmp    80400f <dhcp_start+0x7c>
    dhcp_stop(netif);
  804062:	83 ec 0c             	sub    $0xc,%esp
  804065:	53                   	push   %ebx
  804066:	e8 bc fe ff ff       	call   803f27 <dhcp_stop>
    return ERR_MEM;
  80406b:	83 c4 10             	add    $0x10,%esp
  80406e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804073:	eb 9a                	jmp    80400f <dhcp_start+0x7c>
      return ERR_MEM;
  804075:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80407a:	eb 93                	jmp    80400f <dhcp_start+0x7c>

0080407c <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80407c:	f3 0f 1e fb          	endbr32 
  804080:	55                   	push   %ebp
  804081:	89 e5                	mov    %esp,%ebp
  804083:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  804086:	b8 23 53 81 00       	mov    $0x815323,%eax
  80408b:	83 e0 fc             	and    $0xfffffffc,%eax
  80408e:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  804093:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  804099:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  8040a0:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  8040a4:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  8040aa:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  8040b0:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  8040b7:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  8040be:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  8040c1:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  8040c8:	00 22 00 

  mem_sem = sys_sem_new(1);
  8040cb:	6a 01                	push   $0x1
  8040cd:	e8 ce 5f 00 00       	call   80a0a0 <sys_sem_new>
  8040d2:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  8040d7:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8040dc:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  8040e1:	83 c4 10             	add    $0x10,%esp
  8040e4:	c9                   	leave  
  8040e5:	c3                   	ret    

008040e6 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  8040e6:	f3 0f 1e fb          	endbr32 
  8040ea:	55                   	push   %ebp
  8040eb:	89 e5                	mov    %esp,%ebp
  8040ed:	56                   	push   %esi
  8040ee:	53                   	push   %ebx
  8040ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  8040f2:	85 db                	test   %ebx,%ebx
  8040f4:	0f 84 e1 00 00 00    	je     8041db <mem_free+0xf5>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  8040fa:	f6 c3 03             	test   $0x3,%bl
  8040fd:	0f 85 df 00 00 00    	jne    8041e2 <mem_free+0xfc>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804103:	39 1d 0c 53 81 00    	cmp    %ebx,0x81530c
  804109:	0f 87 ea 00 00 00    	ja     8041f9 <mem_free+0x113>
  80410f:	39 1d 08 53 81 00    	cmp    %ebx,0x815308
  804115:	0f 86 de 00 00 00    	jbe    8041f9 <mem_free+0x113>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80411b:	83 ec 08             	sub    $0x8,%esp
  80411e:	6a 00                	push   $0x0
  804120:	ff 35 00 53 81 00    	pushl  0x815300
  804126:	e8 b6 62 00 00       	call   80a3e1 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80412b:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80412e:	83 c4 10             	add    $0x10,%esp
  804131:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  804135:	0f 84 d5 00 00 00    	je     804210 <mem_free+0x12a>
  /* ... and is now unused. */
  mem->used = 0;
  80413b:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  80413f:	39 05 04 53 81 00    	cmp    %eax,0x815304
  804145:	76 05                	jbe    80414c <mem_free+0x66>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  804147:	a3 04 53 81 00       	mov    %eax,0x815304
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80414c:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  804152:	39 c8                	cmp    %ecx,%eax
  804154:	0f 82 cd 00 00 00    	jb     804227 <mem_free+0x141>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80415a:	8b 35 08 53 81 00    	mov    0x815308,%esi
  804160:	39 f0                	cmp    %esi,%eax
  804162:	0f 83 d6 00 00 00    	jae    80423e <mem_free+0x158>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804168:	8b 53 f4             	mov    -0xc(%ebx),%edx
  80416b:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804171:	0f 87 de 00 00 00    	ja     804255 <mem_free+0x16f>
  nmem = (struct mem *)&ram[mem->next];
  804177:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  804179:	39 d0                	cmp    %edx,%eax
  80417b:	74 25                	je     8041a2 <mem_free+0xbc>
  80417d:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804181:	75 1f                	jne    8041a2 <mem_free+0xbc>
  804183:	39 d6                	cmp    %edx,%esi
  804185:	74 1b                	je     8041a2 <mem_free+0xbc>
    if (lfree == nmem) {
  804187:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  80418d:	0f 84 d9 00 00 00    	je     80426c <mem_free+0x186>
    mem->next = nmem->next;
  804193:	8b 32                	mov    (%edx),%esi
  804195:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  804198:	8b 12                	mov    (%edx),%edx
  80419a:	89 c6                	mov    %eax,%esi
  80419c:	29 ce                	sub    %ecx,%esi
  80419e:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  8041a2:	8b 73 f8             	mov    -0x8(%ebx),%esi
  8041a5:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  8041a8:	39 d0                	cmp    %edx,%eax
  8041aa:	74 1e                	je     8041ca <mem_free+0xe4>
  8041ac:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8041b0:	75 18                	jne    8041ca <mem_free+0xe4>
    if (lfree == mem) {
  8041b2:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  8041b8:	0f 84 b8 00 00 00    	je     804276 <mem_free+0x190>
    pmem->next = mem->next;
  8041be:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8041c1:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8041c3:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8041c6:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8041ca:	83 ec 0c             	sub    $0xc,%esp
  8041cd:	ff 35 00 53 81 00    	pushl  0x815300
  8041d3:	e8 95 61 00 00       	call   80a36d <sys_sem_signal>
  8041d8:	83 c4 10             	add    $0x10,%esp
}
  8041db:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8041de:	5b                   	pop    %ebx
  8041df:	5e                   	pop    %esi
  8041e0:	5d                   	pop    %ebp
  8041e1:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  8041e2:	83 ec 04             	sub    $0x4,%esp
  8041e5:	68 34 1a 81 00       	push   $0x811a34
  8041ea:	68 30 01 00 00       	push   $0x130
  8041ef:	68 2b 1b 81 00       	push   $0x811b2b
  8041f4:	e8 3e a7 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8041f9:	83 ec 04             	sub    $0x4,%esp
  8041fc:	68 3f 1b 81 00       	push   $0x811b3f
  804201:	68 32 01 00 00       	push   $0x132
  804206:	68 2b 1b 81 00       	push   $0x811b2b
  80420b:	e8 27 a7 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804210:	83 ec 04             	sub    $0x4,%esp
  804213:	68 56 1b 81 00       	push   $0x811b56
  804218:	68 43 01 00 00       	push   $0x143
  80421d:	68 2b 1b 81 00       	push   $0x811b2b
  804222:	e8 10 a7 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804227:	83 ec 04             	sub    $0x4,%esp
  80422a:	68 6a 1b 81 00       	push   $0x811b6a
  80422f:	68 e3 00 00 00       	push   $0xe3
  804234:	68 2b 1b 81 00       	push   $0x811b2b
  804239:	e8 f9 a6 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80423e:	83 ec 04             	sub    $0x4,%esp
  804241:	68 81 1b 81 00       	push   $0x811b81
  804246:	68 e4 00 00 00       	push   $0xe4
  80424b:	68 2b 1b 81 00       	push   $0x811b2b
  804250:	e8 e2 a6 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804255:	83 ec 04             	sub    $0x4,%esp
  804258:	68 58 1a 81 00       	push   $0x811a58
  80425d:	68 e8 00 00 00       	push   $0xe8
  804262:	68 2b 1b 81 00       	push   $0x811b2b
  804267:	e8 cb a6 00 00       	call   80e937 <_panic>
      lfree = mem;
  80426c:	a3 04 53 81 00       	mov    %eax,0x815304
  804271:	e9 1d ff ff ff       	jmp    804193 <mem_free+0xad>
      lfree = pmem;
  804276:	89 15 04 53 81 00    	mov    %edx,0x815304
  80427c:	e9 3d ff ff ff       	jmp    8041be <mem_free+0xd8>

00804281 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  804281:	f3 0f 1e fb          	endbr32 
  804285:	55                   	push   %ebp
  804286:	89 e5                	mov    %esp,%ebp
  804288:	57                   	push   %edi
  804289:	56                   	push   %esi
  80428a:	53                   	push   %ebx
  80428b:	83 ec 1c             	sub    $0x1c,%esp
  80428e:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  804291:	8b 45 0c             	mov    0xc(%ebp),%eax
  804294:	8d 58 03             	lea    0x3(%eax),%ebx
  804297:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  80429a:	83 fb 0b             	cmp    $0xb,%ebx
  80429d:	76 12                	jbe    8042b1 <mem_realloc+0x30>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80429f:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  8042a5:	76 0f                	jbe    8042b6 <mem_realloc+0x35>
    return NULL;
  8042a7:	be 00 00 00 00       	mov    $0x0,%esi
  8042ac:	e9 a1 00 00 00       	jmp    804352 <mem_realloc+0xd1>
    newsize = MIN_SIZE_ALIGNED;
  8042b1:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8042b6:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8042bb:	39 f0                	cmp    %esi,%eax
  8042bd:	0f 87 99 00 00 00    	ja     80435c <mem_realloc+0xdb>
  8042c3:	39 35 08 53 81 00    	cmp    %esi,0x815308
  8042c9:	0f 86 8d 00 00 00    	jbe    80435c <mem_realloc+0xdb>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8042cf:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8042d2:	29 c2                	sub    %eax,%edx
  8042d4:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8042d7:	8b 4e f4             	mov    -0xc(%esi),%ecx
  8042da:	8d 79 f4             	lea    -0xc(%ecx),%edi
  8042dd:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8042df:	39 df                	cmp    %ebx,%edi
  8042e1:	0f 82 8c 00 00 00    	jb     804373 <mem_realloc+0xf2>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  8042e7:	74 69                	je     804352 <mem_realloc+0xd1>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8042e9:	83 ec 08             	sub    $0x8,%esp
  8042ec:	6a 00                	push   $0x0
  8042ee:	ff 35 00 53 81 00    	pushl  0x815300
  8042f4:	e8 e8 60 00 00       	call   80a3e1 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  8042f9:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8042fe:	89 c2                	mov    %eax,%edx
  804300:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  804303:	83 c4 10             	add    $0x10,%esp
  804306:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80430a:	0f 85 85 00 00 00    	jne    804395 <mem_realloc+0x114>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804310:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804312:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804315:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  804319:	39 15 04 53 81 00    	cmp    %edx,0x815304
  80431f:	74 69                	je     80438a <mem_realloc+0x109>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  804321:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  804324:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804328:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  80432a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80432d:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  804330:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804333:	8b 12                	mov    (%edx),%edx
  804335:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80433b:	74 04                	je     804341 <mem_realloc+0xc0>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80433d:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804341:	83 ec 0c             	sub    $0xc,%esp
  804344:	ff 35 00 53 81 00    	pushl  0x815300
  80434a:	e8 1e 60 00 00       	call   80a36d <sys_sem_signal>
  return rmem;
  80434f:	83 c4 10             	add    $0x10,%esp
}
  804352:	89 f0                	mov    %esi,%eax
  804354:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804357:	5b                   	pop    %ebx
  804358:	5e                   	pop    %esi
  804359:	5f                   	pop    %edi
  80435a:	5d                   	pop    %ebp
  80435b:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80435c:	83 ec 04             	sub    $0x4,%esp
  80435f:	68 9b 1b 81 00       	push   $0x811b9b
  804364:	68 78 01 00 00       	push   $0x178
  804369:	68 2b 1b 81 00       	push   $0x811b2b
  80436e:	e8 c4 a5 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804373:	83 ec 04             	sub    $0x4,%esp
  804376:	68 84 1a 81 00       	push   $0x811a84
  80437b:	68 8a 01 00 00       	push   $0x18a
  804380:	68 2b 1b 81 00       	push   $0x811b2b
  804385:	e8 ad a5 00 00       	call   80e937 <_panic>
      lfree = (struct mem *)&ram[ptr2];
  80438a:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  80438d:	89 15 04 53 81 00    	mov    %edx,0x815304
  804393:	eb 8c                	jmp    804321 <mem_realloc+0xa0>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  804395:	8d 53 18             	lea    0x18(%ebx),%edx
  804398:	39 fa                	cmp    %edi,%edx
  80439a:	77 a5                	ja     804341 <mem_realloc+0xc0>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80439c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80439f:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8043a3:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8043a6:	39 15 04 53 81 00    	cmp    %edx,0x815304
  8043ac:	76 06                	jbe    8043b4 <mem_realloc+0x133>
      lfree = mem2;
  8043ae:	89 15 04 53 81 00    	mov    %edx,0x815304
    mem2->used = 0;
  8043b4:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8043b8:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8043bb:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8043bd:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8043c0:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8043c3:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8043c6:	8b 12                	mov    (%edx),%edx
  8043c8:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8043ce:	0f 84 6d ff ff ff    	je     804341 <mem_realloc+0xc0>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8043d4:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  8043d8:	e9 64 ff ff ff       	jmp    804341 <mem_realloc+0xc0>

008043dd <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8043dd:	f3 0f 1e fb          	endbr32 
  8043e1:	55                   	push   %ebp
  8043e2:	89 e5                	mov    %esp,%ebp
  8043e4:	57                   	push   %edi
  8043e5:	56                   	push   %esi
  8043e6:	53                   	push   %ebx
  8043e7:	83 ec 1c             	sub    $0x1c,%esp
  8043ea:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8043ed:	85 c0                	test   %eax,%eax
  8043ef:	0f 84 a1 01 00 00    	je     804596 <mem_malloc+0x1b9>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  8043f5:	83 c0 03             	add    $0x3,%eax
  8043f8:	83 e0 fc             	and    $0xfffffffc,%eax
  8043fb:	89 c7                	mov    %eax,%edi

  if(size < MIN_SIZE_ALIGNED) {
  8043fd:	83 f8 0b             	cmp    $0xb,%eax
  804400:	76 3a                	jbe    80443c <mem_malloc+0x5f>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  804402:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804407:	0f 87 90 01 00 00    	ja     80459d <mem_malloc+0x1c0>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80440d:	83 ec 08             	sub    $0x8,%esp
  804410:	6a 00                	push   $0x0
  804412:	ff 35 00 53 81 00    	pushl  0x815300
  804418:	e8 c4 5f 00 00       	call   80a3e1 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80441d:	a1 04 53 81 00       	mov    0x815304,%eax
  804422:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804425:	8b 35 0c 53 81 00    	mov    0x81530c,%esi
  80442b:	29 f0                	sub    %esi,%eax
  80442d:	83 c4 10             	add    $0x10,%esp
  804430:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804435:	29 f9                	sub    %edi,%ecx
  804437:	e9 e3 00 00 00       	jmp    80451f <mem_malloc+0x142>
    size = MIN_SIZE_ALIGNED;
  80443c:	bf 0c 00 00 00       	mov    $0xc,%edi
  804441:	eb ca                	jmp    80440d <mem_malloc+0x30>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  804443:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  804447:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  80444a:	74 4d                	je     804499 <mem_malloc+0xbc>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80444c:	83 ec 0c             	sub    $0xc,%esp
  80444f:	ff 35 00 53 81 00    	pushl  0x815300
  804455:	e8 13 5f 00 00       	call   80a36d <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80445a:	8d 44 3b 0c          	lea    0xc(%ebx,%edi,1),%eax
  80445e:	83 c4 10             	add    $0x10,%esp
  804461:	39 05 08 53 81 00    	cmp    %eax,0x815308
  804467:	0f 82 82 00 00 00    	jb     8044ef <mem_malloc+0x112>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80446d:	8d 43 0c             	lea    0xc(%ebx),%eax
  804470:	f6 c3 03             	test   $0x3,%bl
  804473:	0f 85 8d 00 00 00    	jne    804506 <mem_malloc+0x129>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  804479:	f6 c3 03             	test   $0x3,%bl
  80447c:	0f 84 0c 01 00 00    	je     80458e <mem_malloc+0x1b1>
  804482:	83 ec 04             	sub    $0x4,%esp
  804485:	68 08 1b 81 00       	push   $0x811b08
  80448a:	68 4e 02 00 00       	push   $0x24e
  80448f:	68 2b 1b 81 00       	push   $0x811b2b
  804494:	e8 9e a4 00 00       	call   80e937 <_panic>
          while (lfree->used && lfree != ram_end) {
  804499:	8b 15 08 53 81 00    	mov    0x815308,%edx
  80449f:	b8 00 00 00 00       	mov    $0x0,%eax
            lfree = (struct mem *)&ram[lfree->next];
  8044a4:	b9 01 00 00 00       	mov    $0x1,%ecx
  8044a9:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8044ac:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8044af:	eb 08                	jmp    8044b9 <mem_malloc+0xdc>
  8044b1:	89 f0                	mov    %esi,%eax
  8044b3:	03 07                	add    (%edi),%eax
  8044b5:	89 c7                	mov    %eax,%edi
  8044b7:	89 c8                	mov    %ecx,%eax
          while (lfree->used && lfree != ram_end) {
  8044b9:	80 7f 08 00          	cmpb   $0x0,0x8(%edi)
  8044bd:	74 18                	je     8044d7 <mem_malloc+0xfa>
  8044bf:	39 fa                	cmp    %edi,%edx
  8044c1:	75 ee                	jne    8044b1 <mem_malloc+0xd4>
  8044c3:	89 fe                	mov    %edi,%esi
  8044c5:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8044c8:	84 c0                	test   %al,%al
  8044ca:	74 80                	je     80444c <mem_malloc+0x6f>
  8044cc:	89 35 04 53 81 00    	mov    %esi,0x815304
  8044d2:	e9 75 ff ff ff       	jmp    80444c <mem_malloc+0x6f>
  8044d7:	89 fe                	mov    %edi,%esi
  8044d9:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8044dc:	84 c0                	test   %al,%al
  8044de:	0f 84 68 ff ff ff    	je     80444c <mem_malloc+0x6f>
  8044e4:	89 35 04 53 81 00    	mov    %esi,0x815304
  8044ea:	e9 5d ff ff ff       	jmp    80444c <mem_malloc+0x6f>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  8044ef:	83 ec 04             	sub    $0x4,%esp
  8044f2:	68 a8 1a 81 00       	push   $0x811aa8
  8044f7:	68 4a 02 00 00       	push   $0x24a
  8044fc:	68 2b 1b 81 00       	push   $0x811b2b
  804501:	e8 31 a4 00 00       	call   80e937 <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804506:	83 ec 04             	sub    $0x4,%esp
  804509:	68 d8 1a 81 00       	push   $0x811ad8
  80450e:	68 4c 02 00 00       	push   $0x24c
  804513:	68 2b 1b 81 00       	push   $0x811b2b
  804518:	e8 1a a4 00 00       	call   80e937 <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  80451d:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80451f:	39 c1                	cmp    %eax,%ecx
  804521:	76 55                	jbe    804578 <mem_malloc+0x19b>
      mem = (struct mem *)&ram[ptr];
  804523:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      if ((!mem->used) &&
  804526:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  80452a:	75 f1                	jne    80451d <mem_malloc+0x140>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80452c:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  804531:	29 c2                	sub    %eax,%edx
  804533:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  804535:	39 fa                	cmp    %edi,%edx
  804537:	72 e4                	jb     80451d <mem_malloc+0x140>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  804539:	8d 4f 18             	lea    0x18(%edi),%ecx
  80453c:	39 ca                	cmp    %ecx,%edx
  80453e:	0f 82 ff fe ff ff    	jb     804443 <mem_malloc+0x66>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  804544:	8d 4c 38 0c          	lea    0xc(%eax,%edi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  804548:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80454b:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  80454e:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  804552:	8b 0b                	mov    (%ebx),%ecx
  804554:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  804556:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  804559:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80455c:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  80455e:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  804562:	8b 02                	mov    (%edx),%eax
  804564:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804569:	0f 84 d8 fe ff ff    	je     804447 <mem_malloc+0x6a>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80456f:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  804573:	e9 cf fe ff ff       	jmp    804447 <mem_malloc+0x6a>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  804578:	83 ec 0c             	sub    $0xc,%esp
  80457b:	ff 35 00 53 81 00    	pushl  0x815300
  804581:	e8 e7 5d 00 00       	call   80a36d <sys_sem_signal>
  return NULL;
  804586:	83 c4 10             	add    $0x10,%esp
  804589:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80458e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804591:	5b                   	pop    %ebx
  804592:	5e                   	pop    %esi
  804593:	5f                   	pop    %edi
  804594:	5d                   	pop    %ebp
  804595:	c3                   	ret    
    return NULL;
  804596:	b8 00 00 00 00       	mov    $0x0,%eax
  80459b:	eb f1                	jmp    80458e <mem_malloc+0x1b1>
    return NULL;
  80459d:	b8 00 00 00 00       	mov    $0x0,%eax
  8045a2:	eb ea                	jmp    80458e <mem_malloc+0x1b1>

008045a4 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8045a4:	f3 0f 1e fb          	endbr32 
  8045a8:	55                   	push   %ebp
  8045a9:	89 e5                	mov    %esp,%ebp
  8045ab:	56                   	push   %esi
  8045ac:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8045ad:	8b 75 0c             	mov    0xc(%ebp),%esi
  8045b0:	0f af 75 08          	imul   0x8(%ebp),%esi
  8045b4:	83 ec 0c             	sub    $0xc,%esp
  8045b7:	56                   	push   %esi
  8045b8:	e8 20 fe ff ff       	call   8043dd <mem_malloc>
  8045bd:	89 c3                	mov    %eax,%ebx
  if (p) {
  8045bf:	83 c4 10             	add    $0x10,%esp
  8045c2:	85 c0                	test   %eax,%eax
  8045c4:	74 0f                	je     8045d5 <mem_calloc+0x31>
    /* zero the memory */
    memset(p, 0, count * size);
  8045c6:	83 ec 04             	sub    $0x4,%esp
  8045c9:	56                   	push   %esi
  8045ca:	6a 00                	push   $0x0
  8045cc:	50                   	push   %eax
  8045cd:	e8 08 ac 00 00       	call   80f1da <memset>
  8045d2:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8045d5:	89 d8                	mov    %ebx,%eax
  8045d7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8045da:	5b                   	pop    %ebx
  8045db:	5e                   	pop    %esi
  8045dc:	5d                   	pop    %ebp
  8045dd:	c3                   	ret    

008045de <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8045de:	f3 0f 1e fb          	endbr32 
  8045e2:	55                   	push   %ebp
  8045e3:	89 e5                	mov    %esp,%ebp
  8045e5:	56                   	push   %esi
  8045e6:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  8045e7:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  8045ec:	83 e0 fc             	and    $0xfffffffc,%eax
  8045ef:	ba 00 00 00 00       	mov    $0x0,%edx
  8045f4:	eb 2a                	jmp    804620 <memp_init+0x42>
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  8045f6:	8b 1c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ebx
  8045fd:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  8045ff:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  804606:	0f b7 9c 12 48 1c 81 	movzwl 0x811c48(%edx,%edx,1),%ebx
  80460d:	00 
  80460e:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  804610:	83 c1 01             	add    $0x1,%ecx
  804613:	66 39 ce             	cmp    %cx,%si
  804616:	75 de                	jne    8045f6 <memp_init+0x18>
  804618:	83 c2 01             	add    $0x1,%edx
  for (i = 0; i < MEMP_MAX; ++i) {
  80461b:	83 fa 0e             	cmp    $0xe,%edx
  80461e:	74 1a                	je     80463a <memp_init+0x5c>
    memp_tab[i] = NULL;
  804620:	c7 04 95 c0 43 b3 00 	movl   $0x0,0xb343c0(,%edx,4)
  804627:	00 00 00 00 
    for (j = 0; j < memp_num[i]; ++j) {
  80462b:	0f b7 b4 12 2c 1c 81 	movzwl 0x811c2c(%edx,%edx,1),%esi
  804632:	00 
  804633:	b9 00 00 00 00       	mov    $0x0,%ecx
  804638:	eb d9                	jmp    804613 <memp_init+0x35>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80463a:	5b                   	pop    %ebx
  80463b:	5e                   	pop    %esi
  80463c:	5d                   	pop    %ebp
  80463d:	c3                   	ret    

0080463e <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80463e:	f3 0f 1e fb          	endbr32 
  804642:	55                   	push   %ebp
  804643:	89 e5                	mov    %esp,%ebp
  804645:	83 ec 08             	sub    $0x8,%esp
  804648:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80464b:	83 fa 0d             	cmp    $0xd,%edx
  80464e:	77 1a                	ja     80466a <memp_malloc+0x2c>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804650:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804657:	85 c0                	test   %eax,%eax
  804659:	74 0d                	je     804668 <memp_malloc+0x2a>
    memp_tab[type] = memp->next;    
  80465b:	8b 08                	mov    (%eax),%ecx
  80465d:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804664:	a8 03                	test   $0x3,%al
  804666:	75 19                	jne    804681 <memp_malloc+0x43>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804668:	c9                   	leave  
  804669:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80466a:	83 ec 04             	sub    $0x4,%esp
  80466d:	68 b5 1b 81 00       	push   $0x811bb5
  804672:	68 2d 01 00 00       	push   $0x12d
  804677:	68 d2 1b 81 00       	push   $0x811bd2
  80467c:	e8 b6 a2 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804681:	83 ec 04             	sub    $0x4,%esp
  804684:	68 e8 1b 81 00       	push   $0x811be8
  804689:	68 3e 01 00 00       	push   $0x13e
  80468e:	68 d2 1b 81 00       	push   $0x811bd2
  804693:	e8 9f a2 00 00       	call   80e937 <_panic>

00804698 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  804698:	f3 0f 1e fb          	endbr32 
  80469c:	55                   	push   %ebp
  80469d:	89 e5                	mov    %esp,%ebp
  80469f:	83 ec 08             	sub    $0x8,%esp
  8046a2:	8b 55 08             	mov    0x8(%ebp),%edx
  8046a5:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8046a8:	85 c0                	test   %eax,%eax
  8046aa:	74 14                	je     8046c0 <memp_free+0x28>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8046ac:	a8 03                	test   $0x3,%al
  8046ae:	75 12                	jne    8046c2 <memp_free+0x2a>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8046b0:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  8046b7:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8046b9:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8046c0:	c9                   	leave  
  8046c1:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  8046c2:	83 ec 04             	sub    $0x4,%esp
  8046c5:	68 0c 1c 81 00       	push   $0x811c0c
  8046ca:	68 5a 01 00 00       	push   $0x15a
  8046cf:	68 d2 1b 81 00       	push   $0x811bd2
  8046d4:	e8 5e a2 00 00       	call   80e937 <_panic>

008046d9 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8046d9:	f3 0f 1e fb          	endbr32 
  8046dd:	55                   	push   %ebp
  8046de:	89 e5                	mov    %esp,%ebp
  8046e0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8046e3:	85 c9                	test   %ecx,%ecx
  8046e5:	74 2c                	je     804713 <netif_remove+0x3a>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8046e7:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8046ec:	39 c8                	cmp    %ecx,%eax
  8046ee:	74 0e                	je     8046fe <netif_remove+0x25>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8046f0:	85 c0                	test   %eax,%eax
  8046f2:	74 1f                	je     804713 <netif_remove+0x3a>
      if (tmpNetif->next == netif) {
  8046f4:	8b 10                	mov    (%eax),%edx
  8046f6:	39 ca                	cmp    %ecx,%edx
  8046f8:	74 0d                	je     804707 <netif_remove+0x2e>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8046fa:	89 d0                	mov    %edx,%eax
  8046fc:	eb f2                	jmp    8046f0 <netif_remove+0x17>
    netif_list = netif->next;
  8046fe:	8b 01                	mov    (%ecx),%eax
  804700:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  804705:	eb 04                	jmp    80470b <netif_remove+0x32>
        tmpNetif->next = netif->next;
  804707:	8b 11                	mov    (%ecx),%edx
  804709:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  80470b:	39 0d 38 b2 b3 00    	cmp    %ecx,0xb3b238
  804711:	74 02                	je     804715 <netif_remove+0x3c>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804713:	5d                   	pop    %ebp
  804714:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804715:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  80471c:	00 00 00 
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80471f:	eb f2                	jmp    804713 <netif_remove+0x3a>

00804721 <netif_find>:
{
  804721:	f3 0f 1e fb          	endbr32 
  804725:	55                   	push   %ebp
  804726:	89 e5                	mov    %esp,%ebp
  804728:	53                   	push   %ebx
  804729:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  80472c:	85 c9                	test   %ecx,%ecx
  80472e:	74 2d                	je     80475d <netif_find+0x3c>
  num = name[2] - '0';
  804730:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804734:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804737:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  80473c:	eb 02                	jmp    804740 <netif_find+0x1f>
  80473e:	8b 00                	mov    (%eax),%eax
  804740:	85 c0                	test   %eax,%eax
  804742:	74 16                	je     80475a <netif_find+0x39>
    if (num == netif->num &&
  804744:	38 50 31             	cmp    %dl,0x31(%eax)
  804747:	75 f5                	jne    80473e <netif_find+0x1d>
  804749:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  80474d:	38 19                	cmp    %bl,(%ecx)
  80474f:	75 ed                	jne    80473e <netif_find+0x1d>
       name[0] == netif->name[0] &&
  804751:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804755:	38 59 01             	cmp    %bl,0x1(%ecx)
  804758:	75 e4                	jne    80473e <netif_find+0x1d>
}
  80475a:	5b                   	pop    %ebx
  80475b:	5d                   	pop    %ebp
  80475c:	c3                   	ret    
    return NULL;
  80475d:	89 c8                	mov    %ecx,%eax
  80475f:	eb f9                	jmp    80475a <netif_find+0x39>

00804761 <netif_set_ipaddr>:
{
  804761:	f3 0f 1e fb          	endbr32 
  804765:	55                   	push   %ebp
  804766:	89 e5                	mov    %esp,%ebp
  804768:	57                   	push   %edi
  804769:	56                   	push   %esi
  80476a:	53                   	push   %ebx
  80476b:	83 ec 0c             	sub    $0xc,%esp
  80476e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804771:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804774:	8b 43 04             	mov    0x4(%ebx),%eax
  804777:	39 06                	cmp    %eax,(%esi)
  804779:	74 47                	je     8047c2 <netif_set_ipaddr+0x61>
    pcb = tcp_active_pcbs;
  80477b:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  804780:	eb 11                	jmp    804793 <netif_set_ipaddr+0x32>
        struct tcp_pcb *next = pcb->next;
  804782:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  804785:	83 ec 0c             	sub    $0xc,%esp
  804788:	50                   	push   %eax
  804789:	e8 45 16 00 00       	call   805dd3 <tcp_abort>
  80478e:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  804791:	89 f8                	mov    %edi,%eax
    while (pcb != NULL) {
  804793:	85 c0                	test   %eax,%eax
  804795:	74 0c                	je     8047a3 <netif_set_ipaddr+0x42>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804797:	8b 4b 04             	mov    0x4(%ebx),%ecx
  80479a:	39 08                	cmp    %ecx,(%eax)
  80479c:	74 e4                	je     804782 <netif_set_ipaddr+0x21>
        pcb = pcb->next;
  80479e:	8b 40 0c             	mov    0xc(%eax),%eax
  8047a1:	eb f0                	jmp    804793 <netif_set_ipaddr+0x32>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8047a3:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  8047a8:	eb 03                	jmp    8047ad <netif_set_ipaddr+0x4c>
  8047aa:	8b 40 0c             	mov    0xc(%eax),%eax
  8047ad:	85 c0                	test   %eax,%eax
  8047af:	74 11                	je     8047c2 <netif_set_ipaddr+0x61>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8047b1:	8b 10                	mov    (%eax),%edx
  8047b3:	85 d2                	test   %edx,%edx
  8047b5:	74 f3                	je     8047aa <netif_set_ipaddr+0x49>
  8047b7:	3b 53 04             	cmp    0x4(%ebx),%edx
  8047ba:	75 ee                	jne    8047aa <netif_set_ipaddr+0x49>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8047bc:	8b 16                	mov    (%esi),%edx
  8047be:	89 10                	mov    %edx,(%eax)
  8047c0:	eb e8                	jmp    8047aa <netif_set_ipaddr+0x49>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8047c2:	8b 06                	mov    (%esi),%eax
  8047c4:	89 43 04             	mov    %eax,0x4(%ebx)
}
  8047c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8047ca:	5b                   	pop    %ebx
  8047cb:	5e                   	pop    %esi
  8047cc:	5f                   	pop    %edi
  8047cd:	5d                   	pop    %ebp
  8047ce:	c3                   	ret    

008047cf <netif_set_addr>:
{
  8047cf:	f3 0f 1e fb          	endbr32 
  8047d3:	55                   	push   %ebp
  8047d4:	89 e5                	mov    %esp,%ebp
  8047d6:	57                   	push   %edi
  8047d7:	56                   	push   %esi
  8047d8:	53                   	push   %ebx
  8047d9:	83 ec 14             	sub    $0x14,%esp
  8047dc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8047df:	8b 7d 10             	mov    0x10(%ebp),%edi
  8047e2:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  8047e5:	ff 75 0c             	pushl  0xc(%ebp)
  8047e8:	53                   	push   %ebx
  8047e9:	e8 73 ff ff ff       	call   804761 <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  8047ee:	83 c4 10             	add    $0x10,%esp
  8047f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8047f6:	85 ff                	test   %edi,%edi
  8047f8:	74 02                	je     8047fc <netif_set_addr+0x2d>
  8047fa:	8b 07                	mov    (%edi),%eax
  8047fc:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  8047ff:	b8 00 00 00 00       	mov    $0x0,%eax
  804804:	85 f6                	test   %esi,%esi
  804806:	74 02                	je     80480a <netif_set_addr+0x3b>
  804808:	8b 06                	mov    (%esi),%eax
  80480a:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  80480d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804810:	5b                   	pop    %ebx
  804811:	5e                   	pop    %esi
  804812:	5f                   	pop    %edi
  804813:	5d                   	pop    %ebp
  804814:	c3                   	ret    

00804815 <netif_add>:
{
  804815:	f3 0f 1e fb          	endbr32 
  804819:	55                   	push   %ebp
  80481a:	89 e5                	mov    %esp,%ebp
  80481c:	53                   	push   %ebx
  80481d:	83 ec 04             	sub    $0x4,%esp
  804820:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  804823:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  80482a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804831:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804838:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  80483c:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  804843:	8b 45 18             	mov    0x18(%ebp),%eax
  804846:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804849:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  804850:	8d 50 01             	lea    0x1(%eax),%edx
  804853:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  804859:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  80485c:	8b 45 20             	mov    0x20(%ebp),%eax
  80485f:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  804862:	ff 75 14             	pushl  0x14(%ebp)
  804865:	ff 75 10             	pushl  0x10(%ebp)
  804868:	ff 75 0c             	pushl  0xc(%ebp)
  80486b:	53                   	push   %ebx
  80486c:	e8 5e ff ff ff       	call   8047cf <netif_set_addr>
  if (init(netif) != ERR_OK) {
  804871:	89 1c 24             	mov    %ebx,(%esp)
  804874:	ff 55 1c             	call   *0x1c(%ebp)
  804877:	83 c4 10             	add    $0x10,%esp
  80487a:	84 c0                	test   %al,%al
  80487c:	75 14                	jne    804892 <netif_add+0x7d>
  netif->next = netif_list;
  80487e:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804883:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804885:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  return netif;
  80488b:	89 d8                	mov    %ebx,%eax
}
  80488d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804890:	c9                   	leave  
  804891:	c3                   	ret    
    return NULL;
  804892:	b8 00 00 00 00       	mov    $0x0,%eax
  804897:	eb f4                	jmp    80488d <netif_add+0x78>

00804899 <netif_set_gw>:
{
  804899:	f3 0f 1e fb          	endbr32 
  80489d:	55                   	push   %ebp
  80489e:	89 e5                	mov    %esp,%ebp
  8048a0:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8048a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8048a8:	85 d2                	test   %edx,%edx
  8048aa:	74 02                	je     8048ae <netif_set_gw+0x15>
  8048ac:	8b 02                	mov    (%edx),%eax
  8048ae:	8b 55 08             	mov    0x8(%ebp),%edx
  8048b1:	89 42 0c             	mov    %eax,0xc(%edx)
}
  8048b4:	5d                   	pop    %ebp
  8048b5:	c3                   	ret    

008048b6 <netif_set_netmask>:
{
  8048b6:	f3 0f 1e fb          	endbr32 
  8048ba:	55                   	push   %ebp
  8048bb:	89 e5                	mov    %esp,%ebp
  8048bd:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  8048c0:	b8 00 00 00 00       	mov    $0x0,%eax
  8048c5:	85 d2                	test   %edx,%edx
  8048c7:	74 02                	je     8048cb <netif_set_netmask+0x15>
  8048c9:	8b 02                	mov    (%edx),%eax
  8048cb:	8b 55 08             	mov    0x8(%ebp),%edx
  8048ce:	89 42 08             	mov    %eax,0x8(%edx)
}
  8048d1:	5d                   	pop    %ebp
  8048d2:	c3                   	ret    

008048d3 <netif_set_default>:
{
  8048d3:	f3 0f 1e fb          	endbr32 
  8048d7:	55                   	push   %ebp
  8048d8:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  8048da:	8b 45 08             	mov    0x8(%ebp),%eax
  8048dd:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
}
  8048e2:	5d                   	pop    %ebp
  8048e3:	c3                   	ret    

008048e4 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8048e4:	f3 0f 1e fb          	endbr32 
  8048e8:	55                   	push   %ebp
  8048e9:	89 e5                	mov    %esp,%ebp
  8048eb:	83 ec 08             	sub    $0x8,%esp
  8048ee:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8048f1:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8048f5:	a8 01                	test   $0x1,%al
  8048f7:	75 0c                	jne    804905 <netif_set_up+0x21>
    netif->flags |= NETIF_FLAG_UP;
  8048f9:	89 c1                	mov    %eax,%ecx
  8048fb:	83 c9 01             	or     $0x1,%ecx
  8048fe:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804901:	a8 20                	test   $0x20,%al
  804903:	75 02                	jne    804907 <netif_set_up+0x23>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  804905:	c9                   	leave  
  804906:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  804907:	83 ec 04             	sub    $0x4,%esp
  80490a:	6a 00                	push   $0x0
  80490c:	8d 42 04             	lea    0x4(%edx),%eax
  80490f:	50                   	push   %eax
  804910:	52                   	push   %edx
  804911:	e8 a3 52 00 00       	call   809bb9 <etharp_query>
  804916:	83 c4 10             	add    $0x10,%esp
}
  804919:	eb ea                	jmp    804905 <netif_set_up+0x21>

0080491b <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80491b:	f3 0f 1e fb          	endbr32 
  80491f:	55                   	push   %ebp
  804920:	89 e5                	mov    %esp,%ebp
  804922:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  804925:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804929:	a8 01                	test   $0x1,%al
  80492b:	74 06                	je     804933 <netif_set_down+0x18>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80492d:	83 e0 fe             	and    $0xfffffffe,%eax
  804930:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804933:	5d                   	pop    %ebp
  804934:	c3                   	ret    

00804935 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804935:	f3 0f 1e fb          	endbr32 
  804939:	55                   	push   %ebp
  80493a:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80493c:	8b 45 08             	mov    0x8(%ebp),%eax
  80493f:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804943:	83 e0 01             	and    $0x1,%eax
}
  804946:	5d                   	pop    %ebp
  804947:	c3                   	ret    

00804948 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804948:	f3 0f 1e fb          	endbr32 
  80494c:	55                   	push   %ebp
  80494d:	89 e5                	mov    %esp,%ebp
  80494f:	56                   	push   %esi
  804950:	53                   	push   %ebx
  804951:	8b 45 08             	mov    0x8(%ebp),%eax
  804954:	8b 55 0c             	mov    0xc(%ebp),%edx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804957:	85 c0                	test   %eax,%eax
  804959:	74 42                	je     80499d <pbuf_header+0x55>
  if ((header_size_increment == 0) || (p == NULL))
  80495b:	66 85 d2             	test   %dx,%dx
  80495e:	0f 84 b0 00 00 00    	je     804a14 <pbuf_header+0xcc>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804964:	89 d6                	mov    %edx,%esi
  if (header_size_increment < 0){
  804966:	78 4c                	js     8049b4 <pbuf_header+0x6c>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804968:	0f b6 48 0c          	movzbl 0xc(%eax),%ecx
  /* remember current payload pointer */
  payload = p->payload;
  80496c:	8b 58 04             	mov    0x4(%eax),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80496f:	66 85 c9             	test   %cx,%cx
  804972:	74 5f                	je     8049d3 <pbuf_header+0x8b>
  804974:	66 83 f9 03          	cmp    $0x3,%cx
  804978:	74 59                	je     8049d3 <pbuf_header+0x8b>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80497a:	83 e9 01             	sub    $0x1,%ecx
  80497d:	66 83 f9 01          	cmp    $0x1,%cx
  804981:	77 7a                	ja     8049fd <pbuf_header+0xb5>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  804983:	b9 01 00 00 00       	mov    $0x1,%ecx
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804988:	66 85 d2             	test   %dx,%dx
  80498b:	79 67                	jns    8049f4 <pbuf_header+0xac>
  80498d:	66 39 70 0a          	cmp    %si,0xa(%eax)
  804991:	72 61                	jb     8049f4 <pbuf_header+0xac>
      p->payload = (u8_t *)p->payload - header_size_increment;
  804993:	0f bf ca             	movswl %dx,%ecx
  804996:	29 cb                	sub    %ecx,%ebx
  804998:	89 58 04             	mov    %ebx,0x4(%eax)
  80499b:	eb 4a                	jmp    8049e7 <pbuf_header+0x9f>
  LWIP_ASSERT("p != NULL", p != NULL);
  80499d:	83 ec 04             	sub    $0x4,%esp
  8049a0:	68 28 1d 81 00       	push   $0x811d28
  8049a5:	68 64 01 00 00       	push   $0x164
  8049aa:	68 64 1c 81 00       	push   $0x811c64
  8049af:	e8 83 9f 00 00       	call   80e937 <_panic>
    increment_magnitude = -header_size_increment;
  8049b4:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  8049b6:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8049ba:	73 ac                	jae    804968 <pbuf_header+0x20>
  8049bc:	83 ec 04             	sub    $0x4,%esp
  8049bf:	68 79 1c 81 00       	push   $0x811c79
  8049c4:	68 6b 01 00 00       	push   $0x16b
  8049c9:	68 64 1c 81 00       	push   $0x811c64
  8049ce:	e8 64 9f 00 00       	call   80e937 <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8049d3:	0f bf ca             	movswl %dx,%ecx
  8049d6:	29 cb                	sub    %ecx,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8049d8:	8d 70 10             	lea    0x10(%eax),%esi
      return 1;
  8049db:	b9 01 00 00 00       	mov    $0x1,%ecx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8049e0:	39 f3                	cmp    %esi,%ebx
  8049e2:	72 10                	jb     8049f4 <pbuf_header+0xac>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8049e4:	89 58 04             	mov    %ebx,0x4(%eax)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8049e7:	66 01 50 0a          	add    %dx,0xa(%eax)
  p->tot_len += header_size_increment;
  8049eb:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8049ef:	b9 00 00 00 00       	mov    $0x0,%ecx
}
  8049f4:	89 c8                	mov    %ecx,%eax
  8049f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8049f9:	5b                   	pop    %ebx
  8049fa:	5e                   	pop    %esi
  8049fb:	5d                   	pop    %ebp
  8049fc:	c3                   	ret    
    LWIP_ASSERT("bad pbuf type", 0);
  8049fd:	83 ec 04             	sub    $0x4,%esp
  804a00:	68 97 1c 81 00       	push   $0x811c97
  804a05:	68 9a 01 00 00       	push   $0x19a
  804a0a:	68 64 1c 81 00       	push   $0x811c64
  804a0f:	e8 23 9f 00 00       	call   80e937 <_panic>
    return 0;
  804a14:	b9 00 00 00 00       	mov    $0x0,%ecx
  804a19:	eb d9                	jmp    8049f4 <pbuf_header+0xac>

00804a1b <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804a1b:	f3 0f 1e fb          	endbr32 
  804a1f:	55                   	push   %ebp
  804a20:	89 e5                	mov    %esp,%ebp
  804a22:	56                   	push   %esi
  804a23:	53                   	push   %ebx
  804a24:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804a27:	85 c0                	test   %eax,%eax
  804a29:	74 0d                	je     804a38 <pbuf_free+0x1d>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804a2b:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  804a2f:	77 1e                	ja     804a4f <pbuf_free+0x34>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  804a31:	bb 00 00 00 00       	mov    $0x0,%ebx
  804a36:	eb 6c                	jmp    804aa4 <pbuf_free+0x89>
    LWIP_ASSERT("p != NULL", p != NULL);
  804a38:	83 ec 04             	sub    $0x4,%esp
  804a3b:	68 28 1d 81 00       	push   $0x811d28
  804a40:	68 d0 01 00 00       	push   $0x1d0
  804a45:	68 64 1c 81 00       	push   $0x811c64
  804a4a:	e8 e8 9e 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  804a4f:	83 ec 04             	sub    $0x4,%esp
  804a52:	68 a5 1c 81 00       	push   $0x811ca5
  804a57:	68 d9 01 00 00       	push   $0x1d9
  804a5c:	68 64 1c 81 00       	push   $0x811c64
  804a61:	e8 d1 9e 00 00       	call   80e937 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804a66:	83 ec 04             	sub    $0x4,%esp
  804a69:	68 ba 1c 81 00       	push   $0x811cba
  804a6e:	68 e8 01 00 00       	push   $0x1e8
  804a73:	68 64 1c 81 00       	push   $0x811c64
  804a78:	e8 ba 9e 00 00       	call   80e937 <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  804a7d:	83 ec 08             	sub    $0x8,%esp
  804a80:	50                   	push   %eax
  804a81:	6a 0d                	push   $0xd
  804a83:	e8 10 fc ff ff       	call   804698 <memp_free>
  804a88:	83 c4 10             	add    $0x10,%esp
  804a8b:	eb 0e                	jmp    804a9b <pbuf_free+0x80>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  804a8d:	83 ec 08             	sub    $0x8,%esp
  804a90:	50                   	push   %eax
  804a91:	6a 0c                	push   $0xc
  804a93:	e8 00 fc ff ff       	call   804698 <memp_free>
  804a98:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  804a9b:	83 c3 01             	add    $0x1,%ebx
  while (p != NULL) {
  804a9e:	85 f6                	test   %esi,%esi
  804aa0:	74 3a                	je     804adc <pbuf_free+0xc1>
      /* proceed to next pbuf */
      p = q;
  804aa2:	89 f0                	mov    %esi,%eax
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804aa4:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  804aa8:	66 85 d2             	test   %dx,%dx
  804aab:	74 b9                	je     804a66 <pbuf_free+0x4b>
    ref = --(p->ref);
  804aad:	83 ea 01             	sub    $0x1,%edx
  804ab0:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  804ab4:	66 85 d2             	test   %dx,%dx
  804ab7:	75 23                	jne    804adc <pbuf_free+0xc1>
      q = p->next;
  804ab9:	8b 30                	mov    (%eax),%esi
      type = p->type;
  804abb:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  804abf:	66 83 fa 03          	cmp    $0x3,%dx
  804ac3:	74 b8                	je     804a7d <pbuf_free+0x62>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804ac5:	83 ea 01             	sub    $0x1,%edx
  804ac8:	66 83 fa 01          	cmp    $0x1,%dx
  804acc:	76 bf                	jbe    804a8d <pbuf_free+0x72>
        mem_free(p);
  804ace:	83 ec 0c             	sub    $0xc,%esp
  804ad1:	50                   	push   %eax
  804ad2:	e8 0f f6 ff ff       	call   8040e6 <mem_free>
  804ad7:	83 c4 10             	add    $0x10,%esp
  804ada:	eb bf                	jmp    804a9b <pbuf_free+0x80>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804adc:	89 d8                	mov    %ebx,%eax
  804ade:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804ae1:	5b                   	pop    %ebx
  804ae2:	5e                   	pop    %esi
  804ae3:	5d                   	pop    %ebp
  804ae4:	c3                   	ret    

00804ae5 <pbuf_alloc>:
{
  804ae5:	f3 0f 1e fb          	endbr32 
  804ae9:	55                   	push   %ebp
  804aea:	89 e5                	mov    %esp,%ebp
  804aec:	57                   	push   %edi
  804aed:	56                   	push   %esi
  804aee:	53                   	push   %ebx
  804aef:	83 ec 1c             	sub    $0x1c,%esp
  804af2:	8b 45 08             	mov    0x8(%ebp),%eax
  804af5:	8b 75 0c             	mov    0xc(%ebp),%esi
  804af8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  switch (layer) {
  804afb:	83 f8 02             	cmp    $0x2,%eax
  804afe:	0f 84 8b 00 00 00    	je     804b8f <pbuf_alloc+0xaa>
  804b04:	77 14                	ja     804b1a <pbuf_alloc+0x35>
  offset = 0;
  804b06:	83 f8 01             	cmp    $0x1,%eax
  804b09:	19 ff                	sbb    %edi,%edi
  804b0b:	83 e7 14             	and    $0x14,%edi
    offset += PBUF_IP_HLEN;
  804b0e:	83 c7 14             	add    $0x14,%edi
    offset += PBUF_LINK_HLEN;
  804b11:	8d 47 0e             	lea    0xe(%edi),%eax
  804b14:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  804b18:	eb 0b                	jmp    804b25 <pbuf_alloc+0x40>
  switch (layer) {
  804b1a:	83 f8 03             	cmp    $0x3,%eax
  804b1d:	75 7a                	jne    804b99 <pbuf_alloc+0xb4>
  804b1f:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  switch (type) {
  804b25:	83 fb 02             	cmp    $0x2,%ebx
  804b28:	0f 87 82 00 00 00    	ja     804bb0 <pbuf_alloc+0xcb>
  804b2e:	85 db                	test   %ebx,%ebx
  804b30:	0f 85 c3 01 00 00    	jne    804cf9 <pbuf_alloc+0x214>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  804b36:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  804b3a:	83 ec 0c             	sub    $0xc,%esp
  804b3d:	8d 43 13             	lea    0x13(%ebx),%eax
  804b40:	83 e0 fc             	and    $0xfffffffc,%eax
  804b43:	89 c2                	mov    %eax,%edx
  804b45:	0f b7 c6             	movzwl %si,%eax
  804b48:	83 c0 03             	add    $0x3,%eax
  804b4b:	83 e0 fc             	and    $0xfffffffc,%eax
  804b4e:	01 d0                	add    %edx,%eax
  804b50:	50                   	push   %eax
  804b51:	e8 87 f8 ff ff       	call   8043dd <mem_malloc>
  804b56:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804b58:	83 c4 10             	add    $0x10,%esp
  804b5b:	85 c0                	test   %eax,%eax
  804b5d:	74 26                	je     804b85 <pbuf_alloc+0xa0>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804b5f:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  804b63:	83 e0 fc             	and    $0xfffffffc,%eax
  804b66:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  804b69:	66 89 77 08          	mov    %si,0x8(%edi)
  804b6d:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  804b71:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  804b77:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  804b7b:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  804b81:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  804b85:	89 f8                	mov    %edi,%eax
  804b87:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804b8a:	5b                   	pop    %ebx
  804b8b:	5e                   	pop    %esi
  804b8c:	5f                   	pop    %edi
  804b8d:	5d                   	pop    %ebp
  804b8e:	c3                   	ret    
  switch (layer) {
  804b8f:	bf 00 00 00 00       	mov    $0x0,%edi
  804b94:	e9 78 ff ff ff       	jmp    804b11 <pbuf_alloc+0x2c>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804b99:	83 ec 04             	sub    $0x4,%esp
  804b9c:	68 d0 1c 81 00       	push   $0x811cd0
  804ba1:	68 8a 00 00 00       	push   $0x8a
  804ba6:	68 64 1c 81 00       	push   $0x811c64
  804bab:	e8 87 9d 00 00       	call   80e937 <_panic>
  switch (type) {
  804bb0:	83 fb 03             	cmp    $0x3,%ebx
  804bb3:	0f 85 74 01 00 00    	jne    804d2d <pbuf_alloc+0x248>
      p = memp_malloc(MEMP_PBUF_POOL);
  804bb9:	83 ec 0c             	sub    $0xc,%esp
  804bbc:	6a 0d                	push   $0xd
  804bbe:	e8 7b fa ff ff       	call   80463e <memp_malloc>
  804bc3:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804bc5:	83 c4 10             	add    $0x10,%esp
  804bc8:	85 c0                	test   %eax,%eax
  804bca:	74 b9                	je     804b85 <pbuf_alloc+0xa0>
    p->type = type;
  804bcc:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804bd0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804bd6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804bda:	8d 54 07 13          	lea    0x13(%edi,%eax,1),%edx
  804bde:	83 e2 fc             	and    $0xfffffffc,%edx
  804be1:	89 57 04             	mov    %edx,0x4(%edi)
    p->tot_len = length;
  804be4:	66 89 77 08          	mov    %si,0x8(%edi)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804be8:	0f b7 f6             	movzwl %si,%esi
  804beb:	83 c0 03             	add    $0x3,%eax
  804bee:	83 e0 fc             	and    $0xfffffffc,%eax
  804bf1:	89 c1                	mov    %eax,%ecx
  804bf3:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804bf8:	29 c8                	sub    %ecx,%eax
  804bfa:	39 f0                	cmp    %esi,%eax
  804bfc:	0f 4f c6             	cmovg  %esi,%eax
  804bff:	66 89 47 0a          	mov    %ax,0xa(%edi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804c03:	8d 9f e0 07 00 00    	lea    0x7e0(%edi),%ebx
  804c09:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  804c0c:	01 c2                	add    %eax,%edx
  804c0e:	39 d3                	cmp    %edx,%ebx
  804c10:	72 76                	jb     804c88 <pbuf_alloc+0x1a3>
    p->ref = 1;
  804c12:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  804c18:	29 c6                	sub    %eax,%esi
    r = p;
  804c1a:	89 fb                	mov    %edi,%ebx
    while (rem_len > 0) {
  804c1c:	85 f6                	test   %esi,%esi
  804c1e:	0f 8e 57 ff ff ff    	jle    804b7b <pbuf_alloc+0x96>
      q = memp_malloc(MEMP_PBUF_POOL);
  804c24:	83 ec 0c             	sub    $0xc,%esp
  804c27:	6a 0d                	push   $0xd
  804c29:	e8 10 fa ff ff       	call   80463e <memp_malloc>
      if (q == NULL) {
  804c2e:	83 c4 10             	add    $0x10,%esp
  804c31:	85 c0                	test   %eax,%eax
  804c33:	74 6a                	je     804c9f <pbuf_alloc+0x1ba>
      q->type = type;
  804c35:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804c39:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804c3d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804c43:	89 03                	mov    %eax,(%ebx)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804c45:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804c4b:	7f 67                	jg     804cb4 <pbuf_alloc+0x1cf>
      q->tot_len = (u16_t)rem_len;
  804c4d:	66 89 70 08          	mov    %si,0x8(%eax)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804c51:	66 81 fe d0 07       	cmp    $0x7d0,%si
  804c56:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804c5b:	0f 46 d6             	cmovbe %esi,%edx
  804c5e:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804c62:	8d 48 10             	lea    0x10(%eax),%ecx
  804c65:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804c68:	f6 c1 03             	test   $0x3,%cl
  804c6b:	75 5e                	jne    804ccb <pbuf_alloc+0x1e6>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804c6d:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804c71:	03 4f 04             	add    0x4(%edi),%ecx
  804c74:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804c77:	72 69                	jb     804ce2 <pbuf_alloc+0x1fd>
      q->ref = 1;
  804c79:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      rem_len -= q->len;
  804c7f:	0f b7 d2             	movzwl %dx,%edx
  804c82:	29 d6                	sub    %edx,%esi
      r = q;
  804c84:	89 c3                	mov    %eax,%ebx
  804c86:	eb 94                	jmp    804c1c <pbuf_alloc+0x137>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804c88:	83 ec 04             	sub    $0x4,%esp
  804c8b:	68 e8 1d 81 00       	push   $0x811de8
  804c90:	68 a1 00 00 00       	push   $0xa1
  804c95:	68 64 1c 81 00       	push   $0x811c64
  804c9a:	e8 98 9c 00 00       	call   80e937 <_panic>
  804c9f:	89 c3                	mov    %eax,%ebx
        pbuf_free(p);
  804ca1:	83 ec 0c             	sub    $0xc,%esp
  804ca4:	57                   	push   %edi
  804ca5:	e8 71 fd ff ff       	call   804a1b <pbuf_free>
        return NULL;
  804caa:	83 c4 10             	add    $0x10,%esp
  804cad:	89 df                	mov    %ebx,%edi
  804caf:	e9 d1 fe ff ff       	jmp    804b85 <pbuf_alloc+0xa0>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804cb4:	83 ec 04             	sub    $0x4,%esp
  804cb7:	68 eb 1c 81 00       	push   $0x811ceb
  804cbc:	68 bc 00 00 00       	push   $0xbc
  804cc1:	68 64 1c 81 00       	push   $0x811c64
  804cc6:	e8 6c 9c 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804ccb:	83 ec 04             	sub    $0x4,%esp
  804cce:	68 1c 1e 81 00       	push   $0x811e1c
  804cd3:	68 c1 00 00 00       	push   $0xc1
  804cd8:	68 64 1c 81 00       	push   $0x811c64
  804cdd:	e8 55 9c 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804ce2:	83 ec 04             	sub    $0x4,%esp
  804ce5:	68 e8 1d 81 00       	push   $0x811de8
  804cea:	68 c3 00 00 00       	push   $0xc3
  804cef:	68 64 1c 81 00       	push   $0x811c64
  804cf4:	e8 3e 9c 00 00       	call   80e937 <_panic>
    p = memp_malloc(MEMP_PBUF);
  804cf9:	83 ec 0c             	sub    $0xc,%esp
  804cfc:	6a 0c                	push   $0xc
  804cfe:	e8 3b f9 ff ff       	call   80463e <memp_malloc>
  804d03:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804d05:	83 c4 10             	add    $0x10,%esp
  804d08:	85 c0                	test   %eax,%eax
  804d0a:	0f 84 75 fe ff ff    	je     804b85 <pbuf_alloc+0xa0>
    p->payload = NULL;
  804d10:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804d17:	66 89 70 08          	mov    %si,0x8(%eax)
  804d1b:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804d1f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804d25:	88 58 0c             	mov    %bl,0xc(%eax)
    break;
  804d28:	e9 4e fe ff ff       	jmp    804b7b <pbuf_alloc+0x96>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804d2d:	83 ec 04             	sub    $0x4,%esp
  804d30:	68 ff 1c 81 00       	push   $0x811cff
  804d35:	68 f1 00 00 00       	push   $0xf1
  804d3a:	68 64 1c 81 00       	push   $0x811c64
  804d3f:	e8 f3 9b 00 00       	call   80e937 <_panic>

00804d44 <pbuf_realloc>:
{
  804d44:	f3 0f 1e fb          	endbr32 
  804d48:	55                   	push   %ebp
  804d49:	89 e5                	mov    %esp,%ebp
  804d4b:	57                   	push   %edi
  804d4c:	56                   	push   %esi
  804d4d:	53                   	push   %ebx
  804d4e:	83 ec 0c             	sub    $0xc,%esp
  804d51:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804d54:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804d57:	85 db                	test   %ebx,%ebx
  804d59:	74 53                	je     804dae <pbuf_realloc+0x6a>
  804d5b:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804d5d:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804d61:	77 62                	ja     804dc5 <pbuf_realloc+0x81>
  if (new_len >= p->tot_len) {
  804d63:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d67:	66 39 f0             	cmp    %si,%ax
  804d6a:	0f 86 ae 00 00 00    	jbe    804e1e <pbuf_realloc+0xda>
  grow = new_len - p->tot_len;
  804d70:	0f b7 ce             	movzwl %si,%ecx
  804d73:	0f b7 f8             	movzwl %ax,%edi
  804d76:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804d78:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804d7a:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d7e:	66 39 f0             	cmp    %si,%ax
  804d81:	73 70                	jae    804df3 <pbuf_realloc+0xaf>
    rem_len -= q->len;
  804d83:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804d85:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804d8b:	7f 4f                	jg     804ddc <pbuf_realloc+0x98>
    q->tot_len += (u16_t)grow;
  804d8d:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804d91:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804d93:	85 db                	test   %ebx,%ebx
  804d95:	75 e3                	jne    804d7a <pbuf_realloc+0x36>
  804d97:	83 ec 04             	sub    $0x4,%esp
  804d9a:	68 5e 1d 81 00       	push   $0x811d5e
  804d9f:	68 2f 01 00 00       	push   $0x12f
  804da4:	68 64 1c 81 00       	push   $0x811c64
  804da9:	e8 89 9b 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804dae:	83 ec 04             	sub    $0x4,%esp
  804db1:	68 1a 1d 81 00       	push   $0x811d1a
  804db6:	68 13 01 00 00       	push   $0x113
  804dbb:	68 64 1c 81 00       	push   $0x811c64
  804dc0:	e8 72 9b 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804dc5:	83 ec 04             	sub    $0x4,%esp
  804dc8:	68 32 1d 81 00       	push   $0x811d32
  804dcd:	68 14 01 00 00       	push   $0x114
  804dd2:	68 64 1c 81 00       	push   $0x811c64
  804dd7:	e8 5b 9b 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804ddc:	83 ec 04             	sub    $0x4,%esp
  804ddf:	68 4d 1d 81 00       	push   $0x811d4d
  804de4:	68 2b 01 00 00       	push   $0x12b
  804de9:	68 64 1c 81 00       	push   $0x811c64
  804dee:	e8 44 9b 00 00       	call   80e937 <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804df3:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804df7:	75 05                	jne    804dfe <pbuf_realloc+0xba>
  804df9:	66 39 f0             	cmp    %si,%ax
  804dfc:	75 28                	jne    804e26 <pbuf_realloc+0xe2>
  q->len = rem_len;
  804dfe:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804e02:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804e06:	8b 03                	mov    (%ebx),%eax
  804e08:	85 c0                	test   %eax,%eax
  804e0a:	74 0c                	je     804e18 <pbuf_realloc+0xd4>
    pbuf_free(q->next);
  804e0c:	83 ec 0c             	sub    $0xc,%esp
  804e0f:	50                   	push   %eax
  804e10:	e8 06 fc ff ff       	call   804a1b <pbuf_free>
  804e15:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804e18:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804e1e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804e21:	5b                   	pop    %ebx
  804e22:	5e                   	pop    %esi
  804e23:	5f                   	pop    %edi
  804e24:	5d                   	pop    %ebp
  804e25:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804e26:	8b 43 04             	mov    0x4(%ebx),%eax
  804e29:	29 d8                	sub    %ebx,%eax
  804e2b:	0f b7 d6             	movzwl %si,%edx
  804e2e:	01 d0                	add    %edx,%eax
  804e30:	83 ec 08             	sub    $0x8,%esp
  804e33:	50                   	push   %eax
  804e34:	53                   	push   %ebx
  804e35:	e8 47 f4 ff ff       	call   804281 <mem_realloc>
  804e3a:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804e3c:	83 c4 10             	add    $0x10,%esp
  804e3f:	85 c0                	test   %eax,%eax
  804e41:	75 bb                	jne    804dfe <pbuf_realloc+0xba>
  804e43:	83 ec 04             	sub    $0x4,%esp
  804e46:	68 76 1d 81 00       	push   $0x811d76
  804e4b:	68 39 01 00 00       	push   $0x139
  804e50:	68 64 1c 81 00       	push   $0x811c64
  804e55:	e8 dd 9a 00 00       	call   80e937 <_panic>

00804e5a <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804e5a:	f3 0f 1e fb          	endbr32 
  804e5e:	55                   	push   %ebp
  804e5f:	89 e5                	mov    %esp,%ebp
  804e61:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t len;

  len = 0;
  804e64:	ba 00 00 00 00       	mov    $0x0,%edx
  while (p != NULL) {
  804e69:	85 c0                	test   %eax,%eax
  804e6b:	74 07                	je     804e74 <pbuf_clen+0x1a>
    ++len;
  804e6d:	83 c2 01             	add    $0x1,%edx
    p = p->next;
  804e70:	8b 00                	mov    (%eax),%eax
  804e72:	eb f5                	jmp    804e69 <pbuf_clen+0xf>
  }
  return len;
}
  804e74:	89 d0                	mov    %edx,%eax
  804e76:	5d                   	pop    %ebp
  804e77:	c3                   	ret    

00804e78 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804e78:	f3 0f 1e fb          	endbr32 
  804e7c:	55                   	push   %ebp
  804e7d:	89 e5                	mov    %esp,%ebp
  804e7f:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804e82:	85 c0                	test   %eax,%eax
  804e84:	74 05                	je     804e8b <pbuf_ref+0x13>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804e86:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804e8b:	5d                   	pop    %ebp
  804e8c:	c3                   	ret    

00804e8d <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804e8d:	f3 0f 1e fb          	endbr32 
  804e91:	55                   	push   %ebp
  804e92:	89 e5                	mov    %esp,%ebp
  804e94:	53                   	push   %ebx
  804e95:	83 ec 04             	sub    $0x4,%esp
  804e98:	8b 45 08             	mov    0x8(%ebp),%eax
  804e9b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804e9e:	85 c0                	test   %eax,%eax
  804ea0:	74 04                	je     804ea6 <pbuf_cat+0x19>
  804ea2:	85 db                	test   %ebx,%ebx
  804ea4:	75 21                	jne    804ec7 <pbuf_cat+0x3a>
  804ea6:	83 ec 04             	sub    $0x4,%esp
  804ea9:	68 4c 1e 81 00       	push   $0x811e4c
  804eae:	68 41 02 00 00       	push   $0x241
  804eb3:	68 64 1c 81 00       	push   $0x811c64
  804eb8:	e8 7a 9a 00 00       	call   80e937 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804ebd:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804ec1:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804ec5:	89 d0                	mov    %edx,%eax
  804ec7:	8b 10                	mov    (%eax),%edx
  804ec9:	85 d2                	test   %edx,%edx
  804ecb:	75 f0                	jne    804ebd <pbuf_cat+0x30>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804ecd:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804ed1:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804ed5:	75 0f                	jne    804ee6 <pbuf_cat+0x59>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804ed7:	66 03 53 08          	add    0x8(%ebx),%dx
  804edb:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804edf:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804ee1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804ee4:	c9                   	leave  
  804ee5:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804ee6:	83 ec 04             	sub    $0x4,%esp
  804ee9:	68 84 1e 81 00       	push   $0x811e84
  804eee:	68 4a 02 00 00       	push   $0x24a
  804ef3:	68 64 1c 81 00       	push   $0x811c64
  804ef8:	e8 3a 9a 00 00       	call   80e937 <_panic>

00804efd <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804efd:	f3 0f 1e fb          	endbr32 
  804f01:	55                   	push   %ebp
  804f02:	89 e5                	mov    %esp,%ebp
  804f04:	53                   	push   %ebx
  804f05:	83 ec 0c             	sub    $0xc,%esp
  804f08:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804f0b:	53                   	push   %ebx
  804f0c:	ff 75 08             	pushl  0x8(%ebp)
  804f0f:	e8 79 ff ff ff       	call   804e8d <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804f14:	89 1c 24             	mov    %ebx,(%esp)
  804f17:	e8 5c ff ff ff       	call   804e78 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804f1c:	83 c4 10             	add    $0x10,%esp
  804f1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804f22:	c9                   	leave  
  804f23:	c3                   	ret    

00804f24 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804f24:	f3 0f 1e fb          	endbr32 
  804f28:	55                   	push   %ebp
  804f29:	89 e5                	mov    %esp,%ebp
  804f2b:	57                   	push   %edi
  804f2c:	56                   	push   %esi
  804f2d:	53                   	push   %ebx
  804f2e:	83 ec 1c             	sub    $0x1c,%esp
  804f31:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804f34:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804f36:	85 f6                	test   %esi,%esi
  804f38:	74 71                	je     804fab <pbuf_dechain+0x87>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804f3a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804f3e:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804f42:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804f46:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804f49:	0f b7 d0             	movzwl %ax,%edx
  804f4c:	0f b7 f9             	movzwl %cx,%edi
  804f4f:	29 fa                	sub    %edi,%edx
  804f51:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804f54:	75 3e                	jne    804f94 <pbuf_dechain+0x70>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804f56:	29 c8                	sub    %ecx,%eax
  804f58:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804f5c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804f62:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804f66:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804f6a:	83 ec 0c             	sub    $0xc,%esp
  804f6d:	56                   	push   %esi
  804f6e:	e8 a8 fa ff ff       	call   804a1b <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804f73:	83 c4 10             	add    $0x10,%esp
  804f76:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804f7a:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804f7e:	75 35                	jne    804fb5 <pbuf_dechain+0x91>
  return ((tail_gone > 0) ? NULL : q);
  804f80:	84 c0                	test   %al,%al
  804f82:	b8 00 00 00 00       	mov    $0x0,%eax
  804f87:	0f 45 f0             	cmovne %eax,%esi
}
  804f8a:	89 f0                	mov    %esi,%eax
  804f8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f8f:	5b                   	pop    %ebx
  804f90:	5e                   	pop    %esi
  804f91:	5f                   	pop    %edi
  804f92:	5d                   	pop    %ebp
  804f93:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804f94:	83 ec 04             	sub    $0x4,%esp
  804f97:	68 b4 1e 81 00       	push   $0x811eb4
  804f9c:	68 80 02 00 00       	push   $0x280
  804fa1:	68 64 1c 81 00       	push   $0x811c64
  804fa6:	e8 8c 99 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804fab:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804faf:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804fb3:	74 d5                	je     804f8a <pbuf_dechain+0x66>
  804fb5:	83 ec 04             	sub    $0x4,%esp
  804fb8:	68 91 1d 81 00       	push   $0x811d91
  804fbd:	68 91 02 00 00       	push   $0x291
  804fc2:	68 64 1c 81 00       	push   $0x811c64
  804fc7:	e8 6b 99 00 00       	call   80e937 <_panic>

00804fcc <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804fcc:	f3 0f 1e fb          	endbr32 
  804fd0:	55                   	push   %ebp
  804fd1:	89 e5                	mov    %esp,%ebp
  804fd3:	57                   	push   %edi
  804fd4:	56                   	push   %esi
  804fd5:	53                   	push   %ebx
  804fd6:	83 ec 1c             	sub    $0x1c,%esp
  804fd9:	8b 7d 08             	mov    0x8(%ebp),%edi
  804fdc:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804fdf:	85 ff                	test   %edi,%edi
  804fe1:	74 22                	je     805005 <pbuf_copy+0x39>
  804fe3:	85 db                	test   %ebx,%ebx
  804fe5:	74 1e                	je     805005 <pbuf_copy+0x39>
  804fe7:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804feb:	66 39 47 08          	cmp    %ax,0x8(%edi)
  804fef:	72 14                	jb     805005 <pbuf_copy+0x39>
  u16_t offset_to=0, offset_from=0, len;
  804ff1:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804ff7:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804ffd:	89 7d 08             	mov    %edi,0x8(%ebp)
  805000:	e9 92 00 00 00       	jmp    805097 <pbuf_copy+0xcb>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  805005:	83 ec 04             	sub    $0x4,%esp
  805008:	68 d8 1e 81 00       	push   $0x811ed8
  80500d:	68 b0 02 00 00       	push   $0x2b0
  805012:	68 64 1c 81 00       	push   $0x811c64
  805017:	e8 1b 99 00 00       	call   80e937 <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  80501c:	83 ec 04             	sub    $0x4,%esp
  80501f:	68 a6 1d 81 00       	push   $0x811da6
  805024:	68 c2 02 00 00       	push   $0x2c2
  805029:	68 64 1c 81 00       	push   $0x811c64
  80502e:	e8 04 99 00 00       	call   80e937 <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  805033:	8b 45 08             	mov    0x8(%ebp),%eax
  805036:	8b 00                	mov    (%eax),%eax
  805038:	89 45 08             	mov    %eax,0x8(%ebp)
      offset_to = 0;
  80503b:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  805041:	e9 c7 00 00 00       	jmp    80510d <pbuf_copy+0x141>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  805046:	83 ec 04             	sub    $0x4,%esp
  805049:	68 bd 1d 81 00       	push   $0x811dbd
  80504e:	68 c8 02 00 00       	push   $0x2c8
  805053:	68 64 1c 81 00       	push   $0x811c64
  805058:	e8 da 98 00 00       	call   80e937 <_panic>
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  80505d:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  805063:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805067:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  80506b:	0f 84 cf 00 00 00    	je     805140 <pbuf_copy+0x174>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  805071:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  805075:	0f 84 05 01 00 00    	je     805180 <pbuf_copy+0x1b4>
  80507b:	8b 45 08             	mov    0x8(%ebp),%eax
  80507e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  805082:	8b 4d 08             	mov    0x8(%ebp),%ecx
  805085:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  805089:	0f 84 d1 00 00 00    	je     805160 <pbuf_copy+0x194>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80508f:	85 db                	test   %ebx,%ebx
  805091:	0f 84 00 01 00 00    	je     805197 <pbuf_copy+0x1cb>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  805097:	8b 45 08             	mov    0x8(%ebp),%eax
  80509a:	0f b7 70 0a          	movzwl 0xa(%eax),%esi
  80509e:	0f b7 ce             	movzwl %si,%ecx
  8050a1:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8050a5:	29 c1                	sub    %eax,%ecx
  8050a7:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  8050ab:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8050af:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  8050b1:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8050b5:	66 2b 7d e6          	sub    -0x1a(%ebp),%di
  8050b9:	89 f8                	mov    %edi,%eax
  8050bb:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  8050bf:	29 fe                	sub    %edi,%esi
  8050c1:	39 d1                	cmp    %edx,%ecx
  8050c3:	0f 4d f0             	cmovge %eax,%esi
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  8050c6:	83 ec 04             	sub    $0x4,%esp
  8050c9:	0f b7 c6             	movzwl %si,%eax
  8050cc:	50                   	push   %eax
  8050cd:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8050d1:	03 43 04             	add    0x4(%ebx),%eax
  8050d4:	50                   	push   %eax
  8050d5:	0f b7 c7             	movzwl %di,%eax
  8050d8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8050db:	03 41 04             	add    0x4(%ecx),%eax
  8050de:	50                   	push   %eax
  8050df:	e8 a8 a1 00 00       	call   80f28c <memcpy>
    offset_to += len;
  8050e4:	89 fa                	mov    %edi,%edx
  8050e6:	01 f2                	add    %esi,%edx
  8050e8:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    offset_from += len;
  8050ec:	66 01 75 e6          	add    %si,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  8050f0:	8b 45 08             	mov    0x8(%ebp),%eax
  8050f3:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  8050f7:	83 c4 10             	add    $0x10,%esp
  8050fa:	66 39 d0             	cmp    %dx,%ax
  8050fd:	0f 82 19 ff ff ff    	jb     80501c <pbuf_copy+0x50>
    if (offset_to == p_to->len) {
  805103:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
  805107:	0f 84 26 ff ff ff    	je     805033 <pbuf_copy+0x67>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80510d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  805111:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  805115:	0f 82 2b ff ff ff    	jb     805046 <pbuf_copy+0x7a>
    if (offset_from >= p_from->len) {
  80511b:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  80511f:	0f 85 3e ff ff ff    	jne    805063 <pbuf_copy+0x97>
      p_from = p_from->next;
  805125:	8b 1b                	mov    (%ebx),%ebx
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  805127:	85 db                	test   %ebx,%ebx
  805129:	0f 85 2e ff ff ff    	jne    80505d <pbuf_copy+0x91>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80512f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  805133:	74 62                	je     805197 <pbuf_copy+0x1cb>
      offset_from = 0;
  805135:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  80513b:	e9 3b ff ff ff       	jmp    80507b <pbuf_copy+0xaf>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  805140:	83 3b 00             	cmpl   $0x0,(%ebx)
  805143:	0f 84 28 ff ff ff    	je     805071 <pbuf_copy+0xa5>
  805149:	83 ec 04             	sub    $0x4,%esp
  80514c:	68 08 1f 81 00       	push   $0x811f08
  805151:	68 d1 02 00 00       	push   $0x2d1
  805156:	68 64 1c 81 00       	push   $0x811c64
  80515b:	e8 d7 97 00 00       	call   80e937 <_panic>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  805160:	83 39 00             	cmpl   $0x0,(%ecx)
  805163:	0f 84 26 ff ff ff    	je     80508f <pbuf_copy+0xc3>
  805169:	83 ec 04             	sub    $0x4,%esp
  80516c:	68 08 1f 81 00       	push   $0x811f08
  805171:	68 d6 02 00 00       	push   $0x2d6
  805176:	68 64 1c 81 00       	push   $0x811c64
  80517b:	e8 b7 97 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  805180:	83 ec 04             	sub    $0x4,%esp
  805183:	68 d8 1d 81 00       	push   $0x811dd8
  805188:	68 b6 02 00 00       	push   $0x2b6
  80518d:	68 64 1c 81 00       	push   $0x811c64
  805192:	e8 a0 97 00 00       	call   80e937 <_panic>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  805197:	b8 00 00 00 00       	mov    $0x0,%eax
  80519c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80519f:	5b                   	pop    %ebx
  8051a0:	5e                   	pop    %esi
  8051a1:	5f                   	pop    %edi
  8051a2:	5d                   	pop    %ebp
  8051a3:	c3                   	ret    

008051a4 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  8051a4:	f3 0f 1e fb          	endbr32 
  8051a8:	55                   	push   %ebp
  8051a9:	89 e5                	mov    %esp,%ebp
  8051ab:	57                   	push   %edi
  8051ac:	56                   	push   %esi
  8051ad:	53                   	push   %ebx
  8051ae:	83 ec 1c             	sub    $0x1c,%esp
  8051b1:	8b 75 08             	mov    0x8(%ebp),%esi
  8051b4:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  8051b8:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8051bc:	85 f6                	test   %esi,%esi
  8051be:	74 14                	je     8051d4 <pbuf_copy_partial+0x30>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8051c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8051c4:	74 25                	je     8051eb <pbuf_copy_partial+0x47>
  u16_t copied_total = 0;
  8051c6:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)

  left = 0;
  8051cc:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  8051d2:	eb 69                	jmp    80523d <pbuf_copy_partial+0x99>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8051d4:	83 ec 04             	sub    $0x4,%esp
  8051d7:	68 34 1f 81 00       	push   $0x811f34
  8051dc:	68 ef 02 00 00       	push   $0x2ef
  8051e1:	68 64 1c 81 00       	push   $0x811c64
  8051e6:	e8 4c 97 00 00       	call   80e937 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8051eb:	83 ec 04             	sub    $0x4,%esp
  8051ee:	68 58 1f 81 00       	push   $0x811f58
  8051f3:	68 f0 02 00 00       	push   $0x2f0
  8051f8:	68 64 1c 81 00       	push   $0x811c64
  8051fd:	e8 35 97 00 00       	call   80e937 <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  805202:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  805206:	29 c3                	sub    %eax,%ebx
  805208:	66 39 df             	cmp    %bx,%di
  80520b:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80520e:	83 ec 04             	sub    $0x4,%esp
  805211:	0f b7 d3             	movzwl %bx,%edx
  805214:	52                   	push   %edx
  805215:	0f b7 c0             	movzwl %ax,%eax
  805218:	03 46 04             	add    0x4(%esi),%eax
  80521b:	50                   	push   %eax
  80521c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805220:	03 45 0c             	add    0xc(%ebp),%eax
  805223:	50                   	push   %eax
  805224:	e8 63 a0 00 00       	call   80f28c <memcpy>
      copied_total += buf_copy_len;
  805229:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  80522d:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  805231:	29 df                	sub    %ebx,%edi
  805233:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  805236:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80523b:	8b 36                	mov    (%esi),%esi
  80523d:	66 85 ff             	test   %di,%di
  805240:	74 16                	je     805258 <pbuf_copy_partial+0xb4>
  805242:	85 f6                	test   %esi,%esi
  805244:	74 12                	je     805258 <pbuf_copy_partial+0xb4>
    if ((offset != 0) && (offset >= p->len)) {
  805246:	66 85 c0             	test   %ax,%ax
  805249:	74 b7                	je     805202 <pbuf_copy_partial+0x5e>
  80524b:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80524f:	66 39 c2             	cmp    %ax,%dx
  805252:	77 ae                	ja     805202 <pbuf_copy_partial+0x5e>
      offset -= p->len;
  805254:	29 d0                	sub    %edx,%eax
  805256:	eb e3                	jmp    80523b <pbuf_copy_partial+0x97>
    }
  }
  return copied_total;
}
  805258:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80525c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80525f:	5b                   	pop    %ebx
  805260:	5e                   	pop    %esi
  805261:	5f                   	pop    %edi
  805262:	5d                   	pop    %ebp
  805263:	c3                   	ret    

00805264 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805264:	f3 0f 1e fb          	endbr32 
  805268:	55                   	push   %ebp
  805269:	89 e5                	mov    %esp,%ebp
  80526b:	83 ec 14             	sub    $0x14,%esp
  80526e:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  805271:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  805276:	8b 40 04             	mov    0x4(%eax),%eax
  805279:	ff 30                	pushl  (%eax)
  80527b:	e8 ed 50 00 00       	call   80a36d <sys_sem_signal>
}
  805280:	83 c4 10             	add    $0x10,%esp
  805283:	c9                   	leave  
  805284:	c3                   	ret    

00805285 <sys_mbox_fetch>:
{
  805285:	f3 0f 1e fb          	endbr32 
  805289:	55                   	push   %ebp
  80528a:	89 e5                	mov    %esp,%ebp
  80528c:	57                   	push   %edi
  80528d:	56                   	push   %esi
  80528e:	53                   	push   %ebx
  80528f:	83 ec 0c             	sub    $0xc,%esp
  805292:	8b 7d 0c             	mov    0xc(%ebp),%edi
  805295:	eb 44                	jmp    8052db <sys_mbox_fetch+0x56>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  805297:	83 ec 04             	sub    $0x4,%esp
  80529a:	6a 00                	push   $0x0
  80529c:	57                   	push   %edi
  80529d:	ff 75 08             	pushl  0x8(%ebp)
  8052a0:	e8 4d 53 00 00       	call   80a5f2 <sys_arch_mbox_fetch>
  8052a5:	83 c4 10             	add    $0x10,%esp
}
  8052a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8052ab:	5b                   	pop    %ebx
  8052ac:	5e                   	pop    %esi
  8052ad:	5f                   	pop    %edi
  8052ae:	5d                   	pop    %ebp
  8052af:	c3                   	ret    
      tmptimeout = timeouts->next;
  8052b0:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8052b2:	8b 10                	mov    (%eax),%edx
  8052b4:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8052b6:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8052b9:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8052bc:	83 ec 08             	sub    $0x8,%esp
  8052bf:	50                   	push   %eax
  8052c0:	6a 0b                	push   $0xb
  8052c2:	e8 d1 f3 ff ff       	call   804698 <memp_free>
      if (h != NULL) {
  8052c7:	83 c4 10             	add    $0x10,%esp
  8052ca:	85 db                	test   %ebx,%ebx
  8052cc:	74 0d                	je     8052db <sys_mbox_fetch+0x56>
        h(arg);
  8052ce:	83 ec 0c             	sub    $0xc,%esp
  8052d1:	56                   	push   %esi
  8052d2:	ff d3                	call   *%ebx
  8052d4:	83 c4 10             	add    $0x10,%esp
  8052d7:	f3 0f 1e fb          	endbr32 
  timeouts = sys_arch_timeouts();
  8052db:	e8 b3 54 00 00       	call   80a793 <sys_arch_timeouts>
  8052e0:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  8052e2:	85 c0                	test   %eax,%eax
  8052e4:	74 b1                	je     805297 <sys_mbox_fetch+0x12>
  8052e6:	8b 00                	mov    (%eax),%eax
  8052e8:	85 c0                	test   %eax,%eax
  8052ea:	74 ab                	je     805297 <sys_mbox_fetch+0x12>
    if (timeouts->next->time > 0) {
  8052ec:	8b 40 04             	mov    0x4(%eax),%eax
  8052ef:	85 c0                	test   %eax,%eax
  8052f1:	74 bd                	je     8052b0 <sys_mbox_fetch+0x2b>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8052f3:	83 ec 04             	sub    $0x4,%esp
  8052f6:	50                   	push   %eax
  8052f7:	57                   	push   %edi
  8052f8:	ff 75 08             	pushl  0x8(%ebp)
  8052fb:	e8 f2 52 00 00       	call   80a5f2 <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  805300:	83 c4 10             	add    $0x10,%esp
  805303:	83 f8 ff             	cmp    $0xffffffff,%eax
  805306:	74 a8                	je     8052b0 <sys_mbox_fetch+0x2b>
      if (time_needed < timeouts->next->time) {
  805308:	8b 0b                	mov    (%ebx),%ecx
  80530a:	8b 59 04             	mov    0x4(%ecx),%ebx
        timeouts->next->time -= time_needed;
  80530d:	89 da                	mov    %ebx,%edx
  80530f:	29 c2                	sub    %eax,%edx
  805311:	39 c3                	cmp    %eax,%ebx
  805313:	b8 00 00 00 00       	mov    $0x0,%eax
  805318:	0f 47 c2             	cmova  %edx,%eax
  80531b:	89 41 04             	mov    %eax,0x4(%ecx)
  80531e:	eb 88                	jmp    8052a8 <sys_mbox_fetch+0x23>

00805320 <sys_sem_wait>:
{
  805320:	f3 0f 1e fb          	endbr32 
  805324:	55                   	push   %ebp
  805325:	89 e5                	mov    %esp,%ebp
  805327:	57                   	push   %edi
  805328:	56                   	push   %esi
  805329:	53                   	push   %ebx
  80532a:	83 ec 0c             	sub    $0xc,%esp
  80532d:	8b 75 08             	mov    0x8(%ebp),%esi
  805330:	eb 41                	jmp    805373 <sys_sem_wait+0x53>
    sys_arch_sem_wait(sem, 0);
  805332:	83 ec 08             	sub    $0x8,%esp
  805335:	6a 00                	push   $0x0
  805337:	56                   	push   %esi
  805338:	e8 a4 50 00 00       	call   80a3e1 <sys_arch_sem_wait>
  80533d:	83 c4 10             	add    $0x10,%esp
}
  805340:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805343:	5b                   	pop    %ebx
  805344:	5e                   	pop    %esi
  805345:	5f                   	pop    %edi
  805346:	5d                   	pop    %ebp
  805347:	c3                   	ret    
      tmptimeout = timeouts->next;
  805348:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80534a:	8b 10                	mov    (%eax),%edx
  80534c:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  80534e:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805351:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805354:	83 ec 08             	sub    $0x8,%esp
  805357:	50                   	push   %eax
  805358:	6a 0b                	push   $0xb
  80535a:	e8 39 f3 ff ff       	call   804698 <memp_free>
      if (h != NULL) {
  80535f:	83 c4 10             	add    $0x10,%esp
  805362:	85 db                	test   %ebx,%ebx
  805364:	74 0d                	je     805373 <sys_sem_wait+0x53>
        h(arg);
  805366:	83 ec 0c             	sub    $0xc,%esp
  805369:	57                   	push   %edi
  80536a:	ff d3                	call   *%ebx
  80536c:	83 c4 10             	add    $0x10,%esp
  80536f:	f3 0f 1e fb          	endbr32 
  timeouts = sys_arch_timeouts();
  805373:	e8 1b 54 00 00       	call   80a793 <sys_arch_timeouts>
  805378:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  80537a:	85 c0                	test   %eax,%eax
  80537c:	74 b4                	je     805332 <sys_sem_wait+0x12>
  80537e:	8b 00                	mov    (%eax),%eax
  805380:	85 c0                	test   %eax,%eax
  805382:	74 ae                	je     805332 <sys_sem_wait+0x12>
    if (timeouts->next->time > 0) {
  805384:	8b 40 04             	mov    0x4(%eax),%eax
  805387:	85 c0                	test   %eax,%eax
  805389:	74 bd                	je     805348 <sys_sem_wait+0x28>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80538b:	83 ec 08             	sub    $0x8,%esp
  80538e:	50                   	push   %eax
  80538f:	56                   	push   %esi
  805390:	e8 4c 50 00 00       	call   80a3e1 <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  805395:	83 c4 10             	add    $0x10,%esp
  805398:	83 f8 ff             	cmp    $0xffffffff,%eax
  80539b:	74 ab                	je     805348 <sys_sem_wait+0x28>
      if (time_needed < timeouts->next->time) {
  80539d:	8b 0b                	mov    (%ebx),%ecx
  80539f:	8b 59 04             	mov    0x4(%ecx),%ebx
        timeouts->next->time -= time_needed;
  8053a2:	89 da                	mov    %ebx,%edx
  8053a4:	29 c2                	sub    %eax,%edx
  8053a6:	39 c3                	cmp    %eax,%ebx
  8053a8:	b8 00 00 00 00       	mov    $0x0,%eax
  8053ad:	0f 47 c2             	cmova  %edx,%eax
  8053b0:	89 41 04             	mov    %eax,0x4(%ecx)
  8053b3:	eb 8b                	jmp    805340 <sys_sem_wait+0x20>

008053b5 <sys_timeout>:
{
  8053b5:	f3 0f 1e fb          	endbr32 
  8053b9:	55                   	push   %ebp
  8053ba:	89 e5                	mov    %esp,%ebp
  8053bc:	57                   	push   %edi
  8053bd:	56                   	push   %esi
  8053be:	53                   	push   %ebx
  8053bf:	83 ec 28             	sub    $0x28,%esp
  8053c2:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8053c5:	6a 0b                	push   $0xb
  8053c7:	e8 72 f2 ff ff       	call   80463e <memp_malloc>
  if (timeout == NULL) {
  8053cc:	83 c4 10             	add    $0x10,%esp
  8053cf:	85 c0                	test   %eax,%eax
  8053d1:	74 40                	je     805413 <sys_timeout+0x5e>
  8053d3:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  8053d5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8053db:	8b 45 0c             	mov    0xc(%ebp),%eax
  8053de:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8053e1:	8b 45 10             	mov    0x10(%ebp),%eax
  8053e4:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8053e7:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  8053ea:	e8 a4 53 00 00       	call   80a793 <sys_arch_timeouts>
  if (timeouts == NULL) {
  8053ef:	85 c0                	test   %eax,%eax
  8053f1:	74 37                	je     80542a <sys_timeout+0x75>
  if (timeouts->next == NULL) {
  8053f3:	8b 10                	mov    (%eax),%edx
  8053f5:	85 d2                	test   %edx,%edx
  8053f7:	74 48                	je     805441 <sys_timeout+0x8c>
  if (timeouts->next->time > msecs) {
  8053f9:	8b 4a 04             	mov    0x4(%edx),%ecx
  8053fc:	39 f1                	cmp    %esi,%ecx
  8053fe:	76 45                	jbe    805445 <sys_timeout+0x90>
    timeouts->next->time -= msecs;
  805400:	29 f1                	sub    %esi,%ecx
  805402:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  805405:	8b 10                	mov    (%eax),%edx
  805407:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  805409:	89 18                	mov    %ebx,(%eax)
}
  80540b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80540e:	5b                   	pop    %ebx
  80540f:	5e                   	pop    %esi
  805410:	5f                   	pop    %edi
  805411:	5d                   	pop    %ebp
  805412:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  805413:	83 ec 04             	sub    $0x4,%esp
  805416:	68 7d 1f 81 00       	push   $0x811f7d
  80541b:	68 c3 00 00 00       	push   $0xc3
  805420:	68 9a 1f 81 00       	push   $0x811f9a
  805425:	e8 0d 95 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80542a:	83 ec 04             	sub    $0x4,%esp
  80542d:	68 ae 1f 81 00       	push   $0x811fae
  805432:	68 d1 00 00 00       	push   $0xd1
  805437:	68 9a 1f 81 00       	push   $0x811f9a
  80543c:	e8 f6 94 00 00       	call   80e937 <_panic>
    timeouts->next = timeout;
  805441:	89 18                	mov    %ebx,(%eax)
    return;
  805443:	eb c6                	jmp    80540b <sys_timeout+0x56>
      timeout->time -= t->time;
  805445:	8b 7b 04             	mov    0x4(%ebx),%edi
  805448:	8b 72 04             	mov    0x4(%edx),%esi
  80544b:	89 f8                	mov    %edi,%eax
  80544d:	29 f0                	sub    %esi,%eax
  80544f:	89 43 04             	mov    %eax,0x4(%ebx)
  805452:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      if (t->next == NULL || t->next->time > timeout->time) {
  805455:	8b 12                	mov    (%edx),%edx
  805457:	85 d2                	test   %edx,%edx
  805459:	74 0e                	je     805469 <sys_timeout+0xb4>
  80545b:	8b 4a 04             	mov    0x4(%edx),%ecx
  80545e:	39 c8                	cmp    %ecx,%eax
  805460:	73 e3                	jae    805445 <sys_timeout+0x90>
          t->next->time -= timeout->time;
  805462:	29 f9                	sub    %edi,%ecx
  805464:	01 ce                	add    %ecx,%esi
  805466:	89 72 04             	mov    %esi,0x4(%edx)
        timeout->next = t->next;
  805469:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80546c:	8b 07                	mov    (%edi),%eax
  80546e:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  805470:	89 1f                	mov    %ebx,(%edi)
        break;
  805472:	eb 97                	jmp    80540b <sys_timeout+0x56>

00805474 <sys_untimeout>:
{
  805474:	f3 0f 1e fb          	endbr32 
  805478:	55                   	push   %ebp
  805479:	89 e5                	mov    %esp,%ebp
  80547b:	57                   	push   %edi
  80547c:	56                   	push   %esi
  80547d:	53                   	push   %ebx
  80547e:	83 ec 0c             	sub    $0xc,%esp
  805481:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805484:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  805487:	e8 07 53 00 00       	call   80a793 <sys_arch_timeouts>
  if (timeouts == NULL) {
  80548c:	85 c0                	test   %eax,%eax
  80548e:	74 0f                	je     80549f <sys_untimeout+0x2b>
  805490:	89 c7                	mov    %eax,%edi
  if (timeouts->next == NULL) {
  805492:	8b 10                	mov    (%eax),%edx
  805494:	85 d2                	test   %edx,%edx
  805496:	74 5a                	je     8054f2 <sys_untimeout+0x7e>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805498:	b8 00 00 00 00       	mov    $0x0,%eax
  80549d:	eb 27                	jmp    8054c6 <sys_untimeout+0x52>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80549f:	83 ec 04             	sub    $0x4,%esp
  8054a2:	68 cc 1f 81 00       	push   $0x811fcc
  8054a7:	68 00 01 00 00       	push   $0x100
  8054ac:	68 9a 1f 81 00       	push   $0x811f9a
  8054b1:	e8 81 94 00 00       	call   80e937 <_panic>
        timeouts->next = t->next;
  8054b6:	8b 02                	mov    (%edx),%eax
  8054b8:	89 07                	mov    %eax,(%edi)
  8054ba:	eb 1c                	jmp    8054d8 <sys_untimeout+0x64>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8054bc:	8b 0a                	mov    (%edx),%ecx
  8054be:	89 d0                	mov    %edx,%eax
  8054c0:	85 c9                	test   %ecx,%ecx
  8054c2:	74 2e                	je     8054f2 <sys_untimeout+0x7e>
  8054c4:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  8054c6:	39 5a 08             	cmp    %ebx,0x8(%edx)
  8054c9:	75 f1                	jne    8054bc <sys_untimeout+0x48>
  8054cb:	39 72 0c             	cmp    %esi,0xc(%edx)
  8054ce:	75 ec                	jne    8054bc <sys_untimeout+0x48>
      if (prev_t == NULL)
  8054d0:	85 c0                	test   %eax,%eax
  8054d2:	74 e2                	je     8054b6 <sys_untimeout+0x42>
        prev_t->next = t->next;
  8054d4:	8b 0a                	mov    (%edx),%ecx
  8054d6:	89 08                	mov    %ecx,(%eax)
      if (t->next != NULL)
  8054d8:	8b 02                	mov    (%edx),%eax
  8054da:	85 c0                	test   %eax,%eax
  8054dc:	74 06                	je     8054e4 <sys_untimeout+0x70>
        t->next->time += t->time;
  8054de:	8b 4a 04             	mov    0x4(%edx),%ecx
  8054e1:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8054e4:	83 ec 08             	sub    $0x8,%esp
  8054e7:	52                   	push   %edx
  8054e8:	6a 0b                	push   $0xb
  8054ea:	e8 a9 f1 ff ff       	call   804698 <memp_free>
      return;
  8054ef:	83 c4 10             	add    $0x10,%esp
}
  8054f2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8054f5:	5b                   	pop    %ebx
  8054f6:	5e                   	pop    %esi
  8054f7:	5f                   	pop    %edi
  8054f8:	5d                   	pop    %ebp
  8054f9:	c3                   	ret    

008054fa <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8054fa:	f3 0f 1e fb          	endbr32 
  8054fe:	55                   	push   %ebp
  8054ff:	89 e5                	mov    %esp,%ebp
  805501:	83 ec 18             	sub    $0x18,%esp
  805504:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  805507:	8d 4d 08             	lea    0x8(%ebp),%ecx
  80550a:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  80550d:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  805513:	85 c0                	test   %eax,%eax
  805515:	75 1c                	jne    805533 <sys_sem_wait_timeout+0x39>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  805517:	83 ec 0c             	sub    $0xc,%esp
  80551a:	ff 75 08             	pushl  0x8(%ebp)
  80551d:	e8 fe fd ff ff       	call   805320 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  805522:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  805525:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  80552a:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80552f:	74 19                	je     80554a <sys_sem_wait_timeout+0x50>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  805531:	c9                   	leave  
  805532:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  805533:	83 ec 04             	sub    $0x4,%esp
  805536:	8d 55 f0             	lea    -0x10(%ebp),%edx
  805539:	52                   	push   %edx
  80553a:	68 64 52 80 00       	push   $0x805264
  80553f:	50                   	push   %eax
  805540:	e8 70 fe ff ff       	call   8053b5 <sys_timeout>
  805545:	83 c4 10             	add    $0x10,%esp
  805548:	eb cd                	jmp    805517 <sys_sem_wait_timeout+0x1d>
    sys_untimeout(sswt_handler, &sswt_cb);
  80554a:	83 ec 08             	sub    $0x8,%esp
  80554d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  805550:	50                   	push   %eax
  805551:	68 64 52 80 00       	push   $0x805264
  805556:	e8 19 ff ff ff       	call   805474 <sys_untimeout>
    return 1;
  80555b:	83 c4 10             	add    $0x10,%esp
  80555e:	b8 01 00 00 00       	mov    $0x1,%eax
  805563:	eb cc                	jmp    805531 <sys_sem_wait_timeout+0x37>

00805565 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  805565:	f3 0f 1e fb          	endbr32 
  805569:	55                   	push   %ebp
  80556a:	89 e5                	mov    %esp,%ebp
  80556c:	53                   	push   %ebx
  80556d:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805570:	6a 00                	push   $0x0
  805572:	e8 29 4b 00 00       	call   80a0a0 <sys_sem_new>
  805577:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805579:	83 c4 08             	add    $0x8,%esp
  80557c:	ff 75 08             	pushl  0x8(%ebp)
  80557f:	50                   	push   %eax
  805580:	e8 75 ff ff ff       	call   8054fa <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805585:	89 1c 24             	mov    %ebx,(%esp)
  805588:	e8 98 4b 00 00       	call   80a125 <sys_sem_free>
}
  80558d:	83 c4 10             	add    $0x10,%esp
  805590:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805593:	c9                   	leave  
  805594:	c3                   	ret    

00805595 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  805595:	f3 0f 1e fb          	endbr32 
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805599:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80559e:	c3                   	ret    

0080559f <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80559f:	55                   	push   %ebp
  8055a0:	89 e5                	mov    %esp,%ebp
  8055a2:	57                   	push   %edi
  8055a3:	56                   	push   %esi
  8055a4:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8055a5:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8055ab:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8055b1:	8b 3d 44 b2 b3 00    	mov    0xb3b244,%edi
  8055b7:	0f b7 15 0c 40 81 00 	movzwl 0x81400c,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  8055be:	b9 00 10 00 00       	mov    $0x1000,%ecx
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8055c3:	66 83 c2 01          	add    $0x1,%dx
    port = TCP_LOCAL_PORT_RANGE_START;
  8055c7:	0f 48 d1             	cmovs  %ecx,%edx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8055ca:	89 d8                	mov    %ebx,%eax
  8055cc:	85 c0                	test   %eax,%eax
  8055ce:	74 0b                	je     8055db <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  8055d0:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8055d4:	74 ed                	je     8055c3 <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8055d6:	8b 40 0c             	mov    0xc(%eax),%eax
  8055d9:	eb f1                	jmp    8055cc <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8055db:	89 f0                	mov    %esi,%eax
  8055dd:	85 c0                	test   %eax,%eax
  8055df:	74 0b                	je     8055ec <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  8055e1:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8055e5:	74 dc                	je     8055c3 <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8055e7:	8b 40 0c             	mov    0xc(%eax),%eax
  8055ea:	eb f1                	jmp    8055dd <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8055ec:	89 f8                	mov    %edi,%eax
  8055ee:	85 c0                	test   %eax,%eax
  8055f0:	74 0b                	je     8055fd <tcp_new_port+0x5e>
    if (pcb->local_port == port) {
  8055f2:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8055f6:	74 cb                	je     8055c3 <tcp_new_port+0x24>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8055f8:	8b 40 0c             	mov    0xc(%eax),%eax
  8055fb:	eb f1                	jmp    8055ee <tcp_new_port+0x4f>
  8055fd:	66 89 15 0c 40 81 00 	mov    %dx,0x81400c
      goto again;
    }
  }
  return port;
}
  805604:	89 d0                	mov    %edx,%eax
  805606:	5b                   	pop    %ebx
  805607:	5e                   	pop    %esi
  805608:	5f                   	pop    %edi
  805609:	5d                   	pop    %ebp
  80560a:	c3                   	ret    

0080560b <tcp_bind>:
{
  80560b:	f3 0f 1e fb          	endbr32 
  80560f:	55                   	push   %ebp
  805610:	89 e5                	mov    %esp,%ebp
  805612:	57                   	push   %edi
  805613:	56                   	push   %esi
  805614:	53                   	push   %ebx
  805615:	83 ec 0c             	sub    $0xc,%esp
  805618:	8b 75 08             	mov    0x8(%ebp),%esi
  80561b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80561e:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805621:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  805625:	75 0f                	jne    805636 <tcp_bind+0x2b>
  805627:	89 d0                	mov    %edx,%eax
  if (port == 0) {
  805629:	66 85 d2             	test   %dx,%dx
  80562c:	74 1f                	je     80564d <tcp_bind+0x42>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80562e:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  805634:	eb 21                	jmp    805657 <tcp_bind+0x4c>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805636:	83 ec 04             	sub    $0x4,%esp
  805639:	68 ec 1f 81 00       	push   $0x811fec
  80563e:	68 05 01 00 00       	push   $0x105
  805643:	68 ce 21 81 00       	push   $0x8121ce
  805648:	e8 ea 92 00 00       	call   80e937 <_panic>
    port = tcp_new_port();
  80564d:	e8 4d ff ff ff       	call   80559f <tcp_new_port>
  805652:	eb da                	jmp    80562e <tcp_bind+0x23>
      cpcb != NULL; cpcb = cpcb->next) {
  805654:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805657:	85 d2                	test   %edx,%edx
  805659:	74 2c                	je     805687 <tcp_bind+0x7c>
    if (cpcb->local_port == port) {
  80565b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80565f:	75 f3                	jne    805654 <tcp_bind+0x49>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805661:	8b 0a                	mov    (%edx),%ecx
  805663:	85 db                	test   %ebx,%ebx
  805665:	0f 84 d4 00 00 00    	je     80573f <tcp_bind+0x134>
  80566b:	85 c9                	test   %ecx,%ecx
  80566d:	0f 84 cc 00 00 00    	je     80573f <tcp_bind+0x134>
          ip_addr_isany(ipaddr) ||
  805673:	8b 3b                	mov    (%ebx),%edi
  805675:	39 f9                	cmp    %edi,%ecx
  805677:	74 04                	je     80567d <tcp_bind+0x72>
  805679:	85 ff                	test   %edi,%edi
  80567b:	75 d7                	jne    805654 <tcp_bind+0x49>
        return ERR_USE;
  80567d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805682:	e9 bd 00 00 00       	jmp    805744 <tcp_bind+0x139>
  for(cpcb = tcp_active_pcbs;
  805687:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  80568d:	eb 03                	jmp    805692 <tcp_bind+0x87>
      cpcb != NULL; cpcb = cpcb->next) {
  80568f:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = tcp_active_pcbs;
  805692:	85 d2                	test   %edx,%edx
  805694:	74 2c                	je     8056c2 <tcp_bind+0xb7>
    if (cpcb->local_port == port) {
  805696:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80569a:	75 f3                	jne    80568f <tcp_bind+0x84>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80569c:	8b 0a                	mov    (%edx),%ecx
  80569e:	85 db                	test   %ebx,%ebx
  8056a0:	0f 84 a6 00 00 00    	je     80574c <tcp_bind+0x141>
  8056a6:	85 c9                	test   %ecx,%ecx
  8056a8:	0f 84 9e 00 00 00    	je     80574c <tcp_bind+0x141>
          ip_addr_isany(ipaddr) ||
  8056ae:	8b 3b                	mov    (%ebx),%edi
  8056b0:	39 f9                	cmp    %edi,%ecx
  8056b2:	74 04                	je     8056b8 <tcp_bind+0xad>
  8056b4:	85 ff                	test   %edi,%edi
  8056b6:	75 d7                	jne    80568f <tcp_bind+0x84>
        return ERR_USE;
  8056b8:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8056bd:	e9 82 00 00 00       	jmp    805744 <tcp_bind+0x139>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8056c2:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8056c8:	eb 03                	jmp    8056cd <tcp_bind+0xc2>
  8056ca:	8b 52 0c             	mov    0xc(%edx),%edx
  8056cd:	85 d2                	test   %edx,%edx
  8056cf:	74 21                	je     8056f2 <tcp_bind+0xe7>
    if (cpcb->local_port == port) {
  8056d1:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8056d5:	75 f3                	jne    8056ca <tcp_bind+0xbf>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8056d7:	8b 0a                	mov    (%edx),%ecx
  8056d9:	85 db                	test   %ebx,%ebx
  8056db:	74 76                	je     805753 <tcp_bind+0x148>
  8056dd:	85 c9                	test   %ecx,%ecx
  8056df:	74 72                	je     805753 <tcp_bind+0x148>
          ip_addr_isany(ipaddr) ||
  8056e1:	8b 3b                	mov    (%ebx),%edi
  8056e3:	39 f9                	cmp    %edi,%ecx
  8056e5:	74 04                	je     8056eb <tcp_bind+0xe0>
  8056e7:	85 ff                	test   %edi,%edi
  8056e9:	75 df                	jne    8056ca <tcp_bind+0xbf>
        return ERR_USE;
  8056eb:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8056f0:	eb 52                	jmp    805744 <tcp_bind+0x139>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8056f2:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  8056f8:	eb 03                	jmp    8056fd <tcp_bind+0xf2>
  8056fa:	8b 52 0c             	mov    0xc(%edx),%edx
  8056fd:	85 d2                	test   %edx,%edx
  8056ff:	74 13                	je     805714 <tcp_bind+0x109>
    if (cpcb->local_port == port) {
  805701:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805705:	75 f3                	jne    8056fa <tcp_bind+0xef>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805707:	8b 3b                	mov    (%ebx),%edi
  805709:	39 3a                	cmp    %edi,(%edx)
  80570b:	75 ed                	jne    8056fa <tcp_bind+0xef>
        return ERR_USE;
  80570d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805712:	eb 30                	jmp    805744 <tcp_bind+0x139>
  if (!ip_addr_isany(ipaddr)) {
  805714:	85 db                	test   %ebx,%ebx
  805716:	74 09                	je     805721 <tcp_bind+0x116>
  805718:	83 3b 00             	cmpl   $0x0,(%ebx)
  80571b:	74 04                	je     805721 <tcp_bind+0x116>
    pcb->local_ip = *ipaddr;
  80571d:	8b 13                	mov    (%ebx),%edx
  80571f:	89 16                	mov    %edx,(%esi)
  pcb->local_port = port;
  805721:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805725:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  80572a:	89 46 0c             	mov    %eax,0xc(%esi)
  80572d:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  805733:	e8 0e cc ff ff       	call   802346 <tcp_timer_needed>
  return ERR_OK;
  805738:	b8 00 00 00 00       	mov    $0x0,%eax
  80573d:	eb 05                	jmp    805744 <tcp_bind+0x139>
        return ERR_USE;
  80573f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  805744:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805747:	5b                   	pop    %ebx
  805748:	5e                   	pop    %esi
  805749:	5f                   	pop    %edi
  80574a:	5d                   	pop    %ebp
  80574b:	c3                   	ret    
        return ERR_USE;
  80574c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805751:	eb f1                	jmp    805744 <tcp_bind+0x139>
        return ERR_USE;
  805753:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805758:	eb ea                	jmp    805744 <tcp_bind+0x139>

0080575a <tcp_listen_with_backlog>:
{
  80575a:	f3 0f 1e fb          	endbr32 
  80575e:	55                   	push   %ebp
  80575f:	89 e5                	mov    %esp,%ebp
  805761:	57                   	push   %edi
  805762:	56                   	push   %esi
  805763:	53                   	push   %ebx
  805764:	83 ec 0c             	sub    $0xc,%esp
  805767:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80576a:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80576e:	75 65                	jne    8057d5 <tcp_listen_with_backlog+0x7b>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805770:	83 ec 0c             	sub    $0xc,%esp
  805773:	6a 03                	push   $0x3
  805775:	e8 c4 ee ff ff       	call   80463e <memp_malloc>
  80577a:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  80577c:	83 c4 10             	add    $0x10,%esp
  80577f:	85 c0                	test   %eax,%eax
  805781:	0f 84 9c 00 00 00    	je     805823 <tcp_listen_with_backlog+0xc9>
  lpcb->callback_arg = pcb->callback_arg;
  805787:	8b 43 18             	mov    0x18(%ebx),%eax
  80578a:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  80578d:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805791:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805795:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  80579c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8057a0:	83 c8 02             	or     $0x2,%eax
  8057a3:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  8057a7:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8057ab:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  8057ae:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8057b2:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  8057b5:	8b 03                	mov    (%ebx),%eax
  8057b7:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8057b9:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8057bf:	39 da                	cmp    %ebx,%edx
  8057c1:	74 29                	je     8057ec <tcp_listen_with_backlog+0x92>
  8057c3:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8057c9:	b9 00 00 00 00       	mov    $0x0,%ecx
  8057ce:	bf 01 00 00 00       	mov    $0x1,%edi
  8057d3:	eb 5c                	jmp    805831 <tcp_listen_with_backlog+0xd7>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8057d5:	83 ec 04             	sub    $0x4,%esp
  8057d8:	68 18 20 81 00       	push   $0x812018
  8057dd:	68 60 01 00 00       	push   $0x160
  8057e2:	68 ce 21 81 00       	push   $0x8121ce
  8057e7:	e8 4b 91 00 00       	call   80e937 <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8057ec:	8b 43 0c             	mov    0xc(%ebx),%eax
  8057ef:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  8057f4:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  8057fb:	83 ec 08             	sub    $0x8,%esp
  8057fe:	53                   	push   %ebx
  8057ff:	6a 02                	push   $0x2
  805801:	e8 92 ee ff ff       	call   804698 <memp_free>
  lpcb->accept = tcp_accept_null;
  805806:	c7 46 20 95 55 80 00 	movl   $0x805595,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80580d:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805812:	89 46 0c             	mov    %eax,0xc(%esi)
  805815:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  80581b:	e8 26 cb ff ff       	call   802346 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805820:	83 c4 10             	add    $0x10,%esp
}
  805823:	89 f0                	mov    %esi,%eax
  805825:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805828:	5b                   	pop    %ebx
  805829:	5e                   	pop    %esi
  80582a:	5f                   	pop    %edi
  80582b:	5d                   	pop    %ebp
  80582c:	c3                   	ret    
  80582d:	89 f9                	mov    %edi,%ecx
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80582f:	89 c2                	mov    %eax,%edx
  805831:	85 d2                	test   %edx,%edx
  805833:	74 1d                	je     805852 <tcp_listen_with_backlog+0xf8>
  805835:	8b 42 0c             	mov    0xc(%edx),%eax
  805838:	39 d8                	cmp    %ebx,%eax
  80583a:	75 f1                	jne    80582d <tcp_listen_with_backlog+0xd3>
  80583c:	85 c0                	test   %eax,%eax
  80583e:	74 ed                	je     80582d <tcp_listen_with_backlog+0xd3>
  805840:	84 c9                	test   %cl,%cl
  805842:	74 06                	je     80584a <tcp_listen_with_backlog+0xf0>
  805844:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80584a:	8b 43 0c             	mov    0xc(%ebx),%eax
  80584d:	89 42 0c             	mov    %eax,0xc(%edx)
  805850:	eb a2                	jmp    8057f4 <tcp_listen_with_backlog+0x9a>
  805852:	84 c9                	test   %cl,%cl
  805854:	74 9e                	je     8057f4 <tcp_listen_with_backlog+0x9a>
  805856:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80585d:	00 00 00 
  805860:	eb 92                	jmp    8057f4 <tcp_listen_with_backlog+0x9a>

00805862 <tcp_recved>:
{
  805862:	f3 0f 1e fb          	endbr32 
  805866:	55                   	push   %ebp
  805867:	89 e5                	mov    %esp,%ebp
  805869:	56                   	push   %esi
  80586a:	53                   	push   %ebx
  80586b:	8b 45 08             	mov    0x8(%ebp),%eax
  80586e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805871:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  805875:	0f b7 ca             	movzwl %dx,%ecx
  805878:	0f b7 f3             	movzwl %bx,%esi
  80587b:	01 f1                	add    %esi,%ecx
  80587d:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805883:	76 27                	jbe    8058ac <tcp_recved+0x4a>
    pcb->rcv_wnd = TCP_WND;
  805885:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  80588b:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  805891:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  805895:	f6 c2 03             	test   $0x3,%dl
  805898:	75 3b                	jne    8058d5 <tcp_recved+0x73>
    tcp_ack(pcb);
  80589a:	f6 c2 01             	test   $0x1,%dl
  80589d:	75 1f                	jne    8058be <tcp_recved+0x5c>
  80589f:	83 ca 01             	or     $0x1,%edx
  8058a2:	88 50 20             	mov    %dl,0x20(%eax)
}
  8058a5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8058a8:	5b                   	pop    %ebx
  8058a9:	5e                   	pop    %esi
  8058aa:	5d                   	pop    %ebp
  8058ab:	c3                   	ret    
    pcb->rcv_wnd += len;
  8058ac:	01 da                	add    %ebx,%edx
  8058ae:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  8058b2:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8058b6:	72 d9                	jb     805891 <tcp_recved+0x2f>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8058b8:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  8058bc:	eb d3                	jmp    805891 <tcp_recved+0x2f>
    tcp_ack(pcb);
  8058be:	83 e2 fe             	and    $0xfffffffe,%edx
  8058c1:	83 ca 02             	or     $0x2,%edx
  8058c4:	88 50 20             	mov    %dl,0x20(%eax)
  8058c7:	83 ec 0c             	sub    $0xc,%esp
  8058ca:	50                   	push   %eax
  8058cb:	e8 09 2a 00 00       	call   8082d9 <tcp_output>
  8058d0:	83 c4 10             	add    $0x10,%esp
  8058d3:	eb d0                	jmp    8058a5 <tcp_recved+0x43>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  8058d5:	f6 c2 01             	test   $0x1,%dl
  8058d8:	74 cb                	je     8058a5 <tcp_recved+0x43>
  8058da:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  8058e0:	76 c3                	jbe    8058a5 <tcp_recved+0x43>
    tcp_ack_now(pcb);
  8058e2:	83 ca 02             	or     $0x2,%edx
  8058e5:	88 50 20             	mov    %dl,0x20(%eax)
  8058e8:	83 ec 0c             	sub    $0xc,%esp
  8058eb:	50                   	push   %eax
  8058ec:	e8 e8 29 00 00       	call   8082d9 <tcp_output>
  8058f1:	83 c4 10             	add    $0x10,%esp
}
  8058f4:	eb af                	jmp    8058a5 <tcp_recved+0x43>

008058f6 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8058f6:	f3 0f 1e fb          	endbr32 
  8058fa:	55                   	push   %ebp
  8058fb:	89 e5                	mov    %esp,%ebp
  8058fd:	53                   	push   %ebx
  8058fe:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805901:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  805907:	eb 21                	jmp    80592a <tcp_fasttmr+0x34>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805909:	83 ec 0c             	sub    $0xc,%esp
  80590c:	50                   	push   %eax
  80590d:	e8 09 f1 ff ff       	call   804a1b <pbuf_free>
  805912:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805915:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80591c:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  80591f:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805923:	a8 01                	test   $0x1,%al
  805925:	75 2d                	jne    805954 <tcp_fasttmr+0x5e>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805927:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80592a:	85 db                	test   %ebx,%ebx
  80592c:	74 3e                	je     80596c <tcp_fasttmr+0x76>
    if (pcb->refused_data != NULL) {
  80592e:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805934:	85 c0                	test   %eax,%eax
  805936:	74 e7                	je     80591f <tcp_fasttmr+0x29>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805938:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80593e:	85 d2                	test   %edx,%edx
  805940:	74 c7                	je     805909 <tcp_fasttmr+0x13>
  805942:	6a 00                	push   $0x0
  805944:	50                   	push   %eax
  805945:	53                   	push   %ebx
  805946:	ff 73 18             	pushl  0x18(%ebx)
  805949:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80594b:	83 c4 10             	add    $0x10,%esp
  80594e:	84 c0                	test   %al,%al
  805950:	74 c3                	je     805915 <tcp_fasttmr+0x1f>
  805952:	eb cb                	jmp    80591f <tcp_fasttmr+0x29>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805954:	83 c8 02             	or     $0x2,%eax
  805957:	88 43 20             	mov    %al,0x20(%ebx)
  80595a:	83 ec 0c             	sub    $0xc,%esp
  80595d:	53                   	push   %ebx
  80595e:	e8 76 29 00 00       	call   8082d9 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805963:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  805967:	83 c4 10             	add    $0x10,%esp
  80596a:	eb bb                	jmp    805927 <tcp_fasttmr+0x31>
    }
  }
}
  80596c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80596f:	c9                   	leave  
  805970:	c3                   	ret    

00805971 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805971:	f3 0f 1e fb          	endbr32 
  805975:	55                   	push   %ebp
  805976:	89 e5                	mov    %esp,%ebp
  805978:	56                   	push   %esi
  805979:	53                   	push   %ebx
  80597a:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  80597d:	bb 00 00 00 00       	mov    $0x0,%ebx
  
  if (seg != NULL) {
  805982:	85 f6                	test   %esi,%esi
  805984:	74 23                	je     8059a9 <tcp_seg_free+0x38>
    if (seg->p != NULL) {
  805986:	8b 46 04             	mov    0x4(%esi),%eax
  805989:	85 c0                	test   %eax,%eax
  80598b:	74 0e                	je     80599b <tcp_seg_free+0x2a>
      count = pbuf_free(seg->p);
  80598d:	83 ec 0c             	sub    $0xc,%esp
  805990:	50                   	push   %eax
  805991:	e8 85 f0 ff ff       	call   804a1b <pbuf_free>
  805996:	89 c3                	mov    %eax,%ebx
  805998:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  80599b:	83 ec 08             	sub    $0x8,%esp
  80599e:	56                   	push   %esi
  80599f:	6a 04                	push   $0x4
  8059a1:	e8 f2 ec ff ff       	call   804698 <memp_free>
  8059a6:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  8059a9:	89 d8                	mov    %ebx,%eax
  8059ab:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8059ae:	5b                   	pop    %ebx
  8059af:	5e                   	pop    %esi
  8059b0:	5d                   	pop    %ebp
  8059b1:	c3                   	ret    

008059b2 <tcp_segs_free>:
{
  8059b2:	f3 0f 1e fb          	endbr32 
  8059b6:	55                   	push   %ebp
  8059b7:	89 e5                	mov    %esp,%ebp
  8059b9:	56                   	push   %esi
  8059ba:	53                   	push   %ebx
  8059bb:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  8059be:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  8059c3:	85 c0                	test   %eax,%eax
  8059c5:	74 14                	je     8059db <tcp_segs_free+0x29>
    next = seg->next;
  8059c7:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  8059c9:	83 ec 0c             	sub    $0xc,%esp
  8059cc:	50                   	push   %eax
  8059cd:	e8 9f ff ff ff       	call   805971 <tcp_seg_free>
  8059d2:	01 c3                	add    %eax,%ebx
  8059d4:	83 c4 10             	add    $0x10,%esp
    seg = next;
  8059d7:	89 f0                	mov    %esi,%eax
  8059d9:	eb e8                	jmp    8059c3 <tcp_segs_free+0x11>
}
  8059db:	89 d8                	mov    %ebx,%eax
  8059dd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8059e0:	5b                   	pop    %ebx
  8059e1:	5e                   	pop    %esi
  8059e2:	5d                   	pop    %ebp
  8059e3:	c3                   	ret    

008059e4 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8059e4:	f3 0f 1e fb          	endbr32 
  8059e8:	55                   	push   %ebp
  8059e9:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8059eb:	8b 45 08             	mov    0x8(%ebp),%eax
  8059ee:	8b 55 0c             	mov    0xc(%ebp),%edx
  8059f1:	88 50 14             	mov    %dl,0x14(%eax)
}
  8059f4:	5d                   	pop    %ebp
  8059f5:	c3                   	ret    

008059f6 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8059f6:	f3 0f 1e fb          	endbr32 
  8059fa:	55                   	push   %ebp
  8059fb:	89 e5                	mov    %esp,%ebp
  8059fd:	53                   	push   %ebx
  8059fe:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805a01:	6a 04                	push   $0x4
  805a03:	e8 36 ec ff ff       	call   80463e <memp_malloc>
  805a08:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805a0a:	83 c4 10             	add    $0x10,%esp
  805a0d:	85 c0                	test   %eax,%eax
  805a0f:	74 1c                	je     805a2d <tcp_seg_copy+0x37>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805a11:	83 ec 04             	sub    $0x4,%esp
  805a14:	6a 14                	push   $0x14
  805a16:	ff 75 08             	pushl  0x8(%ebp)
  805a19:	50                   	push   %eax
  805a1a:	e8 6d 98 00 00       	call   80f28c <memcpy>
  pbuf_ref(cseg->p);
  805a1f:	83 c4 04             	add    $0x4,%esp
  805a22:	ff 73 04             	pushl  0x4(%ebx)
  805a25:	e8 4e f4 ff ff       	call   804e78 <pbuf_ref>
  return cseg;
  805a2a:	83 c4 10             	add    $0x10,%esp
}
  805a2d:	89 d8                	mov    %ebx,%eax
  805a2f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805a32:	c9                   	leave  
  805a33:	c3                   	ret    

00805a34 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805a34:	f3 0f 1e fb          	endbr32 
  805a38:	55                   	push   %ebp
  805a39:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805a3b:	8b 45 08             	mov    0x8(%ebp),%eax
  805a3e:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a41:	89 50 18             	mov    %edx,0x18(%eax)
}
  805a44:	5d                   	pop    %ebp
  805a45:	c3                   	ret    

00805a46 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805a46:	f3 0f 1e fb          	endbr32 
  805a4a:	55                   	push   %ebp
  805a4b:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805a4d:	8b 45 08             	mov    0x8(%ebp),%eax
  805a50:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a53:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805a59:	5d                   	pop    %ebp
  805a5a:	c3                   	ret    

00805a5b <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805a5b:	f3 0f 1e fb          	endbr32 
  805a5f:	55                   	push   %ebp
  805a60:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805a62:	8b 45 08             	mov    0x8(%ebp),%eax
  805a65:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a68:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805a6e:	5d                   	pop    %ebp
  805a6f:	c3                   	ret    

00805a70 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805a70:	f3 0f 1e fb          	endbr32 
  805a74:	55                   	push   %ebp
  805a75:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805a77:	8b 45 08             	mov    0x8(%ebp),%eax
  805a7a:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a7d:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805a83:	5d                   	pop    %ebp
  805a84:	c3                   	ret    

00805a85 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805a85:	f3 0f 1e fb          	endbr32 
  805a89:	55                   	push   %ebp
  805a8a:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805a8c:	8b 45 08             	mov    0x8(%ebp),%eax
  805a8f:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a92:	89 50 20             	mov    %edx,0x20(%eax)
}
  805a95:	5d                   	pop    %ebp
  805a96:	c3                   	ret    

00805a97 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805a97:	f3 0f 1e fb          	endbr32 
  805a9b:	55                   	push   %ebp
  805a9c:	89 e5                	mov    %esp,%ebp
  805a9e:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805aa1:	8b 55 0c             	mov    0xc(%ebp),%edx
  805aa4:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805aaa:	8b 55 10             	mov    0x10(%ebp),%edx
  805aad:	88 50 31             	mov    %dl,0x31(%eax)
}
  805ab0:	5d                   	pop    %ebp
  805ab1:	c3                   	ret    

00805ab2 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805ab2:	f3 0f 1e fb          	endbr32 
  805ab6:	55                   	push   %ebp
  805ab7:	89 e5                	mov    %esp,%ebp
  805ab9:	53                   	push   %ebx
  805aba:	83 ec 04             	sub    $0x4,%esp
  805abd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805ac0:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  805ac3:	83 f8 0a             	cmp    $0xa,%eax
  805ac6:	74 05                	je     805acd <tcp_pcb_purge+0x1b>
  805ac8:	83 f8 01             	cmp    $0x1,%eax
  805acb:	77 05                	ja     805ad2 <tcp_pcb_purge+0x20>
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
  }
}
  805acd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805ad0:	c9                   	leave  
  805ad1:	c3                   	ret    
    if (pcb->refused_data != NULL) {
  805ad2:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805ad8:	85 c0                	test   %eax,%eax
  805ada:	74 16                	je     805af2 <tcp_pcb_purge+0x40>
      pbuf_free(pcb->refused_data);
  805adc:	83 ec 0c             	sub    $0xc,%esp
  805adf:	50                   	push   %eax
  805ae0:	e8 36 ef ff ff       	call   804a1b <pbuf_free>
      pcb->refused_data = NULL;
  805ae5:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805aec:	00 00 00 
  805aef:	83 c4 10             	add    $0x10,%esp
    pcb->rtime = -1;
  805af2:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    tcp_segs_free(pcb->ooseq);
  805af8:	83 ec 0c             	sub    $0xc,%esp
  805afb:	ff 73 7c             	pushl  0x7c(%ebx)
  805afe:	e8 af fe ff ff       	call   8059b2 <tcp_segs_free>
    pcb->ooseq = NULL;
  805b03:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
    tcp_segs_free(pcb->unsent);
  805b0a:	83 c4 04             	add    $0x4,%esp
  805b0d:	ff 73 74             	pushl  0x74(%ebx)
  805b10:	e8 9d fe ff ff       	call   8059b2 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805b15:	83 c4 04             	add    $0x4,%esp
  805b18:	ff 73 78             	pushl  0x78(%ebx)
  805b1b:	e8 92 fe ff ff       	call   8059b2 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805b20:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805b27:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  805b2e:	83 c4 10             	add    $0x10,%esp
}
  805b31:	eb 9a                	jmp    805acd <tcp_pcb_purge+0x1b>

00805b33 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805b33:	f3 0f 1e fb          	endbr32 
  805b37:	55                   	push   %ebp
  805b38:	89 e5                	mov    %esp,%ebp
  805b3a:	56                   	push   %esi
  805b3b:	53                   	push   %ebx
  805b3c:	8b 45 08             	mov    0x8(%ebp),%eax
  805b3f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805b42:	8b 10                	mov    (%eax),%edx
  805b44:	39 da                	cmp    %ebx,%edx
  805b46:	74 12                	je     805b5a <tcp_pcb_remove+0x27>
  805b48:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805b4e:	b9 00 00 00 00       	mov    $0x0,%ecx
  805b53:	be 01 00 00 00       	mov    $0x1,%esi
  805b58:	eb 59                	jmp    805bb3 <tcp_pcb_remove+0x80>
  805b5a:	8b 53 0c             	mov    0xc(%ebx),%edx
  805b5d:	89 10                	mov    %edx,(%eax)
  805b5f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805b66:	83 ec 0c             	sub    $0xc,%esp
  805b69:	53                   	push   %ebx
  805b6a:	e8 43 ff ff ff       	call   805ab2 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805b6f:	8b 43 10             	mov    0x10(%ebx),%eax
  805b72:	83 c4 10             	add    $0x10,%esp
  805b75:	83 f8 0a             	cmp    $0xa,%eax
  805b78:	74 7f                	je     805bf9 <tcp_pcb_remove+0xc6>
  805b7a:	83 f8 01             	cmp    $0x1,%eax
  805b7d:	74 7a                	je     805bf9 <tcp_pcb_remove+0xc6>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805b7f:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  805b83:	a8 01                	test   $0x1,%al
  805b85:	75 60                	jne    805be7 <tcp_pcb_remove+0xb4>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805b87:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805b8b:	75 74                	jne    805c01 <tcp_pcb_remove+0xce>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805b8d:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805b91:	0f 85 81 00 00 00    	jne    805c18 <tcp_pcb_remove+0xe5>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805b97:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805b9b:	0f 85 8e 00 00 00    	jne    805c2f <tcp_pcb_remove+0xfc>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805ba1:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805ba8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805bab:	5b                   	pop    %ebx
  805bac:	5e                   	pop    %esi
  805bad:	5d                   	pop    %ebp
  805bae:	c3                   	ret    
  805baf:	89 f1                	mov    %esi,%ecx
  TCP_RMV(pcblist, pcb);
  805bb1:	89 c2                	mov    %eax,%edx
  805bb3:	85 d2                	test   %edx,%edx
  805bb5:	74 1d                	je     805bd4 <tcp_pcb_remove+0xa1>
  805bb7:	8b 42 0c             	mov    0xc(%edx),%eax
  805bba:	39 d8                	cmp    %ebx,%eax
  805bbc:	75 f1                	jne    805baf <tcp_pcb_remove+0x7c>
  805bbe:	85 c0                	test   %eax,%eax
  805bc0:	74 ed                	je     805baf <tcp_pcb_remove+0x7c>
  805bc2:	84 c9                	test   %cl,%cl
  805bc4:	74 06                	je     805bcc <tcp_pcb_remove+0x99>
  805bc6:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805bcc:	8b 43 0c             	mov    0xc(%ebx),%eax
  805bcf:	89 42 0c             	mov    %eax,0xc(%edx)
  805bd2:	eb 8b                	jmp    805b5f <tcp_pcb_remove+0x2c>
  805bd4:	84 c9                	test   %cl,%cl
  805bd6:	74 87                	je     805b5f <tcp_pcb_remove+0x2c>
  805bd8:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805bdf:	00 00 00 
  805be2:	e9 78 ff ff ff       	jmp    805b5f <tcp_pcb_remove+0x2c>
    pcb->flags |= TF_ACK_NOW;
  805be7:	83 c8 02             	or     $0x2,%eax
  805bea:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805bed:	83 ec 0c             	sub    $0xc,%esp
  805bf0:	53                   	push   %ebx
  805bf1:	e8 e3 26 00 00       	call   8082d9 <tcp_output>
  805bf6:	83 c4 10             	add    $0x10,%esp
  if (pcb->state != LISTEN) {
  805bf9:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805bfd:	74 a2                	je     805ba1 <tcp_pcb_remove+0x6e>
  805bff:	eb 86                	jmp    805b87 <tcp_pcb_remove+0x54>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805c01:	83 ec 04             	sub    $0x4,%esp
  805c04:	68 e2 21 81 00       	push   $0x8121e2
  805c09:	68 b4 04 00 00       	push   $0x4b4
  805c0e:	68 ce 21 81 00       	push   $0x8121ce
  805c13:	e8 1f 8d 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805c18:	83 ec 04             	sub    $0x4,%esp
  805c1b:	68 fa 21 81 00       	push   $0x8121fa
  805c20:	68 b5 04 00 00       	push   $0x4b5
  805c25:	68 ce 21 81 00       	push   $0x8121ce
  805c2a:	e8 08 8d 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805c2f:	83 ec 04             	sub    $0x4,%esp
  805c32:	68 13 22 81 00       	push   $0x812213
  805c37:	68 b7 04 00 00       	push   $0x4b7
  805c3c:	68 ce 21 81 00       	push   $0x8121ce
  805c41:	e8 f1 8c 00 00       	call   80e937 <_panic>

00805c46 <tcp_close>:
{
  805c46:	f3 0f 1e fb          	endbr32 
  805c4a:	55                   	push   %ebp
  805c4b:	89 e5                	mov    %esp,%ebp
  805c4d:	56                   	push   %esi
  805c4e:	53                   	push   %ebx
  805c4f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805c52:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805c56:	0f 87 30 01 00 00    	ja     805d8c <tcp_close+0x146>
  805c5c:	8b 43 10             	mov    0x10(%ebx),%eax
  805c5f:	3e ff 24 85 2c 22 81 	notrack jmp *0x81222c(,%eax,4)
  805c66:	00 
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805c67:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  805c6d:	39 da                	cmp    %ebx,%edx
  805c6f:	74 12                	je     805c83 <tcp_close+0x3d>
  805c71:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805c77:	b9 00 00 00 00       	mov    $0x0,%ecx
  805c7c:	be 01 00 00 00       	mov    $0x1,%esi
  805c81:	eb 2b                	jmp    805cae <tcp_close+0x68>
  805c83:	8b 43 0c             	mov    0xc(%ebx),%eax
  805c86:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805c8b:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805c92:	83 ec 08             	sub    $0x8,%esp
  805c95:	53                   	push   %ebx
  805c96:	6a 02                	push   $0x2
  805c98:	e8 fb e9 ff ff       	call   804698 <memp_free>
    break;
  805c9d:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805ca0:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805ca5:	e9 a5 00 00 00       	jmp    805d4f <tcp_close+0x109>
  805caa:	89 f1                	mov    %esi,%ecx
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805cac:	89 c2                	mov    %eax,%edx
  805cae:	85 d2                	test   %edx,%edx
  805cb0:	74 1d                	je     805ccf <tcp_close+0x89>
  805cb2:	8b 42 0c             	mov    0xc(%edx),%eax
  805cb5:	39 d8                	cmp    %ebx,%eax
  805cb7:	75 f1                	jne    805caa <tcp_close+0x64>
  805cb9:	85 c0                	test   %eax,%eax
  805cbb:	74 ed                	je     805caa <tcp_close+0x64>
  805cbd:	84 c9                	test   %cl,%cl
  805cbf:	74 06                	je     805cc7 <tcp_close+0x81>
  805cc1:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805cc7:	8b 43 0c             	mov    0xc(%ebx),%eax
  805cca:	89 42 0c             	mov    %eax,0xc(%edx)
  805ccd:	eb bc                	jmp    805c8b <tcp_close+0x45>
  805ccf:	84 c9                	test   %cl,%cl
  805cd1:	74 b8                	je     805c8b <tcp_close+0x45>
  805cd3:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805cda:	00 00 00 
  805cdd:	eb ac                	jmp    805c8b <tcp_close+0x45>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805cdf:	83 ec 08             	sub    $0x8,%esp
  805ce2:	53                   	push   %ebx
  805ce3:	68 44 b2 b3 00       	push   $0xb3b244
  805ce8:	e8 46 fe ff ff       	call   805b33 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805ced:	83 c4 08             	add    $0x8,%esp
  805cf0:	53                   	push   %ebx
  805cf1:	6a 03                	push   $0x3
  805cf3:	e8 a0 e9 ff ff       	call   804698 <memp_free>
    break;
  805cf8:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805cfb:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805d00:	eb 4d                	jmp    805d4f <tcp_close+0x109>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805d02:	83 ec 08             	sub    $0x8,%esp
  805d05:	53                   	push   %ebx
  805d06:	68 3c b2 b3 00       	push   $0xb3b23c
  805d0b:	e8 23 fe ff ff       	call   805b33 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805d10:	83 c4 08             	add    $0x8,%esp
  805d13:	53                   	push   %ebx
  805d14:	6a 02                	push   $0x2
  805d16:	e8 7d e9 ff ff       	call   804698 <memp_free>
    break;
  805d1b:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805d1e:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805d23:	eb 2a                	jmp    805d4f <tcp_close+0x109>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805d25:	83 ec 08             	sub    $0x8,%esp
  805d28:	6a 01                	push   $0x1
  805d2a:	53                   	push   %ebx
  805d2b:	e8 2b 25 00 00       	call   80825b <tcp_send_ctrl>
    if (err == ERR_OK) {
  805d30:	83 c4 10             	add    $0x10,%esp
  805d33:	84 c0                	test   %al,%al
  805d35:	75 18                	jne    805d4f <tcp_close+0x109>
      pcb->state = FIN_WAIT_1;
  805d37:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    tcp_output(pcb);
  805d3e:	83 ec 0c             	sub    $0xc,%esp
  805d41:	53                   	push   %ebx
  805d42:	e8 92 25 00 00       	call   8082d9 <tcp_output>
  805d47:	83 c4 10             	add    $0x10,%esp
  805d4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805d4f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805d52:	5b                   	pop    %ebx
  805d53:	5e                   	pop    %esi
  805d54:	5d                   	pop    %ebp
  805d55:	c3                   	ret    
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805d56:	83 ec 08             	sub    $0x8,%esp
  805d59:	6a 01                	push   $0x1
  805d5b:	53                   	push   %ebx
  805d5c:	e8 fa 24 00 00       	call   80825b <tcp_send_ctrl>
    if (err == ERR_OK) {
  805d61:	83 c4 10             	add    $0x10,%esp
  805d64:	84 c0                	test   %al,%al
  805d66:	75 e7                	jne    805d4f <tcp_close+0x109>
      pcb->state = FIN_WAIT_1;
  805d68:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805d6f:	eb cd                	jmp    805d3e <tcp_close+0xf8>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805d71:	83 ec 08             	sub    $0x8,%esp
  805d74:	6a 01                	push   $0x1
  805d76:	53                   	push   %ebx
  805d77:	e8 df 24 00 00       	call   80825b <tcp_send_ctrl>
    if (err == ERR_OK) {
  805d7c:	83 c4 10             	add    $0x10,%esp
  805d7f:	84 c0                	test   %al,%al
  805d81:	75 cc                	jne    805d4f <tcp_close+0x109>
      pcb->state = LAST_ACK;
  805d83:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805d8a:	eb b2                	jmp    805d3e <tcp_close+0xf8>
  switch (pcb->state) {
  805d8c:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805d91:	eb bc                	jmp    805d4f <tcp_close+0x109>

00805d93 <tcp_recv_null>:
{
  805d93:	f3 0f 1e fb          	endbr32 
  805d97:	55                   	push   %ebp
  805d98:	89 e5                	mov    %esp,%ebp
  805d9a:	83 ec 08             	sub    $0x8,%esp
  805d9d:	8b 45 10             	mov    0x10(%ebp),%eax
  805da0:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805da3:	85 c0                	test   %eax,%eax
  805da5:	74 13                	je     805dba <tcp_recv_null+0x27>
    pbuf_free(p);
  805da7:	83 ec 0c             	sub    $0xc,%esp
  805daa:	50                   	push   %eax
  805dab:	e8 6b ec ff ff       	call   804a1b <pbuf_free>
  805db0:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805db3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805db8:	c9                   	leave  
  805db9:	c3                   	ret    
  return ERR_OK;
  805dba:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805dbf:	84 d2                	test   %dl,%dl
  805dc1:	75 f5                	jne    805db8 <tcp_recv_null+0x25>
    return tcp_close(pcb);
  805dc3:	83 ec 0c             	sub    $0xc,%esp
  805dc6:	ff 75 0c             	pushl  0xc(%ebp)
  805dc9:	e8 78 fe ff ff       	call   805c46 <tcp_close>
  805dce:	83 c4 10             	add    $0x10,%esp
  805dd1:	eb e5                	jmp    805db8 <tcp_recv_null+0x25>

00805dd3 <tcp_abort>:
{
  805dd3:	f3 0f 1e fb          	endbr32 
  805dd7:	55                   	push   %ebp
  805dd8:	89 e5                	mov    %esp,%ebp
  805dda:	57                   	push   %edi
  805ddb:	56                   	push   %esi
  805ddc:	53                   	push   %ebx
  805ddd:	83 ec 2c             	sub    $0x2c,%esp
  805de0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805de3:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805de7:	0f 84 c2 00 00 00    	je     805eaf <tcp_abort+0xdc>
    seqno = pcb->snd_nxt;
  805ded:	8b 43 54             	mov    0x54(%ebx),%eax
  805df0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805df3:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805df6:	8b 03                	mov    (%ebx),%eax
  805df8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805dfb:	8b 43 04             	mov    0x4(%ebx),%eax
  805dfe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805e01:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805e05:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805e09:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805e0d:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805e11:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805e17:	8b 43 18             	mov    0x18(%ebx),%eax
  805e1a:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805e1d:	83 ec 08             	sub    $0x8,%esp
  805e20:	53                   	push   %ebx
  805e21:	68 3c b2 b3 00       	push   $0xb3b23c
  805e26:	e8 08 fd ff ff       	call   805b33 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805e2b:	8b 43 78             	mov    0x78(%ebx),%eax
  805e2e:	83 c4 10             	add    $0x10,%esp
  805e31:	85 c0                	test   %eax,%eax
  805e33:	74 0c                	je     805e41 <tcp_abort+0x6e>
      tcp_segs_free(pcb->unacked);
  805e35:	83 ec 0c             	sub    $0xc,%esp
  805e38:	50                   	push   %eax
  805e39:	e8 74 fb ff ff       	call   8059b2 <tcp_segs_free>
  805e3e:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805e41:	8b 43 74             	mov    0x74(%ebx),%eax
  805e44:	85 c0                	test   %eax,%eax
  805e46:	74 0c                	je     805e54 <tcp_abort+0x81>
      tcp_segs_free(pcb->unsent);
  805e48:	83 ec 0c             	sub    $0xc,%esp
  805e4b:	50                   	push   %eax
  805e4c:	e8 61 fb ff ff       	call   8059b2 <tcp_segs_free>
  805e51:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805e54:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805e57:	85 c0                	test   %eax,%eax
  805e59:	74 0c                	je     805e67 <tcp_abort+0x94>
      tcp_segs_free(pcb->ooseq);
  805e5b:	83 ec 0c             	sub    $0xc,%esp
  805e5e:	50                   	push   %eax
  805e5f:	e8 4e fb ff ff       	call   8059b2 <tcp_segs_free>
  805e64:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805e67:	83 ec 08             	sub    $0x8,%esp
  805e6a:	53                   	push   %ebx
  805e6b:	6a 02                	push   $0x2
  805e6d:	e8 26 e8 ff ff       	call   804698 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805e72:	83 c4 10             	add    $0x10,%esp
  805e75:	85 f6                	test   %esi,%esi
  805e77:	74 0d                	je     805e86 <tcp_abort+0xb3>
  805e79:	83 ec 08             	sub    $0x8,%esp
  805e7c:	6a fb                	push   $0xfffffffb
  805e7e:	ff 75 cc             	pushl  -0x34(%ebp)
  805e81:	ff d6                	call   *%esi
  805e83:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805e86:	83 ec 08             	sub    $0x8,%esp
  805e89:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805e8d:	50                   	push   %eax
  805e8e:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805e92:	50                   	push   %eax
  805e93:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805e96:	50                   	push   %eax
  805e97:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805e9a:	50                   	push   %eax
  805e9b:	57                   	push   %edi
  805e9c:	ff 75 d4             	pushl  -0x2c(%ebp)
  805e9f:	e8 db 28 00 00       	call   80877f <tcp_rst>
  805ea4:	83 c4 20             	add    $0x20,%esp
}
  805ea7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805eaa:	5b                   	pop    %ebx
  805eab:	5e                   	pop    %esi
  805eac:	5f                   	pop    %edi
  805ead:	5d                   	pop    %ebp
  805eae:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805eaf:	83 ec 08             	sub    $0x8,%esp
  805eb2:	53                   	push   %ebx
  805eb3:	68 50 b2 b3 00       	push   $0xb3b250
  805eb8:	e8 76 fc ff ff       	call   805b33 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805ebd:	83 c4 08             	add    $0x8,%esp
  805ec0:	53                   	push   %ebx
  805ec1:	6a 02                	push   $0x2
  805ec3:	e8 d0 e7 ff ff       	call   804698 <memp_free>
  805ec8:	83 c4 10             	add    $0x10,%esp
  805ecb:	eb da                	jmp    805ea7 <tcp_abort+0xd4>

00805ecd <tcp_slowtmr>:
{
  805ecd:	f3 0f 1e fb          	endbr32 
  805ed1:	55                   	push   %ebp
  805ed2:	89 e5                	mov    %esp,%ebp
  805ed4:	57                   	push   %edi
  805ed5:	56                   	push   %esi
  805ed6:	53                   	push   %ebx
  805ed7:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805eda:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240
  pcb = tcp_active_pcbs;
  805ee1:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  err = ERR_OK;
  805ee7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  prev = NULL;
  805eeb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  805ef2:	e9 8f 02 00 00       	jmp    806186 <tcp_slowtmr+0x2b9>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805ef7:	83 ec 04             	sub    $0x4,%esp
  805efa:	68 3c 20 81 00       	push   $0x81203c
  805eff:	68 36 02 00 00       	push   $0x236
  805f04:	68 ce 21 81 00       	push   $0x8121ce
  805f09:	e8 29 8a 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805f0e:	83 ec 04             	sub    $0x4,%esp
  805f11:	68 68 20 81 00       	push   $0x812068
  805f16:	68 37 02 00 00       	push   $0x237
  805f1b:	68 ce 21 81 00       	push   $0x8121ce
  805f20:	e8 12 8a 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805f25:	83 ec 04             	sub    $0x4,%esp
  805f28:	68 94 20 81 00       	push   $0x812094
  805f2d:	68 38 02 00 00       	push   $0x238
  805f32:	68 ce 21 81 00       	push   $0x8121ce
  805f37:	e8 fb 89 00 00       	call   80e937 <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805f3c:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805f40:	80 fa 06             	cmp    $0x6,%dl
  805f43:	0f 84 35 01 00 00    	je     80607e <tcp_slowtmr+0x1b1>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805f49:	80 fa 0c             	cmp    $0xc,%dl
  805f4c:	0f 85 74 02 00 00    	jne    8061c6 <tcp_slowtmr+0x2f9>
  805f52:	be 01 00 00 00       	mov    $0x1,%esi
  805f57:	e9 27 01 00 00       	jmp    806083 <tcp_slowtmr+0x1b6>
        if(pcb->rtime >= 0)
  805f5c:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805f60:	66 85 c9             	test   %cx,%cx
  805f63:	78 07                	js     805f6c <tcp_slowtmr+0x9f>
          ++pcb->rtime;
  805f65:	83 c1 01             	add    $0x1,%ecx
  805f68:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805f6c:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805f70:	74 6c                	je     805fde <tcp_slowtmr+0x111>
  805f72:	0f b7 7b 44          	movzwl 0x44(%ebx),%edi
  805f76:	66 39 7b 32          	cmp    %di,0x32(%ebx)
  805f7a:	7c 62                	jl     805fde <tcp_slowtmr+0x111>
          if (pcb->state != SYN_SENT) {
  805f7c:	83 f8 02             	cmp    $0x2,%eax
  805f7f:	74 1f                	je     805fa0 <tcp_slowtmr+0xd3>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805f81:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805f85:	66 c1 f8 03          	sar    $0x3,%ax
  805f89:	98                   	cwtl   
  805f8a:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805f8e:	01 c8                	add    %ecx,%eax
  805f90:	0f b6 d2             	movzbl %dl,%edx
  805f93:	0f b6 8a 54 22 81 00 	movzbl 0x812254(%edx),%ecx
  805f9a:	d3 e0                	shl    %cl,%eax
  805f9c:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805fa0:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805fa6:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805faa:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805fae:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805fb3:	66 d1 e8             	shr    %ax
          if (pcb->ssthresh < pcb->mss) {
  805fb6:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
            pcb->ssthresh = pcb->mss * 2;
  805fba:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  805fbd:	66 39 d0             	cmp    %dx,%ax
  805fc0:	0f 42 c1             	cmovb  %ecx,%eax
  805fc3:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805fc7:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805fcb:	83 ec 0c             	sub    $0xc,%esp
  805fce:	53                   	push   %ebx
  805fcf:	e8 d8 28 00 00       	call   8088ac <tcp_rexmit_rto>
  805fd4:	83 c4 10             	add    $0x10,%esp
  805fd7:	eb 05                	jmp    805fde <tcp_slowtmr+0x111>
    pcb_remove = 0;
  805fd9:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  805fde:	8b 43 10             	mov    0x10(%ebx),%eax
  805fe1:	83 f8 06             	cmp    $0x6,%eax
  805fe4:	74 6d                	je     806053 <tcp_slowtmr+0x186>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805fe6:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805fea:	0f 84 93 00 00 00    	je     806083 <tcp_slowtmr+0x1b6>
  805ff0:	83 f8 04             	cmp    $0x4,%eax
  805ff3:	74 09                	je     805ffe <tcp_slowtmr+0x131>
  805ff5:	83 f8 07             	cmp    $0x7,%eax
  805ff8:	0f 85 85 00 00 00    	jne    806083 <tcp_slowtmr+0x1b6>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805ffe:	8b 0d 40 b2 b3 00    	mov    0xb3b240,%ecx
  806004:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  806007:	8b bb 9c 00 00 00    	mov    0x9c(%ebx),%edi
  80600d:	8d 97 b8 4c 0a 00    	lea    0xa4cb8(%edi),%edx
  806013:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806018:	f7 e2                	mul    %edx
  80601a:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80601d:	39 d1                	cmp    %edx,%ecx
  80601f:	77 4f                	ja     806070 <tcp_slowtmr+0x1a3>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  806021:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  806028:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  80602e:	01 fa                	add    %edi,%edx
              / TCP_SLOW_INTERVAL)
  806030:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806035:	f7 e2                	mul    %edx
  806037:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80603a:	39 d1                	cmp    %edx,%ecx
  80603c:	76 45                	jbe    806083 <tcp_slowtmr+0x1b6>
        tcp_keepalive(pcb);
  80603e:	83 ec 0c             	sub    $0xc,%esp
  806041:	53                   	push   %ebx
  806042:	e8 11 29 00 00       	call   808958 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  806047:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  80604e:	83 c4 10             	add    $0x10,%esp
  806051:	eb 30                	jmp    806083 <tcp_slowtmr+0x1b6>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806053:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806058:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  80605b:	83 f8 29             	cmp    $0x29,%eax
  80605e:	89 f0                	mov    %esi,%eax
  806060:	1c ff                	sbb    $0xff,%al
  806062:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  806064:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  806067:	85 c9                	test   %ecx,%ecx
  806069:	75 1f                	jne    80608a <tcp_slowtmr+0x1bd>
  80606b:	e9 d0 00 00 00       	jmp    806140 <tcp_slowtmr+0x273>
        tcp_abort(pcb);
  806070:	83 ec 0c             	sub    $0xc,%esp
  806073:	53                   	push   %ebx
  806074:	e8 5a fd ff ff       	call   805dd3 <tcp_abort>
  806079:	83 c4 10             	add    $0x10,%esp
  80607c:	eb 05                	jmp    806083 <tcp_slowtmr+0x1b6>
  80607e:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  806083:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  806086:	85 c9                	test   %ecx,%ecx
  806088:	74 16                	je     8060a0 <tcp_slowtmr+0x1d3>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80608a:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  806090:	2b 53 2c             	sub    0x2c(%ebx),%edx
  806093:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  806097:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80609a:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  80609c:	39 c2                	cmp    %eax,%edx
  80609e:	73 7b                	jae    80611b <tcp_slowtmr+0x24e>
    if (pcb->state == SYN_RCVD) {
  8060a0:	8b 43 10             	mov    0x10(%ebx),%eax
  8060a3:	83 f8 03             	cmp    $0x3,%eax
  8060a6:	0f 84 87 00 00 00    	je     806133 <tcp_slowtmr+0x266>
    if (pcb->state == LAST_ACK) {
  8060ac:	83 f8 09             	cmp    $0x9,%eax
  8060af:	0f 85 8b 00 00 00    	jne    806140 <tcp_slowtmr+0x273>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8060b5:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8060ba:	2b 43 2c             	sub    0x2c(%ebx),%eax
  8060bd:	3d f0 00 00 00       	cmp    $0xf0,%eax
  8060c2:	76 7c                	jbe    806140 <tcp_slowtmr+0x273>
      tcp_pcb_purge(pcb);      
  8060c4:	83 ec 0c             	sub    $0xc,%esp
  8060c7:	53                   	push   %ebx
  8060c8:	e8 e5 f9 ff ff       	call   805ab2 <tcp_pcb_purge>
      if (prev != NULL) {
  8060cd:	83 c4 10             	add    $0x10,%esp
  8060d0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  8060d4:	0f 84 66 01 00 00    	je     806240 <tcp_slowtmr+0x373>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  8060da:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  8060e0:	0f 84 43 01 00 00    	je     806229 <tcp_slowtmr+0x35c>
        prev->next = pcb->next;
  8060e6:	8b 43 0c             	mov    0xc(%ebx),%eax
  8060e9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8060ec:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  8060ef:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  8060f5:	85 c0                	test   %eax,%eax
  8060f7:	74 0d                	je     806106 <tcp_slowtmr+0x239>
  8060f9:	83 ec 08             	sub    $0x8,%esp
  8060fc:	6a fb                	push   $0xfffffffb
  8060fe:	ff 73 18             	pushl  0x18(%ebx)
  806101:	ff d0                	call   *%eax
  806103:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  806106:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  806109:	83 ec 08             	sub    $0x8,%esp
  80610c:	53                   	push   %ebx
  80610d:	6a 02                	push   $0x2
  80610f:	e8 84 e5 ff ff       	call   804698 <memp_free>
  806114:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806117:	89 f3                	mov    %esi,%ebx
  806119:	eb 6b                	jmp    806186 <tcp_slowtmr+0x2b9>
      tcp_segs_free(pcb->ooseq);
  80611b:	83 ec 0c             	sub    $0xc,%esp
  80611e:	51                   	push   %ecx
  80611f:	e8 8e f8 ff ff       	call   8059b2 <tcp_segs_free>
      pcb->ooseq = NULL;
  806124:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  80612b:	83 c4 10             	add    $0x10,%esp
  80612e:	e9 6d ff ff ff       	jmp    8060a0 <tcp_slowtmr+0x1d3>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806133:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806138:	2b 43 2c             	sub    0x2c(%ebx),%eax
  80613b:	83 f8 28             	cmp    $0x28,%eax
  80613e:	77 84                	ja     8060c4 <tcp_slowtmr+0x1f7>
    if (pcb_remove) {
  806140:	89 f0                	mov    %esi,%eax
  806142:	84 c0                	test   %al,%al
  806144:	0f 85 7a ff ff ff    	jne    8060c4 <tcp_slowtmr+0x1f7>
      ++pcb->polltmr;
  80614a:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  80614e:	83 c0 01             	add    $0x1,%eax
  806151:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  806154:	3a 43 31             	cmp    0x31(%ebx),%al
  806157:	72 27                	jb     806180 <tcp_slowtmr+0x2b3>
        pcb->polltmr = 0;
  806159:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  80615d:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  806163:	85 c0                	test   %eax,%eax
  806165:	74 0f                	je     806176 <tcp_slowtmr+0x2a9>
  806167:	83 ec 08             	sub    $0x8,%esp
  80616a:	53                   	push   %ebx
  80616b:	ff 73 18             	pushl  0x18(%ebx)
  80616e:	ff d0                	call   *%eax
  806170:	88 45 e3             	mov    %al,-0x1d(%ebp)
  806173:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  806176:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80617a:	0f 84 ec 00 00 00    	je     80626c <tcp_slowtmr+0x39f>
      prev = pcb;
  806180:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
      pcb = pcb->next;
  806183:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  806186:	85 db                	test   %ebx,%ebx
  806188:	0f 84 ef 00 00 00    	je     80627d <tcp_slowtmr+0x3b0>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80618e:	8b 43 10             	mov    0x10(%ebx),%eax
  806191:	85 c0                	test   %eax,%eax
  806193:	0f 84 5e fd ff ff    	je     805ef7 <tcp_slowtmr+0x2a>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  806199:	83 f8 01             	cmp    $0x1,%eax
  80619c:	0f 84 6c fd ff ff    	je     805f0e <tcp_slowtmr+0x41>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  8061a2:	83 f8 0a             	cmp    $0xa,%eax
  8061a5:	0f 84 7a fd ff ff    	je     805f25 <tcp_slowtmr+0x58>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8061ab:	83 f8 02             	cmp    $0x2,%eax
  8061ae:	0f 84 88 fd ff ff    	je     805f3c <tcp_slowtmr+0x6f>
    else if (pcb->nrtx == TCP_MAXRTX) {
  8061b4:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  8061b8:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  8061bd:	80 fa 0c             	cmp    $0xc,%dl
  8061c0:	0f 84 18 fe ff ff    	je     805fde <tcp_slowtmr+0x111>
      if (pcb->persist_backoff > 0) {
  8061c6:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  8061cd:	89 f1                	mov    %esi,%ecx
  8061cf:	84 c9                	test   %cl,%cl
  8061d1:	0f 84 85 fd ff ff    	je     805f5c <tcp_slowtmr+0x8f>
        pcb->persist_cnt++;
  8061d7:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  8061dd:	83 c0 01             	add    $0x1,%eax
  8061e0:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  8061e6:	0f b6 d1             	movzbl %cl,%edx
  8061e9:	bf 4c 22 81 00       	mov    $0x81224c,%edi
  8061ee:	0f b6 54 17 ff       	movzbl -0x1(%edi,%edx,1),%edx
  8061f3:	39 d0                	cmp    %edx,%eax
  8061f5:	0f 82 de fd ff ff    	jb     805fd9 <tcp_slowtmr+0x10c>
          pcb->persist_cnt = 0;
  8061fb:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  806202:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  806205:	80 f9 06             	cmp    $0x6,%cl
  806208:	77 09                	ja     806213 <tcp_slowtmr+0x346>
            pcb->persist_backoff++;
  80620a:	8d 46 01             	lea    0x1(%esi),%eax
  80620d:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  806213:	83 ec 0c             	sub    $0xc,%esp
  806216:	53                   	push   %ebx
  806217:	e8 66 28 00 00       	call   808a82 <tcp_zero_window_probe>
  80621c:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  80621f:	be 00 00 00 00       	mov    $0x0,%esi
  806224:	e9 b5 fd ff ff       	jmp    805fde <tcp_slowtmr+0x111>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  806229:	83 ec 04             	sub    $0x4,%esp
  80622c:	68 c4 20 81 00       	push   $0x8120c4
  806231:	68 c1 02 00 00       	push   $0x2c1
  806236:	68 ce 21 81 00       	push   $0x8121ce
  80623b:	e8 f7 86 00 00       	call   80e937 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  806240:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  806246:	75 0d                	jne    806255 <tcp_slowtmr+0x388>
        tcp_active_pcbs = pcb->next;
  806248:	8b 43 0c             	mov    0xc(%ebx),%eax
  80624b:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  806250:	e9 9a fe ff ff       	jmp    8060ef <tcp_slowtmr+0x222>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  806255:	83 ec 04             	sub    $0x4,%esp
  806258:	68 f0 20 81 00       	push   $0x8120f0
  80625d:	68 c5 02 00 00       	push   $0x2c5
  806262:	68 ce 21 81 00       	push   $0x8121ce
  806267:	e8 cb 86 00 00       	call   80e937 <_panic>
          tcp_output(pcb);
  80626c:	83 ec 0c             	sub    $0xc,%esp
  80626f:	53                   	push   %ebx
  806270:	e8 64 20 00 00       	call   8082d9 <tcp_output>
  806275:	83 c4 10             	add    $0x10,%esp
  806278:	e9 03 ff ff ff       	jmp    806180 <tcp_slowtmr+0x2b3>
  pcb = tcp_tw_pcbs;
  80627d:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  806283:	eb 48                	jmp    8062cd <tcp_slowtmr+0x400>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806285:	83 ec 04             	sub    $0x4,%esp
  806288:	68 1c 21 81 00       	push   $0x81211c
  80628d:	68 e5 02 00 00       	push   $0x2e5
  806292:	68 ce 21 81 00       	push   $0x8121ce
  806297:	e8 9b 86 00 00       	call   80e937 <_panic>
      tcp_pcb_purge(pcb);      
  80629c:	83 ec 0c             	sub    $0xc,%esp
  80629f:	56                   	push   %esi
  8062a0:	e8 0d f8 ff ff       	call   805ab2 <tcp_pcb_purge>
      if (prev != NULL) {
  8062a5:	83 c4 10             	add    $0x10,%esp
  8062a8:	85 db                	test   %ebx,%ebx
  8062aa:	74 58                	je     806304 <tcp_slowtmr+0x437>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8062ac:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  8062b2:	74 39                	je     8062ed <tcp_slowtmr+0x420>
        prev->next = pcb->next;
  8062b4:	8b 46 0c             	mov    0xc(%esi),%eax
  8062b7:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  8062ba:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  8062bd:	83 ec 08             	sub    $0x8,%esp
  8062c0:	56                   	push   %esi
  8062c1:	6a 02                	push   $0x2
  8062c3:	e8 d0 e3 ff ff       	call   804698 <memp_free>
  8062c8:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  8062cb:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  8062cd:	85 f6                	test   %esi,%esi
  8062cf:	74 5c                	je     80632d <tcp_slowtmr+0x460>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8062d1:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  8062d5:	75 ae                	jne    806285 <tcp_slowtmr+0x3b8>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8062d7:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8062dc:	2b 46 2c             	sub    0x2c(%esi),%eax
  8062df:	3d f0 00 00 00       	cmp    $0xf0,%eax
  8062e4:	77 b6                	ja     80629c <tcp_slowtmr+0x3cf>
      prev = pcb;
  8062e6:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  8062e8:	8b 76 0c             	mov    0xc(%esi),%esi
  8062eb:	eb e0                	jmp    8062cd <tcp_slowtmr+0x400>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8062ed:	83 ec 04             	sub    $0x4,%esp
  8062f0:	68 4c 21 81 00       	push   $0x81214c
  8062f5:	68 f4 02 00 00       	push   $0x2f4
  8062fa:	68 ce 21 81 00       	push   $0x8121ce
  8062ff:	e8 33 86 00 00       	call   80e937 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806304:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  80630a:	75 0a                	jne    806316 <tcp_slowtmr+0x449>
        tcp_tw_pcbs = pcb->next;
  80630c:	8b 46 0c             	mov    0xc(%esi),%eax
  80630f:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
  806314:	eb a4                	jmp    8062ba <tcp_slowtmr+0x3ed>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806316:	83 ec 04             	sub    $0x4,%esp
  806319:	68 74 21 81 00       	push   $0x812174
  80631e:	68 f8 02 00 00       	push   $0x2f8
  806323:	68 ce 21 81 00       	push   $0x8121ce
  806328:	e8 0a 86 00 00       	call   80e937 <_panic>
}
  80632d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806330:	5b                   	pop    %ebx
  806331:	5e                   	pop    %esi
  806332:	5f                   	pop    %edi
  806333:	5d                   	pop    %ebp
  806334:	c3                   	ret    

00806335 <tcp_tmr>:
{
  806335:	f3 0f 1e fb          	endbr32 
  806339:	55                   	push   %ebp
  80633a:	89 e5                	mov    %esp,%ebp
  80633c:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  80633f:	e8 b2 f5 ff ff       	call   8058f6 <tcp_fasttmr>
  if (++tcp_timer & 1) {
  806344:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  80634b:	83 c0 01             	add    $0x1,%eax
  80634e:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  806353:	a8 01                	test   $0x1,%al
  806355:	75 02                	jne    806359 <tcp_tmr+0x24>
}
  806357:	c9                   	leave  
  806358:	c3                   	ret    
    tcp_slowtmr();
  806359:	e8 6f fb ff ff       	call   805ecd <tcp_slowtmr>
}
  80635e:	eb f7                	jmp    806357 <tcp_tmr+0x22>

00806360 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  806360:	f3 0f 1e fb          	endbr32 
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806364:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806369:	03 05 08 40 81 00    	add    0x814008,%eax
  80636f:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  806374:	c3                   	ret    

00806375 <tcp_alloc>:
{
  806375:	f3 0f 1e fb          	endbr32 
  806379:	55                   	push   %ebp
  80637a:	89 e5                	mov    %esp,%ebp
  80637c:	57                   	push   %edi
  80637d:	56                   	push   %esi
  80637e:	53                   	push   %ebx
  80637f:	83 ec 28             	sub    $0x28,%esp
  806382:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  806386:	6a 02                	push   $0x2
  806388:	e8 b1 e2 ff ff       	call   80463e <memp_malloc>
  80638d:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  80638f:	83 c4 10             	add    $0x10,%esp
  806392:	85 c0                	test   %eax,%eax
  806394:	0f 84 a0 00 00 00    	je     80643a <tcp_alloc+0xc5>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  80639a:	83 ec 04             	sub    $0x4,%esp
  80639d:	68 a8 00 00 00       	push   $0xa8
  8063a2:	6a 00                	push   $0x0
  8063a4:	53                   	push   %ebx
  8063a5:	e8 30 8e 00 00       	call   80f1da <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  8063aa:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  8063ae:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  8063b4:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  8063ba:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  8063c0:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  8063c6:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  8063ca:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8063ce:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8063d4:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  8063da:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8063e0:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  8063e6:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  8063ec:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  8063f2:	e8 69 ff ff ff       	call   806360 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8063f7:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  8063fa:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  8063fd:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  806400:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  806403:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  806406:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80640b:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  80640e:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  806412:	c7 83 88 00 00 00 93 	movl   $0x805d93,0x88(%ebx)
  806419:	5d 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80641c:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  806423:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  806426:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  80642d:	83 c4 10             	add    $0x10,%esp
}
  806430:	89 d8                	mov    %ebx,%eax
  806432:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806435:	5b                   	pop    %ebx
  806436:	5e                   	pop    %esi
  806437:	5f                   	pop    %edi
  806438:	5d                   	pop    %ebp
  806439:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80643a:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80643f:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  inactivity = 0;
  806445:	b9 00 00 00 00       	mov    $0x0,%ecx
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80644a:	eb 03                	jmp    80644f <tcp_alloc+0xda>
  80644c:	8b 40 0c             	mov    0xc(%eax),%eax
  80644f:	85 c0                	test   %eax,%eax
  806451:	74 0f                	je     806462 <tcp_alloc+0xed>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806453:	89 fa                	mov    %edi,%edx
  806455:	2b 50 2c             	sub    0x2c(%eax),%edx
  806458:	39 ca                	cmp    %ecx,%edx
  80645a:	72 f0                	jb     80644c <tcp_alloc+0xd7>
      inactivity = tcp_ticks - pcb->tmr;
  80645c:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  80645e:	89 c3                	mov    %eax,%ebx
  806460:	eb ea                	jmp    80644c <tcp_alloc+0xd7>
  if (inactive != NULL) {
  806462:	85 db                	test   %ebx,%ebx
  806464:	74 0c                	je     806472 <tcp_alloc+0xfd>
    tcp_abort(inactive);
  806466:	83 ec 0c             	sub    $0xc,%esp
  806469:	53                   	push   %ebx
  80646a:	e8 64 f9 ff ff       	call   805dd3 <tcp_abort>
  80646f:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  806472:	83 ec 0c             	sub    $0xc,%esp
  806475:	6a 02                	push   $0x2
  806477:	e8 c2 e1 ff ff       	call   80463e <memp_malloc>
  80647c:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  80647e:	83 c4 10             	add    $0x10,%esp
  806481:	85 c0                	test   %eax,%eax
  806483:	0f 85 11 ff ff ff    	jne    80639a <tcp_alloc+0x25>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806489:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80648e:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  806494:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  806497:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  80649c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8064a3:	89 df                	mov    %ebx,%edi
  8064a5:	89 f1                	mov    %esi,%ecx
  8064a7:	88 4d e7             	mov    %cl,-0x19(%ebp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8064aa:	eb 03                	jmp    8064af <tcp_alloc+0x13a>
  8064ac:	8b 40 0c             	mov    0xc(%eax),%eax
  8064af:	85 c0                	test   %eax,%eax
  8064b1:	74 29                	je     8064dc <tcp_alloc+0x167>
    if (pcb->prio <= prio &&
  8064b3:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  8064b7:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  8064bb:	38 d3                	cmp    %dl,%bl
  8064bd:	89 d6                	mov    %edx,%esi
  8064bf:	0f 46 f3             	cmovbe %ebx,%esi
  8064c2:	89 f3                	mov    %esi,%ebx
  8064c4:	38 cb                	cmp    %cl,%bl
  8064c6:	72 e4                	jb     8064ac <tcp_alloc+0x137>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8064c8:	8b 75 dc             	mov    -0x24(%ebp),%esi
  8064cb:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  8064ce:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  8064d1:	72 d9                	jb     8064ac <tcp_alloc+0x137>
      mprio = pcb->prio;
  8064d3:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  8064d5:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  8064d8:	89 c7                	mov    %eax,%edi
  8064da:	eb d0                	jmp    8064ac <tcp_alloc+0x137>
  if (inactive != NULL) {
  8064dc:	85 ff                	test   %edi,%edi
  8064de:	74 0c                	je     8064ec <tcp_alloc+0x177>
    tcp_abort(inactive);
  8064e0:	83 ec 0c             	sub    $0xc,%esp
  8064e3:	57                   	push   %edi
  8064e4:	e8 ea f8 ff ff       	call   805dd3 <tcp_abort>
  8064e9:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  8064ec:	83 ec 0c             	sub    $0xc,%esp
  8064ef:	6a 02                	push   $0x2
  8064f1:	e8 48 e1 ff ff       	call   80463e <memp_malloc>
  8064f6:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  8064f8:	83 c4 10             	add    $0x10,%esp
  8064fb:	85 c0                	test   %eax,%eax
  8064fd:	0f 84 2d ff ff ff    	je     806430 <tcp_alloc+0xbb>
  806503:	e9 92 fe ff ff       	jmp    80639a <tcp_alloc+0x25>

00806508 <tcp_new>:
{
  806508:	f3 0f 1e fb          	endbr32 
  80650c:	55                   	push   %ebp
  80650d:	89 e5                	mov    %esp,%ebp
  80650f:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  806512:	6a 40                	push   $0x40
  806514:	e8 5c fe ff ff       	call   806375 <tcp_alloc>
}
  806519:	c9                   	leave  
  80651a:	c3                   	ret    

0080651b <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  80651b:	f3 0f 1e fb          	endbr32 
  80651f:	55                   	push   %ebp
  806520:	89 e5                	mov    %esp,%ebp
  806522:	56                   	push   %esi
  806523:	53                   	push   %ebx
  806524:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806527:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806529:	83 ec 0c             	sub    $0xc,%esp
  80652c:	ff 75 0c             	pushl  0xc(%ebp)
  80652f:	e8 ea 01 00 00       	call   80671e <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  806534:	83 c4 10             	add    $0x10,%esp
  806537:	85 c0                	test   %eax,%eax
  806539:	74 12                	je     80654d <tcp_eff_send_mss+0x32>
  80653b:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  80653f:	66 85 c0             	test   %ax,%ax
  806542:	74 09                	je     80654d <tcp_eff_send_mss+0x32>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  806544:	8d 70 d8             	lea    -0x28(%eax),%esi
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  806547:	66 39 f3             	cmp    %si,%bx
  80654a:	0f 46 f3             	cmovbe %ebx,%esi
  }
  return sendmss;
}
  80654d:	89 f0                	mov    %esi,%eax
  80654f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806552:	5b                   	pop    %ebx
  806553:	5e                   	pop    %esi
  806554:	5d                   	pop    %ebp
  806555:	c3                   	ret    

00806556 <tcp_connect>:
{
  806556:	f3 0f 1e fb          	endbr32 
  80655a:	55                   	push   %ebp
  80655b:	89 e5                	mov    %esp,%ebp
  80655d:	56                   	push   %esi
  80655e:	53                   	push   %ebx
  80655f:	83 ec 10             	sub    $0x10,%esp
  806562:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806565:	8b 75 0c             	mov    0xc(%ebp),%esi
  806568:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80656b:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80656f:	0f 85 9c 00 00 00    	jne    806611 <tcp_connect+0xbb>
  if (ipaddr != NULL) {
  806575:	85 f6                	test   %esi,%esi
  806577:	0f 84 53 01 00 00    	je     8066d0 <tcp_connect+0x17a>
    pcb->remote_ip = *ipaddr;
  80657d:	8b 16                	mov    (%esi),%edx
  80657f:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  806582:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  806586:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  80658b:	0f 84 97 00 00 00    	je     806628 <tcp_connect+0xd2>
  iss = tcp_next_iss();
  806591:	e8 ca fd ff ff       	call   806360 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806596:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  80659d:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  8065a0:	83 e8 01             	sub    $0x1,%eax
  8065a3:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8065a6:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8065a9:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  8065af:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  8065b5:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8065bb:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8065c1:	83 ec 08             	sub    $0x8,%esp
  8065c4:	56                   	push   %esi
  8065c5:	68 18 02 00 00       	push   $0x218
  8065ca:	e8 4c ff ff ff       	call   80651b <tcp_eff_send_mss>
  8065cf:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  8065d3:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8065d9:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8065dc:	01 c0                	add    %eax,%eax
  8065de:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8065e2:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  8065e9:	8b 45 14             	mov    0x14(%ebp),%eax
  8065ec:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8065f2:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8065f8:	83 c4 10             	add    $0x10,%esp
  8065fb:	39 da                	cmp    %ebx,%edx
  8065fd:	74 37                	je     806636 <tcp_connect+0xe0>
  8065ff:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806605:	b9 00 00 00 00       	mov    $0x0,%ecx
  80660a:	be 01 00 00 00       	mov    $0x1,%esi
  80660f:	eb 7d                	jmp    80668e <tcp_connect+0x138>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806611:	83 ec 04             	sub    $0x4,%esp
  806614:	68 9c 21 81 00       	push   $0x81219c
  806619:	68 ec 01 00 00       	push   $0x1ec
  80661e:	68 ce 21 81 00       	push   $0x8121ce
  806623:	e8 0f 83 00 00       	call   80e937 <_panic>
    pcb->local_port = tcp_new_port();
  806628:	e8 72 ef ff ff       	call   80559f <tcp_new_port>
  80662d:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  806631:	e9 5b ff ff ff       	jmp    806591 <tcp_connect+0x3b>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806636:	8b 43 0c             	mov    0xc(%ebx),%eax
  806639:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  TCP_REG(&tcp_active_pcbs, pcb);
  80663e:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  806643:	89 43 0c             	mov    %eax,0xc(%ebx)
  806646:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  80664c:	e8 f5 bc ff ff       	call   802346 <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  806651:	83 ec 0c             	sub    $0xc,%esp
  806654:	68 b4 05 04 02       	push   $0x20405b4
  806659:	e8 17 13 00 00       	call   807975 <htonl>
  80665e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806661:	83 c4 0c             	add    $0xc,%esp
  806664:	6a 04                	push   $0x4
  806666:	8d 45 f4             	lea    -0xc(%ebp),%eax
  806669:	50                   	push   %eax
  80666a:	6a 00                	push   $0x0
  80666c:	6a 02                	push   $0x2
  80666e:	6a 00                	push   $0x0
  806670:	6a 00                	push   $0x0
  806672:	53                   	push   %ebx
  806673:	e8 41 15 00 00       	call   807bb9 <tcp_enqueue>
  806678:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  80667a:	83 c4 20             	add    $0x20,%esp
  80667d:	84 c0                	test   %al,%al
  80667f:	74 41                	je     8066c2 <tcp_connect+0x16c>
} 
  806681:	89 f0                	mov    %esi,%eax
  806683:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806686:	5b                   	pop    %ebx
  806687:	5e                   	pop    %esi
  806688:	5d                   	pop    %ebp
  806689:	c3                   	ret    
  80668a:	89 f1                	mov    %esi,%ecx
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80668c:	89 c2                	mov    %eax,%edx
  80668e:	85 d2                	test   %edx,%edx
  806690:	74 1d                	je     8066af <tcp_connect+0x159>
  806692:	8b 42 0c             	mov    0xc(%edx),%eax
  806695:	39 d8                	cmp    %ebx,%eax
  806697:	75 f1                	jne    80668a <tcp_connect+0x134>
  806699:	85 c0                	test   %eax,%eax
  80669b:	74 ed                	je     80668a <tcp_connect+0x134>
  80669d:	84 c9                	test   %cl,%cl
  80669f:	74 06                	je     8066a7 <tcp_connect+0x151>
  8066a1:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8066a7:	8b 43 0c             	mov    0xc(%ebx),%eax
  8066aa:	89 42 0c             	mov    %eax,0xc(%edx)
  8066ad:	eb 8f                	jmp    80663e <tcp_connect+0xe8>
  8066af:	84 c9                	test   %cl,%cl
  8066b1:	74 8b                	je     80663e <tcp_connect+0xe8>
  8066b3:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8066ba:	00 00 00 
  8066bd:	e9 7c ff ff ff       	jmp    80663e <tcp_connect+0xe8>
    tcp_output(pcb);
  8066c2:	83 ec 0c             	sub    $0xc,%esp
  8066c5:	53                   	push   %ebx
  8066c6:	e8 0e 1c 00 00       	call   8082d9 <tcp_output>
  8066cb:	83 c4 10             	add    $0x10,%esp
  8066ce:	eb b1                	jmp    806681 <tcp_connect+0x12b>
    return ERR_VAL;
  8066d0:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  8066d5:	eb aa                	jmp    806681 <tcp_connect+0x12b>

008066d7 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  8066d7:	f3 0f 1e fb          	endbr32 
  8066db:	55                   	push   %ebp
  8066dc:	89 e5                	mov    %esp,%ebp
  8066de:	53                   	push   %ebx
  8066df:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  8066e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8066e5:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8066e7:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8066ea:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8066ef:	83 fb fd             	cmp    $0xfffffffd,%ebx
  8066f2:	77 27                	ja     80671b <ip_addr_isbroadcast+0x44>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8066f4:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  8066f8:	83 e0 02             	and    $0x2,%eax
  8066fb:	74 1e                	je     80671b <ip_addr_isbroadcast+0x44>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8066fd:	8b 59 04             	mov    0x4(%ecx),%ebx
    return 0;
  806700:	b8 00 00 00 00       	mov    $0x0,%eax
  else if (addr2test == netif->ip_addr.addr)
  806705:	39 d3                	cmp    %edx,%ebx
  806707:	74 12                	je     80671b <ip_addr_isbroadcast+0x44>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806709:	8b 49 08             	mov    0x8(%ecx),%ecx
  80670c:	31 d3                	xor    %edx,%ebx
  80670e:	85 cb                	test   %ecx,%ebx
  806710:	75 09                	jne    80671b <ip_addr_isbroadcast+0x44>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806712:	f7 d1                	not    %ecx
  806714:	21 ca                	and    %ecx,%edx
  806716:	39 ca                	cmp    %ecx,%edx
  806718:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  80671b:	5b                   	pop    %ebx
  80671c:	5d                   	pop    %ebp
  80671d:	c3                   	ret    

0080671e <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  80671e:	f3 0f 1e fb          	endbr32 
  806722:	55                   	push   %ebp
  806723:	89 e5                	mov    %esp,%ebp
  806725:	56                   	push   %esi
  806726:	53                   	push   %ebx
  806727:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80672a:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  806730:	eb 02                	jmp    806734 <ip_route+0x16>
  806732:	8b 1b                	mov    (%ebx),%ebx
  806734:	85 db                	test   %ebx,%ebx
  806736:	74 1c                	je     806754 <ip_route+0x36>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806738:	83 ec 0c             	sub    $0xc,%esp
  80673b:	53                   	push   %ebx
  80673c:	e8 f4 e1 ff ff       	call   804935 <netif_is_up>
  806741:	83 c4 10             	add    $0x10,%esp
  806744:	84 c0                	test   %al,%al
  806746:	74 ea                	je     806732 <ip_route+0x14>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  806748:	8b 06                	mov    (%esi),%eax
  80674a:	33 43 04             	xor    0x4(%ebx),%eax
  80674d:	85 43 08             	test   %eax,0x8(%ebx)
  806750:	75 e0                	jne    806732 <ip_route+0x14>
  806752:	eb 1e                	jmp    806772 <ip_route+0x54>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806754:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  806759:	85 c0                	test   %eax,%eax
  80675b:	74 1e                	je     80677b <ip_route+0x5d>
  80675d:	83 ec 0c             	sub    $0xc,%esp
  806760:	50                   	push   %eax
  806761:	e8 cf e1 ff ff       	call   804935 <netif_is_up>
  806766:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806769:	84 c0                	test   %al,%al
  80676b:	0f 45 1d 38 b2 b3 00 	cmovne 0xb3b238,%ebx
}
  806772:	89 d8                	mov    %ebx,%eax
  806774:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806777:	5b                   	pop    %ebx
  806778:	5e                   	pop    %esi
  806779:	5d                   	pop    %ebp
  80677a:	c3                   	ret    
    return NULL;
  80677b:	89 c3                	mov    %eax,%ebx
  80677d:	eb f3                	jmp    806772 <ip_route+0x54>

0080677f <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  80677f:	f3 0f 1e fb          	endbr32 
  806783:	55                   	push   %ebp
  806784:	89 e5                	mov    %esp,%ebp
  806786:	57                   	push   %edi
  806787:	56                   	push   %esi
  806788:	53                   	push   %ebx
  806789:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  80678c:	8b 45 08             	mov    0x8(%ebp),%eax
  80678f:	8b 78 04             	mov    0x4(%eax),%edi
  if (IPH_V(iphdr) != 4) {
  806792:	0f b7 07             	movzwl (%edi),%eax
  806795:	50                   	push   %eax
  806796:	e8 c9 11 00 00       	call   807964 <ntohs>
  80679b:	66 c1 e8 0c          	shr    $0xc,%ax
  80679f:	83 c4 10             	add    $0x10,%esp
  8067a2:	66 83 f8 04          	cmp    $0x4,%ax
  8067a6:	74 1b                	je     8067c3 <ip_input+0x44>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  8067a8:	83 ec 0c             	sub    $0xc,%esp
  8067ab:	ff 75 08             	pushl  0x8(%ebp)
  8067ae:	e8 68 e2 ff ff       	call   804a1b <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8067b3:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  8067b6:	b8 00 00 00 00       	mov    $0x0,%eax
  8067bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8067be:	5b                   	pop    %ebx
  8067bf:	5e                   	pop    %esi
  8067c0:	5f                   	pop    %edi
  8067c1:	5d                   	pop    %ebp
  8067c2:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  8067c3:	83 ec 0c             	sub    $0xc,%esp
  8067c6:	0f b7 07             	movzwl (%edi),%eax
  8067c9:	50                   	push   %eax
  8067ca:	e8 95 11 00 00       	call   807964 <ntohs>
  8067cf:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  8067d3:	83 e0 3c             	and    $0x3c,%eax
  8067d6:	89 c6                	mov    %eax,%esi
  8067d8:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  8067dc:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  8067e0:	89 04 24             	mov    %eax,(%esp)
  8067e3:	e8 7c 11 00 00       	call   807964 <ntohs>
  8067e8:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  8067ea:	83 c4 10             	add    $0x10,%esp
  8067ed:	8b 45 08             	mov    0x8(%ebp),%eax
  8067f0:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8067f4:	72 06                	jb     8067fc <ip_input+0x7d>
  8067f6:	66 39 58 08          	cmp    %bx,0x8(%eax)
  8067fa:	73 10                	jae    80680c <ip_input+0x8d>
    pbuf_free(p);
  8067fc:	83 ec 0c             	sub    $0xc,%esp
  8067ff:	ff 75 08             	pushl  0x8(%ebp)
  806802:	e8 14 e2 ff ff       	call   804a1b <pbuf_free>
    return ERR_OK;
  806807:	83 c4 10             	add    $0x10,%esp
  80680a:	eb aa                	jmp    8067b6 <ip_input+0x37>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  80680c:	83 ec 08             	sub    $0x8,%esp
  80680f:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806813:	50                   	push   %eax
  806814:	57                   	push   %edi
  806815:	e8 ff 0f 00 00       	call   807819 <inet_chksum>
  80681a:	83 c4 10             	add    $0x10,%esp
  80681d:	66 85 c0             	test   %ax,%ax
  806820:	75 27                	jne    806849 <ip_input+0xca>
  pbuf_realloc(p, iphdr_len);
  806822:	83 ec 08             	sub    $0x8,%esp
  806825:	0f b7 db             	movzwl %bx,%ebx
  806828:	53                   	push   %ebx
  806829:	ff 75 08             	pushl  0x8(%ebp)
  80682c:	e8 13 e5 ff ff       	call   804d44 <pbuf_realloc>
  806831:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  806834:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  806837:	be 01 00 00 00       	mov    $0x1,%esi
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80683c:	8d 47 10             	lea    0x10(%edi),%eax
  80683f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806842:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806845:	89 df                	mov    %ebx,%edi
  806847:	eb 2e                	jmp    806877 <ip_input+0xf8>
    pbuf_free(p);
  806849:	83 ec 0c             	sub    $0xc,%esp
  80684c:	ff 75 08             	pushl  0x8(%ebp)
  80684f:	e8 c7 e1 ff ff       	call   804a1b <pbuf_free>
    return ERR_OK;
  806854:	83 c4 10             	add    $0x10,%esp
  806857:	e9 5a ff ff ff       	jmp    8067b6 <ip_input+0x37>
      if (first) {
  80685c:	85 f6                	test   %esi,%esi
  80685e:	74 51                	je     8068b1 <ip_input+0x132>
        netif = netif_list;
  806860:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
      if (netif == inp) {
  806866:	39 df                	cmp    %ebx,%edi
  806868:	74 4b                	je     8068b5 <ip_input+0x136>
  80686a:	be 00 00 00 00       	mov    $0x0,%esi
    } while(netif != NULL);
  80686f:	85 db                	test   %ebx,%ebx
  806871:	0f 84 1b 01 00 00    	je     806992 <ip_input+0x213>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806877:	83 ec 0c             	sub    $0xc,%esp
  80687a:	53                   	push   %ebx
  80687b:	e8 b5 e0 ff ff       	call   804935 <netif_is_up>
  806880:	83 c4 10             	add    $0x10,%esp
  806883:	84 c0                	test   %al,%al
  806885:	74 d5                	je     80685c <ip_input+0xdd>
  806887:	8b 43 04             	mov    0x4(%ebx),%eax
  80688a:	85 c0                	test   %eax,%eax
  80688c:	74 ce                	je     80685c <ip_input+0xdd>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80688e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806891:	3b 41 10             	cmp    0x10(%ecx),%eax
  806894:	74 4a                	je     8068e0 <ip_input+0x161>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806896:	83 ec 08             	sub    $0x8,%esp
  806899:	53                   	push   %ebx
  80689a:	ff 75 dc             	pushl  -0x24(%ebp)
  80689d:	e8 35 fe ff ff       	call   8066d7 <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8068a2:	83 c4 10             	add    $0x10,%esp
  8068a5:	84 c0                	test   %al,%al
  8068a7:	74 b3                	je     80685c <ip_input+0xdd>
  8068a9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8068ac:	e9 fc 00 00 00       	jmp    8069ad <ip_input+0x22e>
        netif = netif->next;
  8068b1:	8b 1b                	mov    (%ebx),%ebx
  8068b3:	eb b1                	jmp    806866 <ip_input+0xe7>
        netif = netif->next;
  8068b5:	8b 1b                	mov    (%ebx),%ebx
  8068b7:	eb b1                	jmp    80686a <ip_input+0xeb>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8068b9:	83 ec 0c             	sub    $0xc,%esp
  8068bc:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8068c0:	0f b7 44 07 02       	movzwl 0x2(%edi,%eax,1),%eax
  8068c5:	50                   	push   %eax
  8068c6:	e8 99 10 00 00       	call   807964 <ntohs>
  8068cb:	83 c4 10             	add    $0x10,%esp
  8068ce:	66 83 f8 44          	cmp    $0x44,%ax
  8068d2:	0f 85 d5 00 00 00    	jne    8069ad <ip_input+0x22e>
        netif = inp;
  8068d8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8068db:	e9 10 01 00 00       	jmp    8069f0 <ip_input+0x271>
  8068e0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8068e3:	e9 c5 00 00 00       	jmp    8069ad <ip_input+0x22e>
      pbuf_free(p);
  8068e8:	83 ec 0c             	sub    $0xc,%esp
  8068eb:	ff 75 08             	pushl  0x8(%ebp)
  8068ee:	e8 28 e1 ff ff       	call   804a1b <pbuf_free>
      return ERR_OK;
  8068f3:	83 c4 10             	add    $0x10,%esp
  8068f6:	e9 bb fe ff ff       	jmp    8067b6 <ip_input+0x37>
    pbuf_free(p);
  8068fb:	83 ec 0c             	sub    $0xc,%esp
  8068fe:	ff 75 08             	pushl  0x8(%ebp)
  806901:	e8 15 e1 ff ff       	call   804a1b <pbuf_free>
    return ERR_OK;
  806906:	83 c4 10             	add    $0x10,%esp
  806909:	e9 a8 fe ff ff       	jmp    8067b6 <ip_input+0x37>
      udp_input(p, inp);
  80690e:	83 ec 08             	sub    $0x8,%esp
  806911:	ff 75 0c             	pushl  0xc(%ebp)
  806914:	ff 75 08             	pushl  0x8(%ebp)
  806917:	e8 ba 22 00 00       	call   808bd6 <udp_input>
      break;
  80691c:	83 c4 10             	add    $0x10,%esp
  80691f:	e9 92 fe ff ff       	jmp    8067b6 <ip_input+0x37>
      tcp_input(p, inp);
  806924:	83 ec 08             	sub    $0x8,%esp
  806927:	ff 75 0c             	pushl  0xc(%ebp)
  80692a:	ff 75 08             	pushl  0x8(%ebp)
  80692d:	e8 e5 6a 00 00       	call   80d417 <tcp_input>
      break;
  806932:	83 c4 10             	add    $0x10,%esp
  806935:	e9 7c fe ff ff       	jmp    8067b6 <ip_input+0x37>
      icmp_input(p, inp);
  80693a:	83 ec 08             	sub    $0x8,%esp
  80693d:	ff 75 0c             	pushl  0xc(%ebp)
  806940:	ff 75 08             	pushl  0x8(%ebp)
  806943:	e8 9b 7a 00 00       	call   80e3e3 <icmp_input>
      break;
  806948:	83 c4 10             	add    $0x10,%esp
  80694b:	e9 66 fe ff ff       	jmp    8067b6 <ip_input+0x37>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806950:	8b 5f 10             	mov    0x10(%edi),%ebx
  806953:	83 ec 0c             	sub    $0xc,%esp
  806956:	68 00 00 00 f0       	push   $0xf0000000
  80695b:	e8 42 12 00 00       	call   807ba2 <ntohl>
  806960:	21 c3                	and    %eax,%ebx
  806962:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806969:	e8 34 12 00 00       	call   807ba2 <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  80696e:	83 c4 10             	add    $0x10,%esp
  806971:	39 c3                	cmp    %eax,%ebx
  806973:	0f 84 19 01 00 00    	je     806a92 <ip_input+0x313>
        p->payload = iphdr;
  806979:	8b 45 08             	mov    0x8(%ebp),%eax
  80697c:	89 78 04             	mov    %edi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  80697f:	83 ec 08             	sub    $0x8,%esp
  806982:	6a 02                	push   $0x2
  806984:	50                   	push   %eax
  806985:	e8 77 7d 00 00       	call   80e701 <icmp_dest_unreach>
  80698a:	83 c4 10             	add    $0x10,%esp
  80698d:	e9 00 01 00 00       	jmp    806a92 <ip_input+0x313>
  806992:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806995:	83 ec 0c             	sub    $0xc,%esp
  806998:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80699c:	50                   	push   %eax
  80699d:	e8 c2 0f 00 00       	call   807964 <ntohs>
  8069a2:	83 c4 10             	add    $0x10,%esp
  8069a5:	3c 11                	cmp    $0x11,%al
  8069a7:	0f 84 0c ff ff ff    	je     8068b9 <ip_input+0x13a>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8069ad:	83 ec 08             	sub    $0x8,%esp
  8069b0:	ff 75 0c             	pushl  0xc(%ebp)
  8069b3:	8d 47 0c             	lea    0xc(%edi),%eax
  8069b6:	50                   	push   %eax
  8069b7:	e8 1b fd ff ff       	call   8066d7 <ip_addr_isbroadcast>
  8069bc:	83 c4 10             	add    $0x10,%esp
  8069bf:	84 c0                	test   %al,%al
  8069c1:	0f 85 21 ff ff ff    	jne    8068e8 <ip_input+0x169>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  8069c7:	8b 77 0c             	mov    0xc(%edi),%esi
  8069ca:	83 ec 0c             	sub    $0xc,%esp
  8069cd:	68 00 00 00 f0       	push   $0xf0000000
  8069d2:	e8 cb 11 00 00       	call   807ba2 <ntohl>
  8069d7:	21 c6                	and    %eax,%esi
  8069d9:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8069e0:	e8 bd 11 00 00       	call   807ba2 <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8069e5:	83 c4 10             	add    $0x10,%esp
  8069e8:	39 c6                	cmp    %eax,%esi
  8069ea:	0f 84 f8 fe ff ff    	je     8068e8 <ip_input+0x169>
  if (netif == NULL) {
  8069f0:	85 db                	test   %ebx,%ebx
  8069f2:	0f 84 03 ff ff ff    	je     8068fb <ip_input+0x17c>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  8069f8:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  8069fc:	83 ec 0c             	sub    $0xc,%esp
  8069ff:	68 ff 3f 00 00       	push   $0x3fff
  806a04:	e8 4a 0f 00 00       	call   807953 <htons>
  806a09:	83 c4 10             	add    $0x10,%esp
  806a0c:	66 85 c3             	test   %ax,%bx
  806a0f:	74 1c                	je     806a2d <ip_input+0x2ae>
    p = ip_reass(p);
  806a11:	83 ec 0c             	sub    $0xc,%esp
  806a14:	ff 75 08             	pushl  0x8(%ebp)
  806a17:	e8 8f 04 00 00       	call   806eab <ip_reass>
  806a1c:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  806a1f:	83 c4 10             	add    $0x10,%esp
  806a22:	85 c0                	test   %eax,%eax
  806a24:	0f 84 8c fd ff ff    	je     8067b6 <ip_input+0x37>
    iphdr = p->payload;
  806a2a:	8b 78 04             	mov    0x4(%eax),%edi
  if (raw_input(p, inp) == 0)
  806a2d:	83 ec 08             	sub    $0x8,%esp
  806a30:	ff 75 0c             	pushl  0xc(%ebp)
  806a33:	ff 75 08             	pushl  0x8(%ebp)
  806a36:	e8 df 76 00 00       	call   80e11a <raw_input>
  806a3b:	83 c4 10             	add    $0x10,%esp
  806a3e:	84 c0                	test   %al,%al
  806a40:	0f 85 70 fd ff ff    	jne    8067b6 <ip_input+0x37>
    switch (IPH_PROTO(iphdr)) {
  806a46:	83 ec 0c             	sub    $0xc,%esp
  806a49:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  806a4d:	50                   	push   %eax
  806a4e:	e8 11 0f 00 00       	call   807964 <ntohs>
  806a53:	89 c2                	mov    %eax,%edx
  806a55:	0f b6 c0             	movzbl %al,%eax
  806a58:	83 c4 10             	add    $0x10,%esp
  806a5b:	80 fa 06             	cmp    $0x6,%dl
  806a5e:	0f 84 c0 fe ff ff    	je     806924 <ip_input+0x1a5>
  806a64:	66 83 f8 11          	cmp    $0x11,%ax
  806a68:	0f 84 a0 fe ff ff    	je     80690e <ip_input+0x18f>
  806a6e:	66 83 f8 01          	cmp    $0x1,%ax
  806a72:	0f 84 c2 fe ff ff    	je     80693a <ip_input+0x1bb>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806a78:	83 ec 08             	sub    $0x8,%esp
  806a7b:	ff 75 0c             	pushl  0xc(%ebp)
  806a7e:	8d 47 10             	lea    0x10(%edi),%eax
  806a81:	50                   	push   %eax
  806a82:	e8 50 fc ff ff       	call   8066d7 <ip_addr_isbroadcast>
  806a87:	83 c4 10             	add    $0x10,%esp
  806a8a:	84 c0                	test   %al,%al
  806a8c:	0f 84 be fe ff ff    	je     806950 <ip_input+0x1d1>
      pbuf_free(p);
  806a92:	83 ec 0c             	sub    $0xc,%esp
  806a95:	ff 75 08             	pushl  0x8(%ebp)
  806a98:	e8 7e df ff ff       	call   804a1b <pbuf_free>
  806a9d:	83 c4 10             	add    $0x10,%esp
  806aa0:	e9 11 fd ff ff       	jmp    8067b6 <ip_input+0x37>

00806aa5 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806aa5:	f3 0f 1e fb          	endbr32 
  806aa9:	55                   	push   %ebp
  806aaa:	89 e5                	mov    %esp,%ebp
  806aac:	57                   	push   %edi
  806aad:	56                   	push   %esi
  806aae:	53                   	push   %ebx
  806aaf:	83 ec 1c             	sub    $0x1c,%esp
  806ab2:	8b 75 08             	mov    0x8(%ebp),%esi
  806ab5:	8b 7d 14             	mov    0x14(%ebp),%edi
  806ab8:	8b 45 18             	mov    0x18(%ebp),%eax
  806abb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806abe:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806ac1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806ac4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806ac8:	0f 84 37 01 00 00    	je     806c05 <ip_output_if+0x160>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806ace:	83 ec 08             	sub    $0x8,%esp
  806ad1:	6a 14                	push   $0x14
  806ad3:	56                   	push   %esi
  806ad4:	e8 6f de ff ff       	call   804948 <pbuf_header>
  806ad9:	83 c4 10             	add    $0x10,%esp
  806adc:	84 c0                	test   %al,%al
  806ade:	0f 85 40 01 00 00    	jne    806c24 <ip_output_if+0x17f>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806ae4:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806ae7:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806aec:	0f 86 f7 00 00 00    	jbe    806be9 <ip_output_if+0x144>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806af2:	83 ec 0c             	sub    $0xc,%esp
  806af5:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806af9:	50                   	push   %eax
  806afa:	e8 65 0e 00 00       	call   807964 <ntohs>
  806aff:	0f b6 c0             	movzbl %al,%eax
  806b02:	c1 e7 08             	shl    $0x8,%edi
  806b05:	09 c7                	or     %eax,%edi
  806b07:	0f b7 ff             	movzwl %di,%edi
  806b0a:	89 3c 24             	mov    %edi,(%esp)
  806b0d:	e8 41 0e 00 00       	call   807953 <htons>
  806b12:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806b16:	0f b7 c0             	movzwl %ax,%eax
  806b19:	89 04 24             	mov    %eax,(%esp)
  806b1c:	e8 43 0e 00 00       	call   807964 <ntohs>
  806b21:	89 c2                	mov    %eax,%edx
  806b23:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  806b29:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  806b2d:	09 d0                	or     %edx,%eax
  806b2f:	0f b7 c0             	movzwl %ax,%eax
  806b32:	89 04 24             	mov    %eax,(%esp)
  806b35:	e8 19 0e 00 00       	call   807953 <htons>
  806b3a:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806b3e:	8b 45 10             	mov    0x10(%ebp),%eax
  806b41:	8b 00                	mov    (%eax),%eax
  806b43:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806b46:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806b4a:	80 cc 45             	or     $0x45,%ah
  806b4d:	89 04 24             	mov    %eax,(%esp)
  806b50:	e8 fe 0d 00 00       	call   807953 <htons>
  806b55:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806b58:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806b5c:	89 04 24             	mov    %eax,(%esp)
  806b5f:	e8 ef 0d 00 00       	call   807953 <htons>
  806b64:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806b68:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806b6e:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  806b75:	89 04 24             	mov    %eax,(%esp)
  806b78:	e8 d6 0d 00 00       	call   807953 <htons>
  806b7d:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806b81:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  806b88:	01 

    if (ip_addr_isany(src)) {
  806b89:	83 c4 10             	add    $0x10,%esp
  806b8c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806b90:	74 09                	je     806b9b <ip_output_if+0xf6>
  806b92:	8b 45 0c             	mov    0xc(%ebp),%eax
  806b95:	8b 00                	mov    (%eax),%eax
  806b97:	85 c0                	test   %eax,%eax
  806b99:	75 65                	jne    806c00 <ip_output_if+0x15b>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806b9b:	8b 45 20             	mov    0x20(%ebp),%eax
  806b9e:	8b 40 04             	mov    0x4(%eax),%eax
  806ba1:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806ba4:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806baa:	83 ec 08             	sub    $0x8,%esp
  806bad:	6a 14                	push   $0x14
  806baf:	53                   	push   %ebx
  806bb0:	e8 64 0c 00 00       	call   807819 <inet_chksum>
  806bb5:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806bb9:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806bbc:	8b 45 20             	mov    0x20(%ebp),%eax
  806bbf:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806bc3:	66 85 c0             	test   %ax,%ax
  806bc6:	74 06                	je     806bce <ip_output_if+0x129>
  806bc8:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806bcc:	72 42                	jb     806c10 <ip_output_if+0x16b>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806bce:	83 ec 04             	sub    $0x4,%esp
  806bd1:	ff 75 10             	pushl  0x10(%ebp)
  806bd4:	56                   	push   %esi
  806bd5:	ff 75 20             	pushl  0x20(%ebp)
  806bd8:	8b 45 20             	mov    0x20(%ebp),%eax
  806bdb:	ff 50 14             	call   *0x14(%eax)
  806bde:	83 c4 10             	add    $0x10,%esp
  }
}
  806be1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806be4:	5b                   	pop    %ebx
  806be5:	5e                   	pop    %esi
  806be6:	5f                   	pop    %edi
  806be7:	5d                   	pop    %ebp
  806be8:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806be9:	83 ec 04             	sub    $0x4,%esp
  806bec:	68 6c 22 81 00       	push   $0x81226c
  806bf1:	68 ed 01 00 00       	push   $0x1ed
  806bf6:	68 99 22 81 00       	push   $0x812299
  806bfb:	e8 37 7d 00 00       	call   80e937 <_panic>
      ip_addr_set(&(iphdr->src), src);
  806c00:	89 43 0c             	mov    %eax,0xc(%ebx)
  806c03:	eb 9f                	jmp    806ba4 <ip_output_if+0xff>
    dest = &(iphdr->dest);
  806c05:	8b 46 04             	mov    0x4(%esi),%eax
  806c08:	83 c0 10             	add    $0x10,%eax
  806c0b:	89 45 10             	mov    %eax,0x10(%ebp)
  806c0e:	eb ac                	jmp    806bbc <ip_output_if+0x117>
    return ip_frag(p,netif,dest);
  806c10:	83 ec 04             	sub    $0x4,%esp
  806c13:	ff 75 10             	pushl  0x10(%ebp)
  806c16:	ff 75 20             	pushl  0x20(%ebp)
  806c19:	56                   	push   %esi
  806c1a:	e8 5f 07 00 00       	call   80737e <ip_frag>
  806c1f:	83 c4 10             	add    $0x10,%esp
  806c22:	eb bd                	jmp    806be1 <ip_output_if+0x13c>
      return ERR_BUF;
  806c24:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  806c29:	eb b6                	jmp    806be1 <ip_output_if+0x13c>

00806c2b <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806c2b:	f3 0f 1e fb          	endbr32 
  806c2f:	55                   	push   %ebp
  806c30:	89 e5                	mov    %esp,%ebp
  806c32:	57                   	push   %edi
  806c33:	56                   	push   %esi
  806c34:	53                   	push   %ebx
  806c35:	83 ec 18             	sub    $0x18,%esp
  806c38:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806c3b:	8b 75 18             	mov    0x18(%ebp),%esi
  806c3e:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806c41:	ff 75 10             	pushl  0x10(%ebp)
  806c44:	e8 d5 fa ff ff       	call   80671e <ip_route>
  806c49:	83 c4 10             	add    $0x10,%esp
  806c4c:	85 c0                	test   %eax,%eax
  806c4e:	74 2d                	je     806c7d <ip_output+0x52>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806c50:	83 ec 04             	sub    $0x4,%esp
  806c53:	50                   	push   %eax
  806c54:	89 f8                	mov    %edi,%eax
  806c56:	0f b6 f8             	movzbl %al,%edi
  806c59:	57                   	push   %edi
  806c5a:	89 f0                	mov    %esi,%eax
  806c5c:	0f b6 f0             	movzbl %al,%esi
  806c5f:	56                   	push   %esi
  806c60:	0f b6 db             	movzbl %bl,%ebx
  806c63:	53                   	push   %ebx
  806c64:	ff 75 10             	pushl  0x10(%ebp)
  806c67:	ff 75 0c             	pushl  0xc(%ebp)
  806c6a:	ff 75 08             	pushl  0x8(%ebp)
  806c6d:	e8 33 fe ff ff       	call   806aa5 <ip_output_if>
  806c72:	83 c4 20             	add    $0x20,%esp
}
  806c75:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806c78:	5b                   	pop    %ebx
  806c79:	5e                   	pop    %esi
  806c7a:	5f                   	pop    %edi
  806c7b:	5d                   	pop    %ebp
  806c7c:	c3                   	ret    
    return ERR_RTE;
  806c7d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806c82:	eb f1                	jmp    806c75 <ip_output+0x4a>

00806c84 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806c84:	55                   	push   %ebp
  806c85:	89 e5                	mov    %esp,%ebp
  806c87:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806c8a:	39 05 e0 49 b3 00    	cmp    %eax,0xb349e0
  806c90:	74 18                	je     806caa <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806c92:	85 d2                	test   %edx,%edx
  806c94:	74 1e                	je     806cb4 <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  806c96:	8b 08                	mov    (%eax),%ecx
  806c98:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806c9a:	83 ec 08             	sub    $0x8,%esp
  806c9d:	50                   	push   %eax
  806c9e:	6a 05                	push   $0x5
  806ca0:	e8 f3 d9 ff ff       	call   804698 <memp_free>
}
  806ca5:	83 c4 10             	add    $0x10,%esp
  806ca8:	c9                   	leave  
  806ca9:	c3                   	ret    
    reassdatagrams = ipr->next;
  806caa:	8b 10                	mov    (%eax),%edx
  806cac:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806cb2:	eb e6                	jmp    806c9a <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806cb4:	83 ec 04             	sub    $0x4,%esp
  806cb7:	68 b1 22 81 00       	push   $0x8122b1
  806cbc:	68 29 01 00 00       	push   $0x129
  806cc1:	68 ca 22 81 00       	push   $0x8122ca
  806cc6:	e8 6c 7c 00 00       	call   80e937 <_panic>

00806ccb <ip_reass_free_complete_datagram>:
{
  806ccb:	55                   	push   %ebp
  806ccc:	89 e5                	mov    %esp,%ebp
  806cce:	57                   	push   %edi
  806ccf:	56                   	push   %esi
  806cd0:	53                   	push   %ebx
  806cd1:	83 ec 1c             	sub    $0x1c,%esp
  806cd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806cd7:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806cda:	39 c2                	cmp    %eax,%edx
  806cdc:	74 2e                	je     806d0c <ip_reass_free_complete_datagram+0x41>
  if (prev != NULL) {
  806cde:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806ce1:	85 c0                	test   %eax,%eax
  806ce3:	74 07                	je     806cec <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806ce5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806ce8:	39 08                	cmp    %ecx,(%eax)
  806cea:	75 37                	jne    806d23 <ip_reass_free_complete_datagram+0x58>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806cec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806cef:	8b 58 04             	mov    0x4(%eax),%ebx
  806cf2:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806cf5:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806cfa:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806cff:	74 39                	je     806d3a <ip_reass_free_complete_datagram+0x6f>
  p = ipr->p;
  806d01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806d04:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806d07:	e9 8a 00 00 00       	jmp    806d96 <ip_reass_free_complete_datagram+0xcb>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806d0c:	83 ec 04             	sub    $0x4,%esp
  806d0f:	68 e7 22 81 00       	push   $0x8122e7
  806d14:	68 99 00 00 00       	push   $0x99
  806d19:	68 ca 22 81 00       	push   $0x8122ca
  806d1e:	e8 14 7c 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806d23:	83 ec 04             	sub    $0x4,%esp
  806d26:	68 f3 22 81 00       	push   $0x8122f3
  806d2b:	68 9b 00 00 00       	push   $0x9b
  806d30:	68 ca 22 81 00       	push   $0x8122ca
  806d35:	e8 fd 7b 00 00       	call   80e937 <_panic>
    ipr->p = iprh->next_pbuf;
  806d3a:	8b 00                	mov    (%eax),%eax
  806d3c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806d3f:	89 42 04             	mov    %eax,0x4(%edx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806d42:	83 ec 04             	sub    $0x4,%esp
  806d45:	6a 14                	push   $0x14
  806d47:	8d 42 08             	lea    0x8(%edx),%eax
  806d4a:	50                   	push   %eax
  806d4b:	ff 73 04             	pushl  0x4(%ebx)
  806d4e:	e8 39 85 00 00       	call   80f28c <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806d53:	83 c4 08             	add    $0x8,%esp
  806d56:	6a 01                	push   $0x1
  806d58:	53                   	push   %ebx
  806d59:	e8 8a 7a 00 00       	call   80e7e8 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806d5e:	89 1c 24             	mov    %ebx,(%esp)
  806d61:	e8 f4 e0 ff ff       	call   804e5a <pbuf_clen>
  806d66:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806d69:	89 1c 24             	mov    %ebx,(%esp)
  806d6c:	e8 aa dc ff ff       	call   804a1b <pbuf_free>
  806d71:	83 c4 10             	add    $0x10,%esp
  806d74:	eb 8b                	jmp    806d01 <ip_reass_free_complete_datagram+0x36>
    iprh = (struct ip_reass_helper *)p->payload;
  806d76:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806d79:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806d7b:	83 ec 0c             	sub    $0xc,%esp
  806d7e:	53                   	push   %ebx
  806d7f:	e8 d6 e0 ff ff       	call   804e5a <pbuf_clen>
  806d84:	0f b6 c0             	movzbl %al,%eax
  806d87:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806d89:	89 1c 24             	mov    %ebx,(%esp)
  806d8c:	e8 8a dc ff ff       	call   804a1b <pbuf_free>
  806d91:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806d94:	89 fb                	mov    %edi,%ebx
  while (p != NULL) {
  806d96:	85 db                	test   %ebx,%ebx
  806d98:	75 dc                	jne    806d76 <ip_reass_free_complete_datagram+0xab>
  ip_reass_dequeue_datagram(ipr, prev);
  806d9a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806d9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806da0:	e8 df fe ff ff       	call   806c84 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806da5:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806dac:	0f b7 d0             	movzwl %ax,%edx
  806daf:	39 f2                	cmp    %esi,%edx
  806db1:	7c 12                	jl     806dc5 <ip_reass_free_complete_datagram+0xfa>
  ip_reass_pbufcount -= pbufs_freed;
  806db3:	29 f0                	sub    %esi,%eax
  806db5:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc
}
  806dbb:	89 f0                	mov    %esi,%eax
  806dbd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806dc0:	5b                   	pop    %ebx
  806dc1:	5e                   	pop    %esi
  806dc2:	5f                   	pop    %edi
  806dc3:	5d                   	pop    %ebp
  806dc4:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806dc5:	83 ec 04             	sub    $0x4,%esp
  806dc8:	68 05 23 81 00       	push   $0x812305
  806dcd:	68 bc 00 00 00       	push   $0xbc
  806dd2:	68 ca 22 81 00       	push   $0x8122ca
  806dd7:	e8 5b 7b 00 00       	call   80e937 <_panic>

00806ddc <ip_reass_remove_oldest_datagram>:
{
  806ddc:	55                   	push   %ebp
  806ddd:	89 e5                	mov    %esp,%ebp
  806ddf:	57                   	push   %edi
  806de0:	56                   	push   %esi
  806de1:	53                   	push   %ebx
  806de2:	83 ec 1c             	sub    $0x1c,%esp
  806de5:	89 c6                	mov    %eax,%esi
  806de7:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806dea:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806df1:	eb 5b                	jmp    806e4e <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806df3:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  806df6:	85 c9                	test   %ecx,%ecx
  806df8:	74 33                	je     806e2d <ip_reass_remove_oldest_datagram+0x51>
          oldest = r;
  806dfa:	0f b6 51 1f          	movzbl 0x1f(%ecx),%edx
  806dfe:	38 50 1f             	cmp    %dl,0x1f(%eax)
  806e01:	0f 46 c8             	cmovbe %eax,%ecx
      if (r->next != NULL) {
  806e04:	8b 10                	mov    (%eax),%edx
        prev = r;
  806e06:	85 d2                	test   %edx,%edx
  806e08:	0f 45 f8             	cmovne %eax,%edi
  806e0b:	89 d0                	mov    %edx,%eax
    while (r != NULL) {
  806e0d:	85 c0                	test   %eax,%eax
  806e0f:	74 20                	je     806e31 <ip_reass_remove_oldest_datagram+0x55>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806e11:	8b 56 0c             	mov    0xc(%esi),%edx
  806e14:	39 50 14             	cmp    %edx,0x14(%eax)
  806e17:	75 da                	jne    806df3 <ip_reass_remove_oldest_datagram+0x17>
  806e19:	8b 56 10             	mov    0x10(%esi),%edx
  806e1c:	39 50 18             	cmp    %edx,0x18(%eax)
  806e1f:	75 d2                	jne    806df3 <ip_reass_remove_oldest_datagram+0x17>
  806e21:	0f b7 56 04          	movzwl 0x4(%esi),%edx
  806e25:	66 39 50 0c          	cmp    %dx,0xc(%eax)
  806e29:	75 c8                	jne    806df3 <ip_reass_remove_oldest_datagram+0x17>
  806e2b:	eb d7                	jmp    806e04 <ip_reass_remove_oldest_datagram+0x28>
          oldest = r;
  806e2d:	89 c1                	mov    %eax,%ecx
  806e2f:	eb d3                	jmp    806e04 <ip_reass_remove_oldest_datagram+0x28>
    if (oldest != NULL) {
  806e31:	85 c9                	test   %ecx,%ecx
  806e33:	74 0c                	je     806e41 <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806e35:	89 fa                	mov    %edi,%edx
  806e37:	89 c8                	mov    %ecx,%eax
  806e39:	e8 8d fe ff ff       	call   806ccb <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806e3e:	01 45 e4             	add    %eax,-0x1c(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806e41:	8b 7d e0             	mov    -0x20(%ebp),%edi
  806e44:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  806e47:	7d 1b                	jge    806e64 <ip_reass_remove_oldest_datagram+0x88>
  806e49:	83 fb 01             	cmp    $0x1,%ebx
  806e4c:	7e 16                	jle    806e64 <ip_reass_remove_oldest_datagram+0x88>
    r = reassdatagrams;
  806e4e:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
    other_datagrams = 0;
  806e53:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806e58:	bf 00 00 00 00       	mov    $0x0,%edi
    oldest = NULL;
  806e5d:	b9 00 00 00 00       	mov    $0x0,%ecx
    while (r != NULL) {
  806e62:	eb a9                	jmp    806e0d <ip_reass_remove_oldest_datagram+0x31>
}
  806e64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806e67:	83 c4 1c             	add    $0x1c,%esp
  806e6a:	5b                   	pop    %ebx
  806e6b:	5e                   	pop    %esi
  806e6c:	5f                   	pop    %edi
  806e6d:	5d                   	pop    %ebp
  806e6e:	c3                   	ret    

00806e6f <ip_reass_tmr>:
{
  806e6f:	f3 0f 1e fb          	endbr32 
  806e73:	55                   	push   %ebp
  806e74:	89 e5                	mov    %esp,%ebp
  806e76:	56                   	push   %esi
  806e77:	53                   	push   %ebx
  r = reassdatagrams;
  806e78:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  struct ip_reassdata *r, *prev = NULL;
  806e7d:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806e82:	eb 0b                	jmp    806e8f <ip_reass_tmr+0x20>
      r = r->next;
  806e84:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806e86:	89 da                	mov    %ebx,%edx
  806e88:	e8 3e fe ff ff       	call   806ccb <ip_reass_free_complete_datagram>
      r = r->next;
  806e8d:	89 f0                	mov    %esi,%eax
  while (r != NULL) {
  806e8f:	85 c0                	test   %eax,%eax
  806e91:	74 14                	je     806ea7 <ip_reass_tmr+0x38>
    if (r->timer > 0) {
  806e93:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806e97:	84 d2                	test   %dl,%dl
  806e99:	74 e9                	je     806e84 <ip_reass_tmr+0x15>
      r->timer--;
  806e9b:	83 ea 01             	sub    $0x1,%edx
  806e9e:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806ea1:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806ea3:	8b 00                	mov    (%eax),%eax
  806ea5:	eb e8                	jmp    806e8f <ip_reass_tmr+0x20>
}
  806ea7:	5b                   	pop    %ebx
  806ea8:	5e                   	pop    %esi
  806ea9:	5d                   	pop    %ebp
  806eaa:	c3                   	ret    

00806eab <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806eab:	f3 0f 1e fb          	endbr32 
  806eaf:	55                   	push   %ebp
  806eb0:	89 e5                	mov    %esp,%ebp
  806eb2:	57                   	push   %edi
  806eb3:	56                   	push   %esi
  806eb4:	53                   	push   %ebx
  806eb5:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806eb8:	8b 45 08             	mov    0x8(%ebp),%eax
  806ebb:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806ebe:	0f b7 03             	movzwl (%ebx),%eax
  806ec1:	50                   	push   %eax
  806ec2:	e8 9d 0a 00 00       	call   807964 <ntohs>
  806ec7:	66 c1 e8 08          	shr    $0x8,%ax
  806ecb:	83 e0 0f             	and    $0xf,%eax
  806ece:	83 c4 10             	add    $0x10,%esp
  806ed1:	83 f8 05             	cmp    $0x5,%eax
  806ed4:	0f 85 de 01 00 00    	jne    8070b8 <ip_reass+0x20d>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806eda:	83 ec 0c             	sub    $0xc,%esp
  806edd:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806ee1:	50                   	push   %eax
  806ee2:	e8 7d 0a 00 00       	call   807964 <ntohs>
  806ee7:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806eeb:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806eef:	89 04 24             	mov    %eax,(%esp)
  806ef2:	e8 6d 0a 00 00       	call   807964 <ntohs>
  806ef7:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806efb:	0f b7 03             	movzwl (%ebx),%eax
  806efe:	89 04 24             	mov    %eax,(%esp)
  806f01:	e8 5e 0a 00 00       	call   807964 <ntohs>
  806f06:	66 89 45 d8          	mov    %ax,-0x28(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806f0a:	83 c4 04             	add    $0x4,%esp
  806f0d:	ff 75 08             	pushl  0x8(%ebp)
  806f10:	e8 45 df ff ff       	call   804e5a <pbuf_clen>
  806f15:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806f18:	0f b6 f0             	movzbl %al,%esi
  806f1b:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806f22:	01 f0                	add    %esi,%eax
  806f24:	83 c4 10             	add    $0x10,%esp
  806f27:	83 f8 0a             	cmp    $0xa,%eax
  806f2a:	7f 0d                	jg     806f39 <ip_reass+0x8e>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806f2c:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806f32:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806f37:	eb 28                	jmp    806f61 <ip_reass+0xb6>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806f39:	89 f2                	mov    %esi,%edx
  806f3b:	89 d8                	mov    %ebx,%eax
  806f3d:	e8 9a fe ff ff       	call   806ddc <ip_reass_remove_oldest_datagram>
  806f42:	85 c0                	test   %eax,%eax
  806f44:	0f 84 6e 01 00 00    	je     8070b8 <ip_reass+0x20d>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806f4a:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806f51:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806f53:	83 f8 0a             	cmp    $0xa,%eax
  806f56:	7e d4                	jle    806f2c <ip_reass+0x81>
  806f58:	e9 5b 01 00 00       	jmp    8070b8 <ip_reass+0x20d>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806f5d:	89 f8                	mov    %edi,%eax
  806f5f:	8b 3f                	mov    (%edi),%edi
  806f61:	85 ff                	test   %edi,%edi
  806f63:	0f 84 f7 00 00 00    	je     807060 <ip_reass+0x1b5>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806f69:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806f6c:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806f6f:	75 ec                	jne    806f5d <ip_reass+0xb2>
  806f71:	8b 53 10             	mov    0x10(%ebx),%edx
  806f74:	39 57 18             	cmp    %edx,0x18(%edi)
  806f77:	75 e4                	jne    806f5d <ip_reass+0xb2>
  806f79:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
  806f7d:	66 39 57 0c          	cmp    %dx,0xc(%edi)
  806f81:	75 da                	jne    806f5d <ip_reass+0xb2>
  806f83:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806f86:	83 ec 0c             	sub    $0xc,%esp
  806f89:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806f8d:	50                   	push   %eax
  806f8e:	e8 d1 09 00 00       	call   807964 <ntohs>
  806f93:	83 c4 10             	add    $0x10,%esp
  806f96:	66 a9 ff 1f          	test   $0x1fff,%ax
  806f9a:	0f 84 4d 01 00 00    	je     8070ed <ip_reass+0x242>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806fa0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806fa4:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806fab:	83 ec 0c             	sub    $0xc,%esp
  806fae:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806fb2:	50                   	push   %eax
  806fb3:	e8 ac 09 00 00       	call   807964 <ntohs>
  806fb8:	83 c4 10             	add    $0x10,%esp
  806fbb:	f6 c4 20             	test   $0x20,%ah
  806fbe:	75 20                	jne    806fe0 <ip_reass+0x135>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806fc0:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806fc4:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806fc8:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  806fcc:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806fcf:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  806fd3:	66 c1 ea 06          	shr    $0x6,%dx
  806fd7:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806fda:	29 d0                	sub    %edx,%eax
  806fdc:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806fe0:	8b 45 08             	mov    0x8(%ebp),%eax
  806fe3:	8b 70 04             	mov    0x4(%eax),%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806fe6:	83 ec 0c             	sub    $0xc,%esp
  806fe9:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806fed:	50                   	push   %eax
  806fee:	e8 71 09 00 00       	call   807964 <ntohs>
  806ff3:	89 c3                	mov    %eax,%ebx
  806ff5:	0f b7 06             	movzwl (%esi),%eax
  806ff8:	89 04 24             	mov    %eax,(%esp)
  806ffb:	e8 64 09 00 00       	call   807964 <ntohs>
  807000:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  807004:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  807008:	89 04 24             	mov    %eax,(%esp)
  80700b:	e8 54 09 00 00       	call   807964 <ntohs>
  807010:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
  iprh = (struct ip_reass_helper*)new_p->payload;
  807017:	8b 55 08             	mov    0x8(%ebp),%edx
  80701a:	8b 72 04             	mov    0x4(%edx),%esi
  80701d:	89 75 e0             	mov    %esi,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  807020:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  iprh->start = offset;
  807026:	66 89 4e 04          	mov    %cx,0x4(%esi)
  iprh->end = offset + len;
  80702a:	01 cb                	add    %ecx,%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80702c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807030:	66 c1 e8 06          	shr    $0x6,%ax
  807034:	83 e0 3c             	and    $0x3c,%eax
  iprh->end = offset + len;
  807037:	29 c3                	sub    %eax,%ebx
  807039:	66 89 5d de          	mov    %bx,-0x22(%ebp)
  80703d:	66 89 5e 06          	mov    %bx,0x6(%esi)
  for (q = ipr->p; q != NULL;) {
  807041:	8b 47 04             	mov    0x4(%edi),%eax
  807044:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807047:	83 c4 10             	add    $0x10,%esp
  80704a:	89 c3                	mov    %eax,%ebx
  int valid = 1;
  80704c:	b8 01 00 00 00       	mov    $0x1,%eax
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  807051:	be 00 00 00 00       	mov    $0x0,%esi
  807056:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  807059:	89 c7                	mov    %eax,%edi
  for (q = ipr->p; q != NULL;) {
  80705b:	e9 25 01 00 00       	jmp    807185 <ip_reass+0x2da>
  807060:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  ipr = memp_malloc(MEMP_REASSDATA);
  807063:	83 ec 0c             	sub    $0xc,%esp
  807066:	6a 05                	push   $0x5
  807068:	e8 d1 d5 ff ff       	call   80463e <memp_malloc>
  80706d:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  80706f:	83 c4 10             	add    $0x10,%esp
  807072:	85 c0                	test   %eax,%eax
  807074:	74 35                	je     8070ab <ip_reass+0x200>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  807076:	83 ec 04             	sub    $0x4,%esp
  807079:	6a 20                	push   $0x20
  80707b:	6a 00                	push   $0x0
  80707d:	57                   	push   %edi
  80707e:	e8 57 81 00 00       	call   80f1da <memset>
  ipr->timer = IP_REASS_MAXAGE;
  807083:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  807087:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  80708c:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  80708e:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  807094:	83 c4 0c             	add    $0xc,%esp
  807097:	6a 14                	push   $0x14
  807099:	53                   	push   %ebx
  80709a:	8d 47 08             	lea    0x8(%edi),%eax
  80709d:	50                   	push   %eax
  80709e:	e8 e9 81 00 00       	call   80f28c <memcpy>
  8070a3:	83 c4 10             	add    $0x10,%esp
  8070a6:	e9 f5 fe ff ff       	jmp    806fa0 <ip_reass+0xf5>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  8070ab:	89 f2                	mov    %esi,%edx
  8070ad:	89 d8                	mov    %ebx,%eax
  8070af:	e8 28 fd ff ff       	call   806ddc <ip_reass_remove_oldest_datagram>
  8070b4:	39 c6                	cmp    %eax,%esi
  8070b6:	7e 20                	jle    8070d8 <ip_reass+0x22d>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  8070b8:	83 ec 0c             	sub    $0xc,%esp
  8070bb:	ff 75 08             	pushl  0x8(%ebp)
  8070be:	e8 58 d9 ff ff       	call   804a1b <pbuf_free>
  return NULL;
  8070c3:	83 c4 10             	add    $0x10,%esp
  8070c6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  8070cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8070d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8070d3:	5b                   	pop    %ebx
  8070d4:	5e                   	pop    %esi
  8070d5:	5f                   	pop    %edi
  8070d6:	5d                   	pop    %ebp
  8070d7:	c3                   	ret    
      ipr = memp_malloc(MEMP_REASSDATA);
  8070d8:	83 ec 0c             	sub    $0xc,%esp
  8070db:	6a 05                	push   $0x5
  8070dd:	e8 5c d5 ff ff       	call   80463e <memp_malloc>
  8070e2:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  8070e4:	83 c4 10             	add    $0x10,%esp
  8070e7:	85 c0                	test   %eax,%eax
  8070e9:	75 8b                	jne    807076 <ip_reass+0x1cb>
  8070eb:	eb cb                	jmp    8070b8 <ip_reass+0x20d>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  8070ed:	83 ec 0c             	sub    $0xc,%esp
  8070f0:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  8070f4:	50                   	push   %eax
  8070f5:	e8 6a 08 00 00       	call   807964 <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8070fa:	83 c4 10             	add    $0x10,%esp
  8070fd:	66 a9 ff 1f          	test   $0x1fff,%ax
  807101:	0f 84 99 fe ff ff    	je     806fa0 <ip_reass+0xf5>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  807107:	83 ec 04             	sub    $0x4,%esp
  80710a:	6a 14                	push   $0x14
  80710c:	53                   	push   %ebx
  80710d:	8d 47 08             	lea    0x8(%edi),%eax
  807110:	50                   	push   %eax
  807111:	e8 76 81 00 00       	call   80f28c <memcpy>
  807116:	83 c4 10             	add    $0x10,%esp
  807119:	e9 82 fe ff ff       	jmp    806fa0 <ip_reass+0xf5>
  80711e:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807121:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      iprh->next_pbuf = q;
  807124:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807127:	89 1a                	mov    %ebx,(%edx)
      if (iprh_prev != NULL) {
  807129:	85 f6                	test   %esi,%esi
  80712b:	74 4c                	je     807179 <ip_reass+0x2ce>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80712d:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  807131:	0f 82 9f 01 00 00    	jb     8072d6 <ip_reass+0x42b>
  807137:	0f b7 4d de          	movzwl -0x22(%ebp),%ecx
  80713b:	66 3b 48 04          	cmp    0x4(%eax),%cx
  80713f:	0f 87 91 01 00 00    	ja     8072d6 <ip_reass+0x42b>
        iprh_prev->next_pbuf = new_p;
  807145:	8b 45 08             	mov    0x8(%ebp),%eax
  807148:	89 06                	mov    %eax,(%esi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80714a:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  80714e:	0f 84 a5 01 00 00    	je     8072f9 <ip_reass+0x44e>
    if (valid) {
  807154:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  807158:	0f 84 9b 01 00 00    	je     8072f9 <ip_reass+0x44e>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80715e:	8b 4f 04             	mov    0x4(%edi),%ecx
  807161:	8b 59 04             	mov    0x4(%ecx),%ebx
  807164:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  807169:	0f 85 8a 01 00 00    	jne    8072f9 <ip_reass+0x44e>
        q = iprh->next_pbuf;
  80716f:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807172:	8b 16                	mov    (%esi),%edx
        while (q != NULL) {
  807174:	e9 85 00 00 00       	jmp    8071fe <ip_reass+0x353>
        ipr->p = new_p;
  807179:	8b 45 08             	mov    0x8(%ebp),%eax
  80717c:	89 47 04             	mov    %eax,0x4(%edi)
  80717f:	eb c9                	jmp    80714a <ip_reass+0x29f>
    q = iprh_tmp->next_pbuf;
  807181:	8b 18                	mov    (%eax),%ebx
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  807183:	89 c6                	mov    %eax,%esi
  for (q = ipr->p; q != NULL;) {
  807185:	85 db                	test   %ebx,%ebx
  807187:	0f 84 c3 01 00 00    	je     807350 <ip_reass+0x4a5>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80718d:	8b 43 04             	mov    0x4(%ebx),%eax
    if (iprh->start < iprh_tmp->start) {
  807190:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  807194:	66 39 d1             	cmp    %dx,%cx
  807197:	72 85                	jb     80711e <ip_reass+0x273>
    } else if(iprh->start == iprh_tmp->start) {
  807199:	0f 84 37 01 00 00    	je     8072d6 <ip_reass+0x42b>
    } else if(iprh->start < iprh_tmp->end) {
  80719f:	66 3b 48 06          	cmp    0x6(%eax),%cx
  8071a3:	0f 82 2d 01 00 00    	jb     8072d6 <ip_reass+0x42b>
      if (iprh_prev != NULL) {
  8071a9:	85 f6                	test   %esi,%esi
  8071ab:	74 d4                	je     807181 <ip_reass+0x2d6>
          valid = 0;
  8071ad:	66 3b 56 06          	cmp    0x6(%esi),%dx
  8071b1:	ba 00 00 00 00       	mov    $0x0,%edx
  8071b6:	0f 45 fa             	cmovne %edx,%edi
  8071b9:	eb c6                	jmp    807181 <ip_reass+0x2d6>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8071bb:	83 ec 04             	sub    $0x4,%esp
  8071be:	68 20 23 81 00       	push   $0x812320
  8071c3:	68 83 01 00 00       	push   $0x183
  8071c8:	68 ca 22 81 00       	push   $0x8122ca
  8071cd:	e8 65 77 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  8071d2:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  8071d6:	75 0b                	jne    8071e3 <ip_reass+0x338>
      ipr->p = new_p;
  8071d8:	8b 45 08             	mov    0x8(%ebp),%eax
  8071db:	89 47 04             	mov    %eax,0x4(%edi)
  8071de:	e9 67 ff ff ff       	jmp    80714a <ip_reass+0x29f>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  8071e3:	83 ec 04             	sub    $0x4,%esp
  8071e6:	68 4c 23 81 00       	push   $0x81234c
  8071eb:	68 8b 01 00 00       	push   $0x18b
  8071f0:	68 ca 22 81 00       	push   $0x8122ca
  8071f5:	e8 3d 77 00 00       	call   80e937 <_panic>
          q = iprh->next_pbuf;
  8071fa:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  8071fc:	89 c6                	mov    %eax,%esi
        while (q != NULL) {
  8071fe:	85 d2                	test   %edx,%edx
  807200:	74 12                	je     807214 <ip_reass+0x369>
          iprh = (struct ip_reass_helper*)q->payload;
  807202:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  807205:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  807209:	66 39 56 06          	cmp    %dx,0x6(%esi)
  80720d:	74 eb                	je     8071fa <ip_reass+0x34f>
  80720f:	e9 e5 00 00 00       	jmp    8072f9 <ip_reass+0x44e>
  807214:	89 75 e0             	mov    %esi,-0x20(%ebp)
          LWIP_ASSERT("sanity check",
  807217:	39 f3                	cmp    %esi,%ebx
  807219:	74 76                	je     807291 <ip_reass+0x3e6>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80721b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80721e:	83 38 00             	cmpl   $0x0,(%eax)
  807221:	0f 85 81 00 00 00    	jne    8072a8 <ip_reass+0x3fd>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807227:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80722b:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80722e:	66 39 46 06          	cmp    %ax,0x6(%esi)
  807232:	0f 85 87 00 00 00    	jne    8072bf <ip_reass+0x414>
    ipr->datagram_len += IP_HLEN;
  807238:	83 c0 14             	add    $0x14,%eax
  80723b:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80723f:	8b 71 04             	mov    0x4(%ecx),%esi
  807242:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  807244:	83 ec 04             	sub    $0x4,%esp
  807247:	6a 14                	push   $0x14
  807249:	8d 47 08             	lea    0x8(%edi),%eax
  80724c:	50                   	push   %eax
  80724d:	56                   	push   %esi
  80724e:	e8 39 80 00 00       	call   80f28c <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  807253:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807257:	89 04 24             	mov    %eax,(%esp)
  80725a:	e8 f4 06 00 00       	call   807953 <htons>
  80725f:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  807263:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  807269:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80726f:	83 c4 08             	add    $0x8,%esp
  807272:	6a 14                	push   $0x14
  807274:	56                   	push   %esi
  807275:	e8 9f 05 00 00       	call   807819 <inet_chksum>
  80727a:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  80727e:	8b 47 04             	mov    0x4(%edi),%eax
  807281:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  807284:	83 c4 10             	add    $0x10,%esp
  807287:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80728a:	89 c7                	mov    %eax,%edi
  80728c:	e9 91 00 00 00       	jmp    807322 <ip_reass+0x477>
          LWIP_ASSERT("sanity check",
  807291:	83 ec 04             	sub    $0x4,%esp
  807294:	68 3e 23 81 00       	push   $0x81233e
  807299:	68 ad 01 00 00       	push   $0x1ad
  80729e:	68 ca 22 81 00       	push   $0x8122ca
  8072a3:	e8 8f 76 00 00       	call   80e937 <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8072a8:	83 ec 04             	sub    $0x4,%esp
  8072ab:	68 84 23 81 00       	push   $0x812384
  8072b0:	68 af 01 00 00       	push   $0x1af
  8072b5:	68 ca 22 81 00       	push   $0x8122ca
  8072ba:	e8 78 76 00 00       	call   80e937 <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8072bf:	83 ec 04             	sub    $0x4,%esp
  8072c2:	68 a8 23 81 00       	push   $0x8123a8
  8072c7:	68 b1 01 00 00       	push   $0x1b1
  8072cc:	68 ca 22 81 00       	push   $0x8122ca
  8072d1:	e8 61 76 00 00       	call   80e937 <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  8072d6:	83 ec 0c             	sub    $0xc,%esp
  8072d9:	ff 75 08             	pushl  0x8(%ebp)
  8072dc:	e8 79 db ff ff       	call   804e5a <pbuf_clen>
  8072e1:	0f b6 c0             	movzbl %al,%eax
  8072e4:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  8072eb:	83 c4 04             	add    $0x4,%esp
  8072ee:	ff 75 08             	pushl  0x8(%ebp)
  8072f1:	e8 25 d7 ff ff       	call   804a1b <pbuf_free>
  return 0;
  8072f6:	83 c4 10             	add    $0x10,%esp
  return NULL;
  8072f9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  807300:	e9 c8 fd ff ff       	jmp    8070cd <ip_reass+0x222>
      iprh = (struct ip_reass_helper*)r->payload;
  807305:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  807308:	83 ec 08             	sub    $0x8,%esp
  80730b:	6a ec                	push   $0xffffffec
  80730d:	53                   	push   %ebx
  80730e:	e8 35 d6 ff ff       	call   804948 <pbuf_header>
      pbuf_cat(p, r);
  807313:	83 c4 08             	add    $0x8,%esp
  807316:	53                   	push   %ebx
  807317:	57                   	push   %edi
  807318:	e8 70 db ff ff       	call   804e8d <pbuf_cat>
      r = iprh->next_pbuf;
  80731d:	8b 1e                	mov    (%esi),%ebx
  80731f:	83 c4 10             	add    $0x10,%esp
    while(r != NULL) {
  807322:	85 db                	test   %ebx,%ebx
  807324:	75 df                	jne    807305 <ip_reass+0x45a>
  807326:	8b 7d e0             	mov    -0x20(%ebp),%edi
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  807329:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80732c:	89 f8                	mov    %edi,%eax
  80732e:	e8 51 f9 ff ff       	call   806c84 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  807333:	83 ec 0c             	sub    $0xc,%esp
  807336:	ff 75 e4             	pushl  -0x1c(%ebp)
  807339:	e8 1c db ff ff       	call   804e5a <pbuf_clen>
  80733e:	0f b6 c0             	movzbl %al,%eax
  807341:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
    return p;
  807348:	83 c4 10             	add    $0x10,%esp
  80734b:	e9 7d fd ff ff       	jmp    8070cd <ip_reass+0x222>
  807350:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807353:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  807356:	85 f6                	test   %esi,%esi
  807358:	0f 84 74 fe ff ff    	je     8071d2 <ip_reass+0x327>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  80735e:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  807362:	66 39 c1             	cmp    %ax,%cx
  807365:	0f 82 50 fe ff ff    	jb     8071bb <ip_reass+0x310>
      iprh_prev->next_pbuf = new_p;
  80736b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80736e:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  807370:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807373:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  807377:	75 80                	jne    8072f9 <ip_reass+0x44e>
  807379:	e9 cc fd ff ff       	jmp    80714a <ip_reass+0x29f>

0080737e <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  80737e:	f3 0f 1e fb          	endbr32 
  807382:	55                   	push   %ebp
  807383:	89 e5                	mov    %esp,%ebp
  807385:	57                   	push   %edi
  807386:	56                   	push   %esi
  807387:	53                   	push   %ebx
  807388:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  80738b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80738e:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807392:	6a 02                	push   $0x2
  807394:	6a 00                	push   $0x0
  807396:	6a 02                	push   $0x2
  807398:	e8 48 d7 ff ff       	call   804ae5 <pbuf_alloc>
  80739d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  8073a0:	83 c4 10             	add    $0x10,%esp
  8073a3:	85 c0                	test   %eax,%eax
  8073a5:	0f 84 c2 00 00 00    	je     80746d <ip_frag+0xef>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8073ab:	66 89 58 0a          	mov    %bx,0xa(%eax)
  8073af:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8073b3:	be 03 44 b3 00       	mov    $0xb34403,%esi
  8073b8:	83 e6 fc             	and    $0xfffffffc,%esi
  8073bb:	89 70 04             	mov    %esi,0x4(%eax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8073be:	83 ec 04             	sub    $0x4,%esp
  8073c1:	6a 14                	push   $0x14
  8073c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8073c6:	ff 70 04             	pushl  0x4(%eax)
  8073c9:	56                   	push   %esi
  8073ca:	e8 bd 7e 00 00       	call   80f28c <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8073cf:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  8073d3:	89 04 24             	mov    %eax,(%esp)
  8073d6:	e8 89 05 00 00       	call   807964 <ntohs>
  ofo = tmp & IP_OFFMASK;
  8073db:	89 c7                	mov    %eax,%edi
  8073dd:	66 81 e7 ff 1f       	and    $0x1fff,%di
  8073e2:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
  omf = tmp & IP_MF;
  8073e6:	66 25 00 20          	and    $0x2000,%ax
  8073ea:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;
  8073ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8073f1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8073f5:	8d 78 ec             	lea    -0x14(%eax),%edi

  nfb = (mtu - IP_HLEN) / 8;
  8073f8:	0f b7 db             	movzwl %bx,%ebx
  8073fb:	8d 43 f3             	lea    -0xd(%ebx),%eax
  8073fe:	83 c4 10             	add    $0x10,%esp
  807401:	89 da                	mov    %ebx,%edx
  807403:	83 ea 14             	sub    $0x14,%edx
  807406:	0f 49 c2             	cmovns %edx,%eax
  807409:	c1 f8 03             	sar    $0x3,%eax
  80740c:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807410:	c1 e0 03             	shl    $0x3,%eax
  807413:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807417:	0f b7 c8             	movzwl %ax,%ecx
  80741a:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80741d:	83 c0 14             	add    $0x14,%eax
  807420:	0f b7 c0             	movzwl %ax,%eax
  807423:	89 45 c8             	mov    %eax,-0x38(%ebp)
  u16_t poff = IP_HLEN;
  807426:	66 c7 45 e6 14 00    	movw   $0x14,-0x1a(%ebp)
    last = (left <= mtu - IP_HLEN);
  80742c:	8d 43 ed             	lea    -0x13(%ebx),%eax
  80742f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807432:	8d 46 14             	lea    0x14(%esi),%eax
  807435:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  while (left) {
  807438:	e9 e3 00 00 00       	jmp    807520 <ip_frag+0x1a2>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80743d:	83 ec 0c             	sub    $0xc,%esp
  807440:	ff 75 dc             	pushl  -0x24(%ebp)
  807443:	e8 d3 d5 ff ff       	call   804a1b <pbuf_free>
      return ERR_MEM;
  807448:	83 c4 10             	add    $0x10,%esp
  80744b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807450:	eb 13                	jmp    807465 <ip_frag+0xe7>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  807452:	83 ec 0c             	sub    $0xc,%esp
  807455:	ff 75 dc             	pushl  -0x24(%ebp)
  807458:	e8 be d5 ff ff       	call   804a1b <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  80745d:	83 c4 10             	add    $0x10,%esp
  807460:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807465:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807468:	5b                   	pop    %ebx
  807469:	5e                   	pop    %esi
  80746a:	5f                   	pop    %edi
  80746b:	5d                   	pop    %ebp
  80746c:	c3                   	ret    
    return ERR_MEM;
  80746d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807472:	eb f1                	jmp    807465 <ip_frag+0xe7>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807474:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  807478:	52                   	push   %edx
  807479:	50                   	push   %eax
  80747a:	ff 75 d4             	pushl  -0x2c(%ebp)
  80747d:	ff 75 08             	pushl  0x8(%ebp)
  807480:	e8 1f dd ff ff       	call   8051a4 <pbuf_copy_partial>
  807485:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807489:	0f b7 db             	movzwl %bx,%ebx
  80748c:	89 1c 24             	mov    %ebx,(%esp)
  80748f:	e8 bf 04 00 00       	call   807953 <htons>
  807494:	66 89 46 06          	mov    %ax,0x6(%esi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807498:	8d 5f 14             	lea    0x14(%edi),%ebx
  80749b:	0f b7 db             	movzwl %bx,%ebx
  80749e:	89 1c 24             	mov    %ebx,(%esp)
  8074a1:	e8 ad 04 00 00       	call   807953 <htons>
  8074a6:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  8074aa:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8074b0:	83 c4 08             	add    $0x8,%esp
  8074b3:	6a 14                	push   $0x14
  8074b5:	56                   	push   %esi
  8074b6:	e8 5e 03 00 00       	call   807819 <inet_chksum>
  8074bb:	66 89 46 0a          	mov    %ax,0xa(%esi)
      pbuf_realloc(rambuf, left + IP_HLEN);
  8074bf:	83 c4 08             	add    $0x8,%esp
  8074c2:	53                   	push   %ebx
  8074c3:	ff 75 dc             	pushl  -0x24(%ebp)
  8074c6:	e8 79 d8 ff ff       	call   804d44 <pbuf_realloc>
  8074cb:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  8074ce:	66 89 7d e2          	mov    %di,-0x1e(%ebp)
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8074d2:	83 ec 04             	sub    $0x4,%esp
  8074d5:	6a 00                	push   $0x0
  8074d7:	6a 00                	push   $0x0
  8074d9:	6a 02                	push   $0x2
  8074db:	e8 05 d6 ff ff       	call   804ae5 <pbuf_alloc>
  8074e0:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  8074e2:	83 c4 10             	add    $0x10,%esp
  8074e5:	85 c0                	test   %eax,%eax
  8074e7:	0f 84 50 ff ff ff    	je     80743d <ip_frag+0xbf>
      pbuf_chain(header, rambuf);
  8074ed:	83 ec 08             	sub    $0x8,%esp
  8074f0:	ff 75 dc             	pushl  -0x24(%ebp)
  8074f3:	50                   	push   %eax
  8074f4:	e8 04 da ff ff       	call   804efd <pbuf_chain>
      netif->output(netif, header, dest);
  8074f9:	83 c4 0c             	add    $0xc,%esp
  8074fc:	ff 75 10             	pushl  0x10(%ebp)
  8074ff:	53                   	push   %ebx
  807500:	ff 75 0c             	pushl  0xc(%ebp)
  807503:	8b 45 0c             	mov    0xc(%ebp),%eax
  807506:	ff 50 14             	call   *0x14(%eax)
      pbuf_free(header);
  807509:	89 1c 24             	mov    %ebx,(%esp)
  80750c:	e8 0a d5 ff ff       	call   804a1b <pbuf_free>
    left -= cop;
  807511:	66 2b 7d e2          	sub    -0x1e(%ebp),%di
    ofo += nfb;
  807515:	0f b7 4d d2          	movzwl -0x2e(%ebp),%ecx
  807519:	66 01 4d e4          	add    %cx,-0x1c(%ebp)
  80751d:	83 c4 10             	add    $0x10,%esp
  while (left) {
  807520:	66 85 ff             	test   %di,%di
  807523:	0f 84 29 ff ff ff    	je     807452 <ip_frag+0xd4>
    last = (left <= mtu - IP_HLEN);
  807529:	0f b7 c7             	movzwl %di,%eax
    tmp = omf | (IP_OFFMASK & (ofo));
  80752c:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  807530:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  807535:	66 0b 5d e0          	or     -0x20(%ebp),%bx
    if (!last)
  807539:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  80753c:	0f 8f 32 ff ff ff    	jg     807474 <ip_frag+0xf6>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807542:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807546:	50                   	push   %eax
  807547:	ff 75 cc             	pushl  -0x34(%ebp)
  80754a:	ff 75 d4             	pushl  -0x2c(%ebp)
  80754d:	ff 75 08             	pushl  0x8(%ebp)
  807550:	e8 4f dc ff ff       	call   8051a4 <pbuf_copy_partial>
  807555:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
      tmp = tmp | IP_MF;
  807559:	80 cf 20             	or     $0x20,%bh
    IPH_OFFSET_SET(iphdr, htons(tmp));
  80755c:	0f b7 db             	movzwl %bx,%ebx
  80755f:	89 1c 24             	mov    %ebx,(%esp)
  807562:	e8 ec 03 00 00       	call   807953 <htons>
  807567:	66 89 46 06          	mov    %ax,0x6(%esi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80756b:	83 c4 04             	add    $0x4,%esp
  80756e:	ff 75 c8             	pushl  -0x38(%ebp)
  807571:	e8 dd 03 00 00       	call   807953 <htons>
  807576:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  80757a:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  807580:	83 c4 08             	add    $0x8,%esp
  807583:	6a 14                	push   $0x14
  807585:	56                   	push   %esi
  807586:	e8 8e 02 00 00       	call   807819 <inet_chksum>
  80758b:	66 89 46 0a          	mov    %ax,0xa(%esi)
  80758f:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  807592:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  807596:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  80759a:	e9 33 ff ff ff       	jmp    8074d2 <ip_frag+0x154>

0080759f <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80759f:	55                   	push   %ebp
  8075a0:	89 e5                	mov    %esp,%ebp
  8075a2:	57                   	push   %edi
  8075a3:	56                   	push   %esi
  8075a4:	53                   	push   %ebx
  8075a5:	83 ec 1c             	sub    $0x1c,%esp
  8075a8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8075ab:	89 d7                	mov    %edx,%edi
  8075ad:	66 d1 ef             	shr    %di
  8075b0:	0f b7 d7             	movzwl %di,%edx
  8075b3:	8d 34 50             	lea    (%eax,%edx,2),%esi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8075b6:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8075bb:	39 f0                	cmp    %esi,%eax
  8075bd:	74 18                	je     8075d7 <lwip_standard_chksum+0x38>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8075bf:	0f b6 10             	movzbl (%eax),%edx
  8075c2:	89 d1                	mov    %edx,%ecx
  8075c4:	c1 e1 08             	shl    $0x8,%ecx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8075c7:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  8075cb:	09 ca                	or     %ecx,%edx
  8075cd:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  8075d0:	0f b7 d2             	movzwl %dx,%edx
  8075d3:	01 d3                	add    %edx,%ebx
  8075d5:	eb e4                	jmp    8075bb <lwip_standard_chksum+0x1c>
    len -= 2;
  }
  if (len > 0) {
  8075d7:	01 ff                	add    %edi,%edi
  8075d9:	66 3b 7d e4          	cmp    -0x1c(%ebp),%di
  8075dd:	74 0b                	je     8075ea <lwip_standard_chksum+0x4b>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8075df:	0f b6 00             	movzbl (%eax),%eax
  8075e2:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  8075e5:	0f b7 c0             	movzwl %ax,%eax
  8075e8:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8075ea:	89 da                	mov    %ebx,%edx
  8075ec:	c1 ea 10             	shr    $0x10,%edx
  8075ef:	0f b7 db             	movzwl %bx,%ebx
  8075f2:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
  if ((acc & 0xffff0000) != 0) {
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8075f5:	0f b7 c8             	movzwl %ax,%ecx
  8075f8:	83 c1 01             	add    $0x1,%ecx
  8075fb:	89 c3                	mov    %eax,%ebx
  8075fd:	a9 00 00 ff ff       	test   $0xffff0000,%eax
  807602:	89 c8                	mov    %ecx,%eax
  807604:	0f 44 c3             	cmove  %ebx,%eax
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807607:	83 ec 0c             	sub    $0xc,%esp
  80760a:	0f b7 c0             	movzwl %ax,%eax
  80760d:	50                   	push   %eax
  80760e:	e8 40 03 00 00       	call   807953 <htons>
}
  807613:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807616:	5b                   	pop    %ebx
  807617:	5e                   	pop    %esi
  807618:	5f                   	pop    %edi
  807619:	5d                   	pop    %ebp
  80761a:	c3                   	ret    

0080761b <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80761b:	f3 0f 1e fb          	endbr32 
  80761f:	55                   	push   %ebp
  807620:	89 e5                	mov    %esp,%ebp
  807622:	57                   	push   %edi
  807623:	56                   	push   %esi
  807624:	53                   	push   %ebx
  807625:	83 ec 1c             	sub    $0x1c,%esp
  807628:	8b 75 08             	mov    0x8(%ebp),%esi
  80762b:	8b 45 14             	mov    0x14(%ebp),%eax
  80762e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807631:	8b 45 18             	mov    0x18(%ebp),%eax
  807634:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807637:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  80763c:	bb 00 00 00 00       	mov    $0x0,%ebx
  807641:	89 f8                	mov    %edi,%eax
  807643:	89 df                	mov    %ebx,%edi
  807645:	89 c3                	mov    %eax,%ebx
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807647:	eb 02                	jmp    80764b <inet_chksum_pseudo+0x30>
  807649:	8b 36                	mov    (%esi),%esi
  80764b:	85 f6                	test   %esi,%esi
  80764d:	74 3d                	je     80768c <inet_chksum_pseudo+0x71>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80764f:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807653:	8b 46 04             	mov    0x4(%esi),%eax
  807656:	e8 44 ff ff ff       	call   80759f <lwip_standard_chksum>
  80765b:	0f b7 c0             	movzwl %ax,%eax
  80765e:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807660:	89 c7                	mov    %eax,%edi
  807662:	c1 ef 10             	shr    $0x10,%edi
  807665:	0f b7 c0             	movzwl %ax,%eax
  807668:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  80766a:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  80766e:	74 d9                	je     807649 <inet_chksum_pseudo+0x2e>
      swapped = 1 - swapped;
  807670:	b8 01 00 00 00       	mov    $0x1,%eax
  807675:	29 d8                	sub    %ebx,%eax
  807677:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  807679:	89 fa                	mov    %edi,%edx
  80767b:	c1 e2 08             	shl    $0x8,%edx
  80767e:	0f b7 d2             	movzwl %dx,%edx
  807681:	89 f8                	mov    %edi,%eax
  807683:	0f b6 c4             	movzbl %ah,%eax
  807686:	09 c2                	or     %eax,%edx
  807688:	89 d7                	mov    %edx,%edi
  80768a:	eb bd                	jmp    807649 <inet_chksum_pseudo+0x2e>
  80768c:	89 d8                	mov    %ebx,%eax
  80768e:	89 fb                	mov    %edi,%ebx
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807690:	84 c0                	test   %al,%al
  807692:	74 0d                	je     8076a1 <inet_chksum_pseudo+0x86>
    acc = SWAP_BYTES_IN_WORD(acc);
  807694:	89 f8                	mov    %edi,%eax
  807696:	c1 e0 08             	shl    $0x8,%eax
  807699:	0f b7 c0             	movzwl %ax,%eax
  80769c:	0f b6 df             	movzbl %bh,%ebx
  80769f:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  8076a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8076a4:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8076a6:	8b 55 10             	mov    0x10(%ebp),%edx
  8076a9:	8b 12                	mov    (%edx),%edx
  8076ab:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8076ae:	c1 ea 10             	shr    $0x10,%edx
  8076b1:	01 ca                	add    %ecx,%edx
  acc += (src->addr & 0xffffUL);
  8076b3:	0f b7 c8             	movzwl %ax,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8076b6:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  8076b8:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  8076bb:	01 d0                	add    %edx,%eax
  8076bd:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  8076bf:	83 ec 0c             	sub    $0xc,%esp
  8076c2:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8076c6:	50                   	push   %eax
  8076c7:	e8 87 02 00 00       	call   807953 <htons>
  8076cc:	0f b7 f0             	movzwl %ax,%esi
  8076cf:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  8076d1:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8076d5:	89 04 24             	mov    %eax,(%esp)
  8076d8:	e8 76 02 00 00       	call   807953 <htons>
  8076dd:	0f b7 d8             	movzwl %ax,%ebx
  8076e0:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8076e2:	89 d8                	mov    %ebx,%eax
  8076e4:	c1 e8 10             	shr    $0x10,%eax
  8076e7:	0f b7 db             	movzwl %bx,%ebx
  8076ea:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  8076ec:	89 d8                	mov    %ebx,%eax
  8076ee:	c1 e8 10             	shr    $0x10,%eax
  8076f1:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8076f3:	f7 d0                	not    %eax
}
  8076f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8076f8:	5b                   	pop    %ebx
  8076f9:	5e                   	pop    %esi
  8076fa:	5f                   	pop    %edi
  8076fb:	5d                   	pop    %ebp
  8076fc:	c3                   	ret    

008076fd <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  8076fd:	f3 0f 1e fb          	endbr32 
  807701:	55                   	push   %ebp
  807702:	89 e5                	mov    %esp,%ebp
  807704:	57                   	push   %edi
  807705:	56                   	push   %esi
  807706:	53                   	push   %ebx
  807707:	83 ec 1c             	sub    $0x1c,%esp
  80770a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80770d:	8b 45 14             	mov    0x14(%ebp),%eax
  807710:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807713:	8b 45 18             	mov    0x18(%ebp),%eax
  807716:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807719:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  80771d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  807721:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807728:	eb 19                	jmp    807743 <inet_chksum_pseudo_partial+0x46>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80772a:	83 ec 04             	sub    $0x4,%esp
  80772d:	68 d5 23 81 00       	push   $0x8123d5
  807732:	68 60 01 00 00       	push   $0x160
  807737:	68 e0 23 81 00       	push   $0x8123e0
  80773c:	e8 f6 71 00 00       	call   80e937 <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807741:	8b 1b                	mov    (%ebx),%ebx
  807743:	85 db                	test   %ebx,%ebx
  807745:	74 5c                	je     8077a3 <inet_chksum_pseudo_partial+0xa6>
  807747:	66 85 f6             	test   %si,%si
  80774a:	74 57                	je     8077a3 <inet_chksum_pseudo_partial+0xa6>
    chklen = q->len;
  80774c:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  807750:	66 39 fe             	cmp    %di,%si
  807753:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  807756:	0f b7 d7             	movzwl %di,%edx
  807759:	8b 43 04             	mov    0x4(%ebx),%eax
  80775c:	e8 3e fe ff ff       	call   80759f <lwip_standard_chksum>
  807761:	0f b7 c0             	movzwl %ax,%eax
  807764:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  807767:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807769:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  80776e:	77 ba                	ja     80772a <inet_chksum_pseudo_partial+0x2d>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807770:	89 c2                	mov    %eax,%edx
  807772:	c1 ea 10             	shr    $0x10,%edx
  807775:	0f b7 c0             	movzwl %ax,%eax
  807778:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  80777b:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80777e:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807782:	74 bd                	je     807741 <inet_chksum_pseudo_partial+0x44>
      swapped = 1 - swapped;
  807784:	b8 01 00 00 00       	mov    $0x1,%eax
  807789:	2a 45 e3             	sub    -0x1d(%ebp),%al
  80778c:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80778f:	89 fa                	mov    %edi,%edx
  807791:	c1 e2 08             	shl    $0x8,%edx
  807794:	0f b7 d2             	movzwl %dx,%edx
  807797:	89 f8                	mov    %edi,%eax
  807799:	0f b6 c4             	movzbl %ah,%eax
  80779c:	09 c2                	or     %eax,%edx
  80779e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8077a1:	eb 9e                	jmp    807741 <inet_chksum_pseudo_partial+0x44>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8077a3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8077a7:	74 13                	je     8077bc <inet_chksum_pseudo_partial+0xbf>
    acc = SWAP_BYTES_IN_WORD(acc);
  8077a9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8077ac:	89 c8                	mov    %ecx,%eax
  8077ae:	c1 e0 08             	shl    $0x8,%eax
  8077b1:	0f b7 c0             	movzwl %ax,%eax
  8077b4:	0f b6 d5             	movzbl %ch,%edx
  8077b7:	09 d0                	or     %edx,%eax
  8077b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  8077bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8077bf:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8077c1:	8b 45 10             	mov    0x10(%ebp),%eax
  8077c4:	8b 00                	mov    (%eax),%eax
  8077c6:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8077c9:	c1 e8 10             	shr    $0x10,%eax
  8077cc:	01 d0                	add    %edx,%eax
  acc += (src->addr & 0xffffUL);
  8077ce:	0f b7 d3             	movzwl %bx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8077d1:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  8077d3:	c1 eb 10             	shr    $0x10,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8077d6:	01 c3                	add    %eax,%ebx
  8077d8:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  8077db:	83 ec 0c             	sub    $0xc,%esp
  8077de:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  8077e2:	50                   	push   %eax
  8077e3:	e8 6b 01 00 00       	call   807953 <htons>
  8077e8:	0f b7 f0             	movzwl %ax,%esi
  8077eb:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  8077ed:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  8077f1:	89 04 24             	mov    %eax,(%esp)
  8077f4:	e8 5a 01 00 00       	call   807953 <htons>
  8077f9:	0f b7 d8             	movzwl %ax,%ebx
  8077fc:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8077fe:	89 d8                	mov    %ebx,%eax
  807800:	c1 e8 10             	shr    $0x10,%eax
  807803:	0f b7 db             	movzwl %bx,%ebx
  807806:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  807808:	89 d8                	mov    %ebx,%eax
  80780a:	c1 e8 10             	shr    $0x10,%eax
  80780d:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80780f:	f7 d0                	not    %eax
}
  807811:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807814:	5b                   	pop    %ebx
  807815:	5e                   	pop    %esi
  807816:	5f                   	pop    %edi
  807817:	5d                   	pop    %ebp
  807818:	c3                   	ret    

00807819 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807819:	f3 0f 1e fb          	endbr32 
  80781d:	55                   	push   %ebp
  80781e:	89 e5                	mov    %esp,%ebp
  807820:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807823:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807827:	8b 45 08             	mov    0x8(%ebp),%eax
  80782a:	e8 70 fd ff ff       	call   80759f <lwip_standard_chksum>
  80782f:	f7 d0                	not    %eax
}
  807831:	c9                   	leave  
  807832:	c3                   	ret    

00807833 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807833:	f3 0f 1e fb          	endbr32 
  807837:	55                   	push   %ebp
  807838:	89 e5                	mov    %esp,%ebp
  80783a:	57                   	push   %edi
  80783b:	56                   	push   %esi
  80783c:	53                   	push   %ebx
  80783d:	83 ec 0c             	sub    $0xc,%esp
  807840:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807843:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  807848:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
  80784d:	eb 02                	jmp    807851 <inet_chksum_pbuf+0x1e>
  80784f:	8b 36                	mov    (%esi),%esi
  807851:	85 f6                	test   %esi,%esi
  807853:	74 3b                	je     807890 <inet_chksum_pbuf+0x5d>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807855:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807859:	8b 46 04             	mov    0x4(%esi),%eax
  80785c:	e8 3e fd ff ff       	call   80759f <lwip_standard_chksum>
  807861:	0f b7 c0             	movzwl %ax,%eax
  807864:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  807866:	89 d8                	mov    %ebx,%eax
  807868:	c1 e8 10             	shr    $0x10,%eax
  80786b:	0f b7 db             	movzwl %bx,%ebx
  80786e:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  807870:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807874:	74 d9                	je     80784f <inet_chksum_pbuf+0x1c>
      swapped = 1 - swapped;
  807876:	b8 01 00 00 00       	mov    $0x1,%eax
  80787b:	89 f9                	mov    %edi,%ecx
  80787d:	29 c8                	sub    %ecx,%eax
  80787f:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807881:	89 da                	mov    %ebx,%edx
  807883:	c1 e2 08             	shl    $0x8,%edx
  807886:	0f b7 d2             	movzwl %dx,%edx
  807889:	0f b6 df             	movzbl %bh,%ebx
  80788c:	09 d3                	or     %edx,%ebx
  80788e:	eb bf                	jmp    80784f <inet_chksum_pbuf+0x1c>
    }
  }

  if (swapped) {
  807890:	89 f8                	mov    %edi,%eax
  807892:	84 c0                	test   %al,%al
  807894:	74 0d                	je     8078a3 <inet_chksum_pbuf+0x70>
    acc = SWAP_BYTES_IN_WORD(acc);
  807896:	89 da                	mov    %ebx,%edx
  807898:	c1 e2 08             	shl    $0x8,%edx
  80789b:	0f b7 d2             	movzwl %dx,%edx
  80789e:	0f b6 df             	movzbl %bh,%ebx
  8078a1:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  8078a3:	89 d8                	mov    %ebx,%eax
  8078a5:	f7 d0                	not    %eax
}
  8078a7:	83 c4 0c             	add    $0xc,%esp
  8078aa:	5b                   	pop    %ebx
  8078ab:	5e                   	pop    %esi
  8078ac:	5f                   	pop    %edi
  8078ad:	5d                   	pop    %ebp
  8078ae:	c3                   	ret    

008078af <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  8078af:	f3 0f 1e fb          	endbr32 
  8078b3:	55                   	push   %ebp
  8078b4:	89 e5                	mov    %esp,%ebp
  8078b6:	57                   	push   %edi
  8078b7:	56                   	push   %esi
  8078b8:	53                   	push   %ebx
  8078b9:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  8078bc:	8b 45 08             	mov    0x8(%ebp),%eax
  8078bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  8078c2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
  ap = (u8_t *)&s_addr;
  8078c6:	8d 75 f0             	lea    -0x10(%ebp),%esi
  rp = str;
  8078c9:	bf e4 49 b3 00       	mov    $0xb349e4,%edi
  8078ce:	eb 2e                	jmp    8078fe <inet_ntoa+0x4f>
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  8078d0:	0f b6 c8             	movzbl %al,%ecx
  8078d3:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  8078d8:	88 0a                	mov    %cl,(%edx)
  8078da:	83 c2 01             	add    $0x1,%edx
    while(i--)
  8078dd:	83 e8 01             	sub    $0x1,%eax
  8078e0:	3c ff                	cmp    $0xff,%al
  8078e2:	75 ec                	jne    8078d0 <inet_ntoa+0x21>
  8078e4:	0f b6 db             	movzbl %bl,%ebx
  8078e7:	01 fb                	add    %edi,%ebx
    *rp++ = '.';
  8078e9:	8d 7b 01             	lea    0x1(%ebx),%edi
  8078ec:	c6 03 2e             	movb   $0x2e,(%ebx)
  8078ef:	83 c6 01             	add    $0x1,%esi
  for(n = 0; n < 4; n++) {
  8078f2:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
  8078f6:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  8078fa:	3c 04                	cmp    $0x4,%al
  8078fc:	74 45                	je     807943 <inet_ntoa+0x94>
  rp = str;
  8078fe:	bb 00 00 00 00       	mov    $0x0,%ebx
      rem = *ap % (u8_t)10;
  807903:	0f b6 16             	movzbl (%esi),%edx
      *ap /= (u8_t)10;
  807906:	0f b6 ca             	movzbl %dl,%ecx
  807909:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80790c:	8d 04 c1             	lea    (%ecx,%eax,8),%eax
  80790f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807912:	66 c1 e8 0b          	shr    $0xb,%ax
  807916:	88 06                	mov    %al,(%esi)
  807918:	89 d9                	mov    %ebx,%ecx
      inv[i++] = '0' + rem;
  80791a:	83 c3 01             	add    $0x1,%ebx
  80791d:	0f b6 c9             	movzbl %cl,%ecx
  807920:	89 4d e0             	mov    %ecx,-0x20(%ebp)
      rem = *ap % (u8_t)10;
  807923:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807926:	01 c0                	add    %eax,%eax
  807928:	89 d1                	mov    %edx,%ecx
  80792a:	29 c1                	sub    %eax,%ecx
  80792c:	89 c8                	mov    %ecx,%eax
      inv[i++] = '0' + rem;
  80792e:	83 c0 30             	add    $0x30,%eax
  807931:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807934:	88 44 0d ed          	mov    %al,-0x13(%ebp,%ecx,1)
    } while(*ap);
  807938:	80 fa 09             	cmp    $0x9,%dl
  80793b:	77 c6                	ja     807903 <inet_ntoa+0x54>
  80793d:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  80793f:	89 d8                	mov    %ebx,%eax
  807941:	eb 9a                	jmp    8078dd <inet_ntoa+0x2e>
    ap++;
  }
  *--rp = 0;
  807943:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  807946:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  80794b:	83 c4 18             	add    $0x18,%esp
  80794e:	5b                   	pop    %ebx
  80794f:	5e                   	pop    %esi
  807950:	5f                   	pop    %edi
  807951:	5d                   	pop    %ebp
  807952:	c3                   	ret    

00807953 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807953:	f3 0f 1e fb          	endbr32 
  807957:	55                   	push   %ebp
  807958:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  80795a:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80795e:	66 c1 c0 08          	rol    $0x8,%ax
}
  807962:	5d                   	pop    %ebp
  807963:	c3                   	ret    

00807964 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807964:	f3 0f 1e fb          	endbr32 
  807968:	55                   	push   %ebp
  807969:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  80796b:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80796f:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  807973:	5d                   	pop    %ebp
  807974:	c3                   	ret    

00807975 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807975:	f3 0f 1e fb          	endbr32 
  807979:	55                   	push   %ebp
  80797a:	89 e5                	mov    %esp,%ebp
  80797c:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  80797f:	89 d0                	mov    %edx,%eax
  807981:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  807984:	89 d1                	mov    %edx,%ecx
  807986:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  807989:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  80798b:	89 d1                	mov    %edx,%ecx
  80798d:	c1 e1 08             	shl    $0x8,%ecx
  807990:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  807996:	09 c8                	or     %ecx,%eax
  807998:	c1 ea 08             	shr    $0x8,%edx
  80799b:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8079a1:	09 d0                	or     %edx,%eax
}
  8079a3:	5d                   	pop    %ebp
  8079a4:	c3                   	ret    

008079a5 <inet_aton>:
{
  8079a5:	f3 0f 1e fb          	endbr32 
  8079a9:	55                   	push   %ebp
  8079aa:	89 e5                	mov    %esp,%ebp
  8079ac:	57                   	push   %edi
  8079ad:	56                   	push   %esi
  8079ae:	53                   	push   %ebx
  8079af:	83 ec 2c             	sub    $0x2c,%esp
  8079b2:	8b 55 08             	mov    0x8(%ebp),%edx
  c = *cp;
  8079b5:	0f be 02             	movsbl (%edx),%eax
  u32_t *pp = parts;
  8079b8:	8d 75 d8             	lea    -0x28(%ebp),%esi
  8079bb:	89 75 cc             	mov    %esi,-0x34(%ebp)
  8079be:	e9 a7 00 00 00       	jmp    807a6a <inet_aton+0xc5>
      c = *++cp;
  8079c3:	0f b6 42 01          	movzbl 0x1(%edx),%eax
      if (c == 'x' || c == 'X') {
  8079c7:	89 c1                	mov    %eax,%ecx
  8079c9:	83 e1 df             	and    $0xffffffdf,%ecx
  8079cc:	80 f9 58             	cmp    $0x58,%cl
  8079cf:	74 10                	je     8079e1 <inet_aton+0x3c>
      c = *++cp;
  8079d1:	83 c2 01             	add    $0x1,%edx
  8079d4:	0f be c0             	movsbl %al,%eax
        base = 8;
  8079d7:	be 08 00 00 00       	mov    $0x8,%esi
  8079dc:	e9 a3 00 00 00       	jmp    807a84 <inet_aton+0xdf>
        c = *++cp;
  8079e1:	0f be 42 02          	movsbl 0x2(%edx),%eax
  8079e5:	8d 52 02             	lea    0x2(%edx),%edx
        base = 16;
  8079e8:	be 10 00 00 00       	mov    $0x10,%esi
  8079ed:	e9 92 00 00 00       	jmp    807a84 <inet_aton+0xdf>
      } else if (base == 16 && isxdigit(c)) {
  8079f2:	83 fe 10             	cmp    $0x10,%esi
  8079f5:	75 4d                	jne    807a44 <inet_aton+0x9f>
  8079f7:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  8079fa:	88 4d d3             	mov    %cl,-0x2d(%ebp)
  8079fd:	89 c1                	mov    %eax,%ecx
  8079ff:	83 e1 df             	and    $0xffffffdf,%ecx
  807a02:	83 e9 41             	sub    $0x41,%ecx
  807a05:	80 f9 05             	cmp    $0x5,%cl
  807a08:	77 3a                	ja     807a44 <inet_aton+0x9f>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807a0a:	c1 e3 04             	shl    $0x4,%ebx
  807a0d:	83 c0 0a             	add    $0xa,%eax
  807a10:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  807a14:	19 c9                	sbb    %ecx,%ecx
  807a16:	83 e1 20             	and    $0x20,%ecx
  807a19:	83 c1 41             	add    $0x41,%ecx
  807a1c:	29 c8                	sub    %ecx,%eax
  807a1e:	09 c3                	or     %eax,%ebx
        c = *++cp;
  807a20:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807a23:	0f be 40 01          	movsbl 0x1(%eax),%eax
  807a27:	83 c2 01             	add    $0x1,%edx
  807a2a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      if (isdigit(c)) {
  807a2d:	89 c7                	mov    %eax,%edi
  807a2f:	8d 48 d0             	lea    -0x30(%eax),%ecx
  807a32:	80 f9 09             	cmp    $0x9,%cl
  807a35:	77 bb                	ja     8079f2 <inet_aton+0x4d>
        val = (val * base) + (int)(c - '0');
  807a37:	0f af de             	imul   %esi,%ebx
  807a3a:	8d 5c 18 d0          	lea    -0x30(%eax,%ebx,1),%ebx
        c = *++cp;
  807a3e:	0f be 42 01          	movsbl 0x1(%edx),%eax
  807a42:	eb e3                	jmp    807a27 <inet_aton+0x82>
    if (c == '.') {
  807a44:	83 f8 2e             	cmp    $0x2e,%eax
  807a47:	75 42                	jne    807a8b <inet_aton+0xe6>
      if (pp >= parts + 3)
  807a49:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807a4c:	8b 75 cc             	mov    -0x34(%ebp),%esi
  807a4f:	39 c6                	cmp    %eax,%esi
  807a51:	0f 84 16 01 00 00    	je     807b6d <inet_aton+0x1c8>
      *pp++ = val;
  807a57:	83 c6 04             	add    $0x4,%esi
  807a5a:	89 75 cc             	mov    %esi,-0x34(%ebp)
  807a5d:	89 5e fc             	mov    %ebx,-0x4(%esi)
      c = *++cp;
  807a60:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807a63:	8d 50 01             	lea    0x1(%eax),%edx
  807a66:	0f be 40 01          	movsbl 0x1(%eax),%eax
    if (!isdigit(c))
  807a6a:	8d 48 d0             	lea    -0x30(%eax),%ecx
  807a6d:	80 f9 09             	cmp    $0x9,%cl
  807a70:	0f 87 f0 00 00 00    	ja     807b66 <inet_aton+0x1c1>
    base = 10;
  807a76:	be 0a 00 00 00       	mov    $0xa,%esi
    if (c == '0') {
  807a7b:	83 f8 30             	cmp    $0x30,%eax
  807a7e:	0f 84 3f ff ff ff    	je     8079c3 <inet_aton+0x1e>
    base = 10;
  807a84:	bb 00 00 00 00       	mov    $0x0,%ebx
  807a89:	eb 9f                	jmp    807a2a <inet_aton+0x85>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807a8b:	85 c0                	test   %eax,%eax
  807a8d:	74 29                	je     807ab8 <inet_aton+0x113>
    return (0);
  807a8f:	ba 00 00 00 00       	mov    $0x0,%edx
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807a94:	89 f9                	mov    %edi,%ecx
  807a96:	80 f9 1f             	cmp    $0x1f,%cl
  807a99:	0f 86 d3 00 00 00    	jbe    807b72 <inet_aton+0x1cd>
  807a9f:	84 c0                	test   %al,%al
  807aa1:	0f 88 cb 00 00 00    	js     807b72 <inet_aton+0x1cd>
  807aa7:	83 f8 20             	cmp    $0x20,%eax
  807aaa:	74 0c                	je     807ab8 <inet_aton+0x113>
  807aac:	83 e8 09             	sub    $0x9,%eax
  807aaf:	83 f8 04             	cmp    $0x4,%eax
  807ab2:	0f 87 ba 00 00 00    	ja     807b72 <inet_aton+0x1cd>
  n = pp - parts + 1;
  807ab8:	8d 45 d8             	lea    -0x28(%ebp),%eax
  807abb:	8b 75 cc             	mov    -0x34(%ebp),%esi
  807abe:	29 c6                	sub    %eax,%esi
  807ac0:	89 f0                	mov    %esi,%eax
  807ac2:	c1 f8 02             	sar    $0x2,%eax
  807ac5:	8d 50 01             	lea    0x1(%eax),%edx
  switch (n) {
  807ac8:	83 f8 02             	cmp    $0x2,%eax
  807acb:	74 7a                	je     807b47 <inet_aton+0x1a2>
  807acd:	83 fa 03             	cmp    $0x3,%edx
  807ad0:	7f 49                	jg     807b1b <inet_aton+0x176>
  807ad2:	85 d2                	test   %edx,%edx
  807ad4:	0f 84 98 00 00 00    	je     807b72 <inet_aton+0x1cd>
  807ada:	83 fa 02             	cmp    $0x2,%edx
  807add:	75 19                	jne    807af8 <inet_aton+0x153>
      return (0);
  807adf:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xffffffUL)
  807ae4:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  807aea:	0f 87 82 00 00 00    	ja     807b72 <inet_aton+0x1cd>
    val |= parts[0] << 24;
  807af0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807af3:	c1 e0 18             	shl    $0x18,%eax
  807af6:	09 c3                	or     %eax,%ebx
  return (1);
  807af8:	ba 01 00 00 00       	mov    $0x1,%edx
  if (addr)
  807afd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807b01:	74 6f                	je     807b72 <inet_aton+0x1cd>
    addr->s_addr = htonl(val);
  807b03:	83 ec 0c             	sub    $0xc,%esp
  807b06:	53                   	push   %ebx
  807b07:	e8 69 fe ff ff       	call   807975 <htonl>
  807b0c:	83 c4 10             	add    $0x10,%esp
  807b0f:	8b 75 0c             	mov    0xc(%ebp),%esi
  807b12:	89 06                	mov    %eax,(%esi)
  return (1);
  807b14:	ba 01 00 00 00       	mov    $0x1,%edx
  807b19:	eb 57                	jmp    807b72 <inet_aton+0x1cd>
  switch (n) {
  807b1b:	83 fa 04             	cmp    $0x4,%edx
  807b1e:	75 d8                	jne    807af8 <inet_aton+0x153>
      return (0);
  807b20:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xff)
  807b25:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  807b2b:	77 45                	ja     807b72 <inet_aton+0x1cd>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807b2d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807b30:	c1 e0 18             	shl    $0x18,%eax
  807b33:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807b36:	c1 e2 10             	shl    $0x10,%edx
  807b39:	09 d0                	or     %edx,%eax
  807b3b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807b3e:	c1 e2 08             	shl    $0x8,%edx
  807b41:	09 d0                	or     %edx,%eax
  807b43:	09 c3                	or     %eax,%ebx
    break;
  807b45:	eb b1                	jmp    807af8 <inet_aton+0x153>
      return (0);
  807b47:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xffff)
  807b4c:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  807b52:	77 1e                	ja     807b72 <inet_aton+0x1cd>
    val |= (parts[0] << 24) | (parts[1] << 16);
  807b54:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807b57:	c1 e0 18             	shl    $0x18,%eax
  807b5a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807b5d:	c1 e2 10             	shl    $0x10,%edx
  807b60:	09 d0                	or     %edx,%eax
  807b62:	09 c3                	or     %eax,%ebx
    break;
  807b64:	eb 92                	jmp    807af8 <inet_aton+0x153>
      return (0);
  807b66:	ba 00 00 00 00       	mov    $0x0,%edx
  807b6b:	eb 05                	jmp    807b72 <inet_aton+0x1cd>
        return (0);
  807b6d:	ba 00 00 00 00       	mov    $0x0,%edx
}
  807b72:	89 d0                	mov    %edx,%eax
  807b74:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807b77:	5b                   	pop    %ebx
  807b78:	5e                   	pop    %esi
  807b79:	5f                   	pop    %edi
  807b7a:	5d                   	pop    %ebp
  807b7b:	c3                   	ret    

00807b7c <inet_addr>:
{
  807b7c:	f3 0f 1e fb          	endbr32 
  807b80:	55                   	push   %ebp
  807b81:	89 e5                	mov    %esp,%ebp
  807b83:	83 ec 20             	sub    $0x20,%esp
  if (inet_aton(cp, &val)) {
  807b86:	8d 45 f4             	lea    -0xc(%ebp),%eax
  807b89:	50                   	push   %eax
  807b8a:	ff 75 08             	pushl  0x8(%ebp)
  807b8d:	e8 13 fe ff ff       	call   8079a5 <inet_aton>
  807b92:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  807b95:	85 c0                	test   %eax,%eax
  807b97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807b9c:	0f 45 45 f4          	cmovne -0xc(%ebp),%eax
}
  807ba0:	c9                   	leave  
  807ba1:	c3                   	ret    

00807ba2 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807ba2:	f3 0f 1e fb          	endbr32 
  807ba6:	55                   	push   %ebp
  807ba7:	89 e5                	mov    %esp,%ebp
  807ba9:	83 ec 14             	sub    $0x14,%esp
  return htonl(n);
  807bac:	ff 75 08             	pushl  0x8(%ebp)
  807baf:	e8 c1 fd ff ff       	call   807975 <htonl>
  807bb4:	83 c4 10             	add    $0x10,%esp
}
  807bb7:	c9                   	leave  
  807bb8:	c3                   	ret    

00807bb9 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807bb9:	f3 0f 1e fb          	endbr32 
  807bbd:	55                   	push   %ebp
  807bbe:	89 e5                	mov    %esp,%ebp
  807bc0:	57                   	push   %edi
  807bc1:	56                   	push   %esi
  807bc2:	53                   	push   %ebx
  807bc3:	83 ec 3c             	sub    $0x3c,%esp
  807bc6:	8b 7d 08             	mov    0x8(%ebp),%edi
  807bc9:	8b 75 10             	mov    0x10(%ebp),%esi
  807bcc:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  807bcf:	8b 55 14             	mov    0x14(%ebp),%edx
  807bd2:	89 55 bc             	mov    %edx,-0x44(%ebp)
  807bd5:	8b 5d 18             	mov    0x18(%ebp),%ebx
  807bd8:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  807bdb:	8b 45 20             	mov    0x20(%ebp),%eax
  807bde:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  807be2:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807be5:	89 da                	mov    %ebx,%edx
  807be7:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807bea:	66 85 f6             	test   %si,%si
  807bed:	74 04                	je     807bf3 <tcp_enqueue+0x3a>
  807bef:	84 c0                	test   %al,%al
  807bf1:	75 54                	jne    807c47 <tcp_enqueue+0x8e>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807bf3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807bf7:	74 06                	je     807bff <tcp_enqueue+0x46>
  807bf9:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807bfd:	75 5f                	jne    807c5e <tcp_enqueue+0xa5>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807bff:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  807c03:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  807c07:	72 6c                	jb     807c75 <tcp_enqueue+0xbc>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807c09:	8b 4f 68             	mov    0x68(%edi),%ecx
  807c0c:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807c0f:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  807c13:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807c17:	66 83 f9 1f          	cmp    $0x1f,%cx
  807c1b:	77 66                	ja     807c83 <tcp_enqueue+0xca>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  807c1d:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807c22:	74 6d                	je     807c91 <tcp_enqueue+0xd8>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807c24:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807c28:	75 7b                	jne    807ca5 <tcp_enqueue+0xec>
  807c2a:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807c2e:	75 75                	jne    807ca5 <tcp_enqueue+0xec>
  807c30:	83 ec 04             	sub    $0x4,%esp
  807c33:	68 8c 24 81 00       	push   $0x81248c
  807c38:	68 ad 00 00 00       	push   $0xad
  807c3d:	68 a6 25 81 00       	push   $0x8125a6
  807c42:	e8 f0 6c 00 00       	call   80e937 <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807c47:	83 ec 04             	sub    $0x4,%esp
  807c4a:	68 04 24 81 00       	push   $0x812404
  807c4f:	68 8f 00 00 00       	push   $0x8f
  807c54:	68 a6 25 81 00       	push   $0x8125a6
  807c59:	e8 d9 6c 00 00       	call   80e937 <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807c5e:	83 ec 04             	sub    $0x4,%esp
  807c61:	68 44 24 81 00       	push   $0x812444
  807c66:	68 91 00 00 00       	push   $0x91
  807c6b:	68 a6 25 81 00       	push   $0x8125a6
  807c70:	e8 c2 6c 00 00       	call   80e937 <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  807c75:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807c79:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807c7e:	e9 64 04 00 00       	jmp    8080e7 <tcp_enqueue+0x52e>
    pcb->flags |= TF_NAGLEMEMERR;
  807c83:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807c87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807c8c:	e9 56 04 00 00       	jmp    8080e7 <tcp_enqueue+0x52e>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807c91:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807c95:	0f 85 c5 02 00 00    	jne    807f60 <tcp_enqueue+0x3a7>
  807c9b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807c9f:	0f 85 bb 02 00 00    	jne    807f60 <tcp_enqueue+0x3a7>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807ca5:	c0 e8 02             	shr    $0x2,%al
  807ca8:	c1 e0 0c             	shl    $0xc,%eax
  807cab:	66 05 00 50          	add    $0x5000,%ax
  807caf:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807cb3:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807cb7:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807cbb:	8b 45 0c             	mov    0xc(%ebp),%eax
  807cbe:	89 45 d0             	mov    %eax,-0x30(%ebp)
  807cc1:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (queue == NULL || left > 0) {
  807cc6:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807cca:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807cd1:	83 e2 01             	and    $0x1,%edx
  807cd4:	88 55 c9             	mov    %dl,-0x37(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807cd7:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807cdb:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  807cde:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807ce2:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807ce6:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807ceb:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  807cef:	89 de                	mov    %ebx,%esi
    seg = memp_malloc(MEMP_TCP_SEG);
  807cf1:	83 ec 0c             	sub    $0xc,%esp
  807cf4:	6a 04                	push   $0x4
  807cf6:	e8 43 c9 ff ff       	call   80463e <memp_malloc>
  807cfb:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807cfd:	83 c4 10             	add    $0x10,%esp
  807d00:	85 c0                	test   %eax,%eax
  807d02:	0f 84 a4 03 00 00    	je     8080ac <tcp_enqueue+0x4f3>
    seg->next = NULL;
  807d08:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807d0e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807d15:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807d19:	0f 85 6f 02 00 00    	jne    807f8e <tcp_enqueue+0x3d5>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807d1f:	85 f6                	test   %esi,%esi
  807d21:	0f 84 50 02 00 00    	je     807f77 <tcp_enqueue+0x3be>
      useg->next = seg;
  807d27:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807d29:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807d2d:	0f 84 7a 02 00 00    	je     807fad <tcp_enqueue+0x3f4>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807d33:	83 ec 04             	sub    $0x4,%esp
  807d36:	6a 00                	push   $0x0
  807d38:	ff 75 cc             	pushl  -0x34(%ebp)
  807d3b:	6a 00                	push   $0x0
  807d3d:	e8 a3 cd ff ff       	call   804ae5 <pbuf_alloc>
  807d42:	89 43 04             	mov    %eax,0x4(%ebx)
  807d45:	83 c4 10             	add    $0x10,%esp
  807d48:	85 c0                	test   %eax,%eax
  807d4a:	0f 84 5c 03 00 00    	je     8080ac <tcp_enqueue+0x4f3>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807d50:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807d54:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807d58:	0f 82 38 02 00 00    	jb     807f96 <tcp_enqueue+0x3dd>
      queuelen += pbuf_clen(seg->p);
  807d5e:	83 ec 0c             	sub    $0xc,%esp
  807d61:	50                   	push   %eax
  807d62:	e8 f3 d0 ff ff       	call   804e5a <pbuf_clen>
  807d67:	0f b6 c0             	movzbl %al,%eax
  807d6a:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807d6e:	8b 43 04             	mov    0x4(%ebx),%eax
  807d71:	8b 40 04             	mov    0x4(%eax),%eax
  807d74:	89 43 08             	mov    %eax,0x8(%ebx)
  807d77:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807d7a:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807d7f:	0f 87 27 03 00 00    	ja     8080ac <tcp_enqueue+0x4f3>
    seg->len = seglen;
  807d85:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807d89:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807d8d:	83 ec 08             	sub    $0x8,%esp
  807d90:	6a 14                	push   $0x14
  807d92:	ff 73 04             	pushl  0x4(%ebx)
  807d95:	e8 ae cb ff ff       	call   804948 <pbuf_header>
  807d9a:	83 c4 10             	add    $0x10,%esp
  807d9d:	84 c0                	test   %al,%al
  807d9f:	0f 85 07 03 00 00    	jne    8080ac <tcp_enqueue+0x4f3>
    seg->tcphdr = seg->p->payload;
  807da5:	8b 43 04             	mov    0x4(%ebx),%eax
  807da8:	8b 70 04             	mov    0x4(%eax),%esi
  807dab:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807dae:	83 ec 0c             	sub    $0xc,%esp
  807db1:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807db5:	50                   	push   %eax
  807db6:	e8 98 fb ff ff       	call   807953 <htons>
  807dbb:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807dbe:	8b 73 10             	mov    0x10(%ebx),%esi
  807dc1:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807dc5:	89 04 24             	mov    %eax,(%esp)
  807dc8:	e8 86 fb ff ff       	call   807953 <htons>
  807dcd:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807dd1:	8b 73 10             	mov    0x10(%ebx),%esi
  807dd4:	83 c4 04             	add    $0x4,%esp
  807dd7:	ff 75 d8             	pushl  -0x28(%ebp)
  807dda:	e8 96 fb ff ff       	call   807975 <htonl>
  807ddf:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807de2:	8b 43 10             	mov    0x10(%ebx),%eax
  807de5:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807deb:	8b 43 10             	mov    0x10(%ebx),%eax
  807dee:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807df2:	89 04 24             	mov    %eax,(%esp)
  807df5:	e8 6a fb ff ff       	call   807964 <ntohs>
  807dfa:	8b 73 10             	mov    0x10(%ebx),%esi
  807dfd:	83 e0 c0             	and    $0xffffffc0,%eax
  807e00:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807e04:	09 d0                	or     %edx,%eax
  807e06:	0f b7 c0             	movzwl %ax,%eax
  807e09:	89 04 24             	mov    %eax,(%esp)
  807e0c:	e8 42 fb ff ff       	call   807953 <htons>
  807e11:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807e15:	83 c4 10             	add    $0x10,%esp
  807e18:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807e1c:	0f 84 cd 02 00 00    	je     8080ef <tcp_enqueue+0x536>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807e22:	83 ec 0c             	sub    $0xc,%esp
  807e25:	8b 43 10             	mov    0x10(%ebx),%eax
  807e28:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e2c:	50                   	push   %eax
  807e2d:	e8 32 fb ff ff       	call   807964 <ntohs>
  807e32:	8b 73 10             	mov    0x10(%ebx),%esi
  807e35:	83 e0 3f             	and    $0x3f,%eax
  807e38:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807e3c:	0f b7 c0             	movzwl %ax,%eax
  807e3f:	89 04 24             	mov    %eax,(%esp)
  807e42:	e8 0c fb ff ff       	call   807953 <htons>
  807e47:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807e4b:	83 c4 0c             	add    $0xc,%esp
  807e4e:	ff 75 cc             	pushl  -0x34(%ebp)
  807e51:	ff 75 1c             	pushl  0x1c(%ebp)
  807e54:	ff 73 08             	pushl  0x8(%ebx)
  807e57:	e8 30 74 00 00       	call   80f28c <memcpy>
  807e5c:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807e5f:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807e63:	0f b7 c1             	movzwl %cx,%eax
  807e66:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807e69:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807e6c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807e70:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807e74:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807e78:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807e7c:	0f 85 5c fe ff ff    	jne    807cde <tcp_enqueue+0x125>
  807e82:	84 c0                	test   %al,%al
  807e84:	0f 85 54 fe ff ff    	jne    807cde <tcp_enqueue+0x125>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807e8a:	8b 77 74             	mov    0x74(%edi),%esi
  807e8d:	85 f6                	test   %esi,%esi
  807e8f:	0f 84 bb 03 00 00    	je     808250 <tcp_enqueue+0x697>
  807e95:	89 f0                	mov    %esi,%eax
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807e97:	8b 36                	mov    (%esi),%esi
  807e99:	85 f6                	test   %esi,%esi
  807e9b:	75 f8                	jne    807e95 <tcp_enqueue+0x2dc>
  807e9d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  807ea0:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807ea4:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  807ea8:	83 ec 0c             	sub    $0xc,%esp
  807eab:	8b 40 10             	mov    0x10(%eax),%eax
  807eae:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807eb2:	50                   	push   %eax
  807eb3:	e8 ac fa ff ff       	call   807964 <ntohs>
  807eb8:	83 c4 10             	add    $0x10,%esp
  807ebb:	a8 01                	test   $0x1,%al
  807ebd:	0f 84 59 02 00 00    	je     80811c <tcp_enqueue+0x563>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807ec3:	83 ec 0c             	sub    $0xc,%esp
  807ec6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ec9:	8b 40 10             	mov    0x10(%eax),%eax
  807ecc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807ed0:	50                   	push   %eax
  807ed1:	e8 8e fa ff ff       	call   807964 <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807ed6:	83 c4 10             	add    $0x10,%esp
  807ed9:	a8 03                	test   $0x3,%al
  807edb:	0f 85 63 02 00 00    	jne    808144 <tcp_enqueue+0x58b>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807ee1:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807ee5:	0f 85 59 02 00 00    	jne    808144 <tcp_enqueue+0x58b>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  807eeb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807eee:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807ef2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807ef5:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  807ef9:	01 d0                	add    %edx,%eax
  807efb:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807eff:	39 d0                	cmp    %edx,%eax
  807f01:	0f 8f 3d 02 00 00    	jg     808144 <tcp_enqueue+0x58b>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807f07:	83 ec 08             	sub    $0x8,%esp
  807f0a:	6a ec                	push   $0xffffffec
  807f0c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807f0f:	ff 70 04             	pushl  0x4(%eax)
  807f12:	e8 31 ca ff ff       	call   804948 <pbuf_header>
  807f17:	83 c4 10             	add    $0x10,%esp
  807f1a:	84 c0                	test   %al,%al
  807f1c:	0f 85 c5 02 00 00    	jne    8081e7 <tcp_enqueue+0x62e>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  807f22:	83 ec 08             	sub    $0x8,%esp
  807f25:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807f28:	ff 72 04             	pushl  0x4(%edx)
  807f2b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807f2e:	ff 71 04             	pushl  0x4(%ecx)
  807f31:	e8 57 cf ff ff       	call   804e8d <pbuf_cat>
    useg->len += queue->len;
  807f36:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807f39:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807f3d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807f40:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  807f44:	8b 02                	mov    (%edx),%eax
  807f46:	89 01                	mov    %eax,(%ecx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  807f48:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807f4b:	39 da                	cmp    %ebx,%edx
  807f4d:	0f 44 de             	cmove  %esi,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  807f50:	52                   	push   %edx
  807f51:	6a 04                	push   $0x4
  807f53:	e8 40 c7 ff ff       	call   804698 <memp_free>
  807f58:	83 c4 10             	add    $0x10,%esp
  807f5b:	e9 00 02 00 00       	jmp    808160 <tcp_enqueue+0x5a7>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807f60:	83 ec 04             	sub    $0x4,%esp
  807f63:	68 c8 24 81 00       	push   $0x8124c8
  807f68:	68 b0 00 00 00       	push   $0xb0
  807f6d:	68 a6 25 81 00       	push   $0x8125a6
  807f72:	e8 c0 69 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807f77:	83 ec 04             	sub    $0x4,%esp
  807f7a:	68 be 25 81 00       	push   $0x8125be
  807f7f:	68 ce 00 00 00       	push   $0xce
  807f84:	68 a6 25 81 00       	push   $0x8125a6
  807f89:	e8 a9 69 00 00       	call   80e937 <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807f8e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807f91:	e9 93 fd ff ff       	jmp    807d29 <tcp_enqueue+0x170>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807f96:	83 ec 04             	sub    $0x4,%esp
  807f99:	68 fc 24 81 00       	push   $0x8124fc
  807f9e:	68 de 00 00 00       	push   $0xde
  807fa3:	68 a6 25 81 00       	push   $0x8125a6
  807fa8:	e8 8a 69 00 00       	call   80e937 <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807fad:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807fb1:	74 7f                	je     808032 <tcp_enqueue+0x479>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807fb3:	83 ec 04             	sub    $0x4,%esp
  807fb6:	6a 00                	push   $0x0
  807fb8:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807fbc:	0f b7 c6             	movzwl %si,%eax
  807fbf:	50                   	push   %eax
  807fc0:	6a 00                	push   $0x0
  807fc2:	e8 1e cb ff ff       	call   804ae5 <pbuf_alloc>
  807fc7:	89 43 04             	mov    %eax,0x4(%ebx)
  807fca:	83 c4 10             	add    $0x10,%esp
  807fcd:	85 c0                	test   %eax,%eax
  807fcf:	0f 84 d7 00 00 00    	je     8080ac <tcp_enqueue+0x4f3>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807fd5:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807fd9:	72 40                	jb     80801b <tcp_enqueue+0x462>
      queuelen += pbuf_clen(seg->p);
  807fdb:	83 ec 0c             	sub    $0xc,%esp
  807fde:	50                   	push   %eax
  807fdf:	e8 76 ce ff ff       	call   804e5a <pbuf_clen>
  807fe4:	0f b6 c0             	movzbl %al,%eax
  807fe7:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807feb:	83 c4 10             	add    $0x10,%esp
  807fee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807ff2:	74 19                	je     80800d <tcp_enqueue+0x454>
        MEMCPY(seg->p->payload, ptr, seglen);
  807ff4:	83 ec 04             	sub    $0x4,%esp
  807ff7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807ffb:	50                   	push   %eax
  807ffc:	ff 75 d0             	pushl  -0x30(%ebp)
  807fff:	8b 43 04             	mov    0x4(%ebx),%eax
  808002:	ff 70 04             	pushl  0x4(%eax)
  808005:	e8 82 72 00 00       	call   80f28c <memcpy>
  80800a:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  80800d:	8b 43 04             	mov    0x4(%ebx),%eax
  808010:	8b 40 04             	mov    0x4(%eax),%eax
  808013:	89 43 08             	mov    %eax,0x8(%ebx)
  808016:	e9 5f fd ff ff       	jmp    807d7a <tcp_enqueue+0x1c1>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  80801b:	83 ec 04             	sub    $0x4,%esp
  80801e:	68 24 25 81 00       	push   $0x812524
  808023:	68 e9 00 00 00       	push   $0xe9
  808028:	68 a6 25 81 00       	push   $0x8125a6
  80802d:	e8 05 69 00 00       	call   80e937 <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  808032:	83 ec 04             	sub    $0x4,%esp
  808035:	6a 01                	push   $0x1
  808037:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80803b:	50                   	push   %eax
  80803c:	6a 00                	push   $0x0
  80803e:	e8 a2 ca ff ff       	call   804ae5 <pbuf_alloc>
  808043:	89 c6                	mov    %eax,%esi
  808045:	83 c4 10             	add    $0x10,%esp
  808048:	85 c0                	test   %eax,%eax
  80804a:	74 60                	je     8080ac <tcp_enqueue+0x4f3>
      ++queuelen;
  80804c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  808050:	83 c0 01             	add    $0x1,%eax
  808053:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  808057:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80805a:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  80805d:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  808060:	83 ec 04             	sub    $0x4,%esp
  808063:	6a 00                	push   $0x0
  808065:	6a 00                	push   $0x0
  808067:	6a 00                	push   $0x0
  808069:	e8 77 ca ff ff       	call   804ae5 <pbuf_alloc>
  80806e:	89 43 04             	mov    %eax,0x4(%ebx)
  808071:	83 c4 10             	add    $0x10,%esp
  808074:	85 c0                	test   %eax,%eax
  808076:	74 28                	je     8080a0 <tcp_enqueue+0x4e7>
      queuelen += pbuf_clen(seg->p);
  808078:	83 ec 0c             	sub    $0xc,%esp
  80807b:	50                   	push   %eax
  80807c:	e8 d9 cd ff ff       	call   804e5a <pbuf_clen>
  808081:	0f b6 c0             	movzbl %al,%eax
  808084:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  808088:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  80808c:	83 c4 08             	add    $0x8,%esp
  80808f:	56                   	push   %esi
  808090:	ff 73 04             	pushl  0x4(%ebx)
  808093:	e8 f5 cd ff ff       	call   804e8d <pbuf_cat>
  808098:	83 c4 10             	add    $0x10,%esp
  80809b:	e9 da fc ff ff       	jmp    807d7a <tcp_enqueue+0x1c1>
        pbuf_free(p);
  8080a0:	83 ec 0c             	sub    $0xc,%esp
  8080a3:	56                   	push   %esi
  8080a4:	e8 72 c9 ff ff       	call   804a1b <pbuf_free>
        goto memerr;
  8080a9:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  8080ac:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  8080b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8080b3:	85 c0                	test   %eax,%eax
  8080b5:	74 0c                	je     8080c3 <tcp_enqueue+0x50a>
    tcp_segs_free(queue);
  8080b7:	83 ec 0c             	sub    $0xc,%esp
  8080ba:	50                   	push   %eax
  8080bb:	e8 f2 d8 ff ff       	call   8059b2 <tcp_segs_free>
  8080c0:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  8080c3:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  8080c8:	0f 84 6e 01 00 00    	je     80823c <tcp_enqueue+0x683>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  8080ce:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8080d2:	0f 85 6e 01 00 00    	jne    808246 <tcp_enqueue+0x68d>
  8080d8:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8080dc:	0f 84 39 01 00 00    	je     80821b <tcp_enqueue+0x662>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  8080e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8080e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8080ea:	5b                   	pop    %ebx
  8080eb:	5e                   	pop    %esi
  8080ec:	5f                   	pop    %edi
  8080ed:	5d                   	pop    %ebp
  8080ee:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  8080ef:	83 ec 0c             	sub    $0xc,%esp
  8080f2:	8b 43 10             	mov    0x10(%ebx),%eax
  8080f5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8080f9:	50                   	push   %eax
  8080fa:	e8 65 f8 ff ff       	call   807964 <ntohs>
  8080ff:	8b 73 10             	mov    0x10(%ebx),%esi
  808102:	83 e0 3f             	and    $0x3f,%eax
  808105:	80 cc 50             	or     $0x50,%ah
  808108:	89 04 24             	mov    %eax,(%esp)
  80810b:	e8 43 f8 ff ff       	call   807953 <htons>
  808110:	66 89 46 0c          	mov    %ax,0xc(%esi)
  808114:	83 c4 10             	add    $0x10,%esp
  808117:	e9 43 fd ff ff       	jmp    807e5f <tcp_enqueue+0x2a6>
    TCP_TCPLEN(useg) != 0 &&
  80811c:	83 ec 0c             	sub    $0xc,%esp
  80811f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808122:	8b 40 10             	mov    0x10(%eax),%eax
  808125:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808129:	50                   	push   %eax
  80812a:	e8 35 f8 ff ff       	call   807964 <ntohs>
  80812f:	66 d1 e8             	shr    %ax
  808132:	83 e0 01             	and    $0x1,%eax
  808135:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  if (useg != NULL &&
  808139:	83 c4 10             	add    $0x10,%esp
  80813c:	01 d0                	add    %edx,%eax
  80813e:	0f 85 7f fd ff ff    	jne    807ec3 <tcp_enqueue+0x30a>
      useg->next = queue;
  808144:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808147:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80814a:	89 10                	mov    %edx,(%eax)
    ++len;
  80814c:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  808150:	83 c0 01             	add    $0x1,%eax
  808153:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  808157:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  80815c:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  if (flags & TCP_FIN) {
  808160:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  808164:	74 04                	je     80816a <tcp_enqueue+0x5b1>
    pcb->flags |= TF_FIN;
  808166:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  80816a:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  80816e:	0f b7 c2             	movzwl %dx,%eax
  808171:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  808174:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  808178:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80817c:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  808180:	66 85 c0             	test   %ax,%ax
  808183:	74 06                	je     80818b <tcp_enqueue+0x5d2>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  808185:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808189:	74 73                	je     8081fe <tcp_enqueue+0x645>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80818b:	85 db                	test   %ebx,%ebx
  80818d:	0f 84 9f 00 00 00    	je     808232 <tcp_enqueue+0x679>
  808193:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  808198:	0f 84 94 00 00 00    	je     808232 <tcp_enqueue+0x679>
  80819e:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  8081a1:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8081a6:	85 d2                	test   %edx,%edx
  8081a8:	0f 84 39 ff ff ff    	je     8080e7 <tcp_enqueue+0x52e>
  8081ae:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  8081b2:	0f 85 2f ff ff ff    	jne    8080e7 <tcp_enqueue+0x52e>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  8081b8:	83 ec 0c             	sub    $0xc,%esp
  8081bb:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  8081bf:	50                   	push   %eax
  8081c0:	e8 9f f7 ff ff       	call   807964 <ntohs>
  8081c5:	8b 5b 10             	mov    0x10(%ebx),%ebx
  8081c8:	83 c8 08             	or     $0x8,%eax
  8081cb:	0f b7 c0             	movzwl %ax,%eax
  8081ce:	89 04 24             	mov    %eax,(%esp)
  8081d1:	e8 7d f7 ff ff       	call   807953 <htons>
  8081d6:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  8081da:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  8081dd:	b8 00 00 00 00       	mov    $0x0,%eax
  8081e2:	e9 00 ff ff ff       	jmp    8080e7 <tcp_enqueue+0x52e>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8081e7:	83 ec 04             	sub    $0x4,%esp
  8081ea:	68 cb 25 81 00       	push   $0x8125cb
  8081ef:	68 52 01 00 00       	push   $0x152
  8081f4:	68 a6 25 81 00       	push   $0x8125a6
  8081f9:	e8 39 67 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  8081fe:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  808202:	75 87                	jne    80818b <tcp_enqueue+0x5d2>
  808204:	83 ec 04             	sub    $0x4,%esp
  808207:	68 58 25 81 00       	push   $0x812558
  80820c:	68 79 01 00 00       	push   $0x179
  808211:	68 a6 25 81 00       	push   $0x8125a6
  808216:	e8 1c 67 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80821b:	83 ec 04             	sub    $0x4,%esp
  80821e:	68 58 25 81 00       	push   $0x812558
  808223:	68 8c 01 00 00       	push   $0x18c
  808228:	68 a6 25 81 00       	push   $0x8125a6
  80822d:	e8 05 67 00 00       	call   80e937 <_panic>
  return ERR_OK;
  808232:	b8 00 00 00 00       	mov    $0x0,%eax
  808237:	e9 ab fe ff ff       	jmp    8080e7 <tcp_enqueue+0x52e>
  return ERR_MEM;
  80823c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808241:	e9 a1 fe ff ff       	jmp    8080e7 <tcp_enqueue+0x52e>
  808246:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80824b:	e9 97 fe ff ff       	jmp    8080e7 <tcp_enqueue+0x52e>
      pcb->unsent = queue;
  808250:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808253:	89 47 74             	mov    %eax,0x74(%edi)
  808256:	e9 f1 fe ff ff       	jmp    80814c <tcp_enqueue+0x593>

0080825b <tcp_send_ctrl>:
{
  80825b:	f3 0f 1e fb          	endbr32 
  80825f:	55                   	push   %ebp
  808260:	89 e5                	mov    %esp,%ebp
  808262:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  808265:	6a 00                	push   $0x0
  808267:	6a 00                	push   $0x0
  808269:	6a 01                	push   $0x1
  80826b:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80826f:	50                   	push   %eax
  808270:	6a 00                	push   $0x0
  808272:	6a 00                	push   $0x0
  808274:	ff 75 08             	pushl  0x8(%ebp)
  808277:	e8 3d f9 ff ff       	call   807bb9 <tcp_enqueue>
}
  80827c:	c9                   	leave  
  80827d:	c3                   	ret    

0080827e <tcp_write>:
{
  80827e:	f3 0f 1e fb          	endbr32 
  808282:	55                   	push   %ebp
  808283:	89 e5                	mov    %esp,%ebp
  808285:	56                   	push   %esi
  808286:	53                   	push   %ebx
  808287:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80828a:	8b 55 10             	mov    0x10(%ebp),%edx
  80828d:	8b 75 14             	mov    0x14(%ebp),%esi
  if (pcb->state == ESTABLISHED ||
  808290:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  808293:	8d 58 fe             	lea    -0x2(%eax),%ebx
     pcb->state == SYN_SENT ||
  808296:	83 fb 02             	cmp    $0x2,%ebx
  808299:	76 05                	jbe    8082a0 <tcp_write+0x22>
  80829b:	83 f8 07             	cmp    $0x7,%eax
  80829e:	75 32                	jne    8082d2 <tcp_write+0x54>
    return ERR_OK;
  8082a0:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  8082a5:	66 85 d2             	test   %dx,%dx
  8082a8:	75 07                	jne    8082b1 <tcp_write+0x33>
}
  8082aa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8082ad:	5b                   	pop    %ebx
  8082ae:	5e                   	pop    %esi
  8082af:	5d                   	pop    %ebp
  8082b0:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  8082b1:	83 ec 04             	sub    $0x4,%esp
  8082b4:	6a 00                	push   $0x0
  8082b6:	6a 00                	push   $0x0
  8082b8:	89 f0                	mov    %esi,%eax
  8082ba:	0f b6 f0             	movzbl %al,%esi
  8082bd:	56                   	push   %esi
  8082be:	6a 00                	push   $0x0
  8082c0:	0f b7 d2             	movzwl %dx,%edx
  8082c3:	52                   	push   %edx
  8082c4:	ff 75 0c             	pushl  0xc(%ebp)
  8082c7:	51                   	push   %ecx
  8082c8:	e8 ec f8 ff ff       	call   807bb9 <tcp_enqueue>
  8082cd:	83 c4 20             	add    $0x20,%esp
  8082d0:	eb d8                	jmp    8082aa <tcp_write+0x2c>
    return ERR_CONN;
  8082d2:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  8082d7:	eb d1                	jmp    8082aa <tcp_write+0x2c>

008082d9 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  8082d9:	f3 0f 1e fb          	endbr32 
  8082dd:	55                   	push   %ebp
  8082de:	89 e5                	mov    %esp,%ebp
  8082e0:	57                   	push   %edi
  8082e1:	56                   	push   %esi
  8082e2:	53                   	push   %ebx
  8082e3:	83 ec 1c             	sub    $0x1c,%esp
  8082e6:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  8082e9:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  8082ef:	0f 84 62 04 00 00    	je     808757 <tcp_output+0x47e>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  8082f5:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  8082f9:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  8082fd:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  808302:	0f b7 c0             	movzwl %ax,%eax
  808305:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  808308:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80830b:	8b 47 78             	mov    0x78(%edi),%eax
  80830e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (useg != NULL) {
  808311:	85 c0                	test   %eax,%eax
  808313:	74 0b                	je     808320 <tcp_output+0x47>
  808315:	89 c2                	mov    %eax,%edx
    for (; useg->next != NULL; useg = useg->next);
  808317:	8b 00                	mov    (%eax),%eax
  808319:	85 c0                	test   %eax,%eax
  80831b:	75 f8                	jne    808315 <tcp_output+0x3c>
  80831d:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808320:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  808324:	0f 84 eb 03 00 00    	je     808715 <tcp_output+0x43c>
  80832a:	85 db                	test   %ebx,%ebx
  80832c:	74 25                	je     808353 <tcp_output+0x7a>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80832e:	83 ec 0c             	sub    $0xc,%esp
  808331:	8b 43 10             	mov    0x10(%ebx),%eax
  808334:	ff 70 04             	pushl  0x4(%eax)
  808337:	e8 66 f8 ff ff       	call   807ba2 <ntohl>
  80833c:	89 c2                	mov    %eax,%edx
  80833e:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808342:	2b 47 48             	sub    0x48(%edi),%eax
  808345:	01 d0                	add    %edx,%eax
     (seg == NULL ||
  808347:	83 c4 10             	add    $0x10,%esp
  80834a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  80834d:	0f 86 c2 03 00 00    	jbe    808715 <tcp_output+0x43c>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808353:	83 ec 04             	sub    $0x4,%esp
  808356:	6a 00                	push   $0x0
  808358:	6a 14                	push   $0x14
  80835a:	6a 01                	push   $0x1
  80835c:	e8 84 c7 ff ff       	call   804ae5 <pbuf_alloc>
  808361:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808363:	83 c4 10             	add    $0x10,%esp
  808366:	85 c0                	test   %eax,%eax
  808368:	0f 84 f0 03 00 00    	je     80875e <tcp_output+0x485>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80836e:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  808372:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  808375:	83 ec 0c             	sub    $0xc,%esp
  808378:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80837c:	50                   	push   %eax
  80837d:	e8 d1 f5 ff ff       	call   807953 <htons>
  808382:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  808385:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  808389:	89 04 24             	mov    %eax,(%esp)
  80838c:	e8 c2 f5 ff ff       	call   807953 <htons>
  808391:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  808395:	83 c4 04             	add    $0x4,%esp
  808398:	ff 77 54             	pushl  0x54(%edi)
  80839b:	e8 d5 f5 ff ff       	call   807975 <htonl>
  8083a0:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8083a3:	83 c4 04             	add    $0x4,%esp
  8083a6:	ff 77 24             	pushl  0x24(%edi)
  8083a9:	e8 c7 f5 ff ff       	call   807975 <htonl>
  8083ae:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8083b1:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8083b5:	89 04 24             	mov    %eax,(%esp)
  8083b8:	e8 a7 f5 ff ff       	call   807964 <ntohs>
  8083bd:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8083c2:	83 c8 10             	or     $0x10,%eax
  8083c5:	89 04 24             	mov    %eax,(%esp)
  8083c8:	e8 86 f5 ff ff       	call   807953 <htons>
  8083cd:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8083d1:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8083d5:	89 04 24             	mov    %eax,(%esp)
  8083d8:	e8 76 f5 ff ff       	call   807953 <htons>
  8083dd:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  8083e1:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  8083e7:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8083eb:	89 04 24             	mov    %eax,(%esp)
  8083ee:	e8 71 f5 ff ff       	call   807964 <ntohs>
  8083f3:	83 e0 3f             	and    $0x3f,%eax
  8083f6:	80 cc 50             	or     $0x50,%ah
  8083f9:	89 04 24             	mov    %eax,(%esp)
  8083fc:	e8 52 f5 ff ff       	call   807953 <htons>
  808401:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808405:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80840b:	8d 47 04             	lea    0x4(%edi),%eax
  80840e:	89 c1                	mov    %eax,%ecx
  808410:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808414:	89 04 24             	mov    %eax,(%esp)
  808417:	6a 06                	push   $0x6
  808419:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80841c:	51                   	push   %ecx
  80841d:	57                   	push   %edi
  80841e:	56                   	push   %esi
  80841f:	e8 f7 f1 ff ff       	call   80761b <inet_chksum_pseudo>
  808424:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808428:	83 c4 18             	add    $0x18,%esp
  80842b:	6a 06                	push   $0x6
  80842d:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808431:	50                   	push   %eax
  808432:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808436:	50                   	push   %eax
  808437:	ff 75 e4             	pushl  -0x1c(%ebp)
  80843a:	57                   	push   %edi
  80843b:	56                   	push   %esi
  80843c:	e8 ea e7 ff ff       	call   806c2b <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  808441:	83 c4 14             	add    $0x14,%esp
  808444:	56                   	push   %esi
  808445:	e8 d1 c5 ff ff       	call   804a1b <pbuf_free>

    return ERR_OK;
  80844a:	83 c4 10             	add    $0x10,%esp
  80844d:	b8 00 00 00 00       	mov    $0x0,%eax
  808452:	e9 20 03 00 00       	jmp    808777 <tcp_output+0x49e>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  808457:	83 ec 04             	sub    $0x4,%esp
  80845a:	68 df 25 81 00       	push   $0x8125df
  80845f:	68 04 02 00 00       	push   $0x204
  808464:	68 a6 25 81 00       	push   $0x8125a6
  808469:	e8 c9 64 00 00       	call   80e937 <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80846e:	83 ec 0c             	sub    $0xc,%esp
  808471:	8b 43 10             	mov    0x10(%ebx),%eax
  808474:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808478:	50                   	push   %eax
  808479:	e8 e6 f4 ff ff       	call   807964 <ntohs>
  80847e:	8b 73 10             	mov    0x10(%ebx),%esi
  808481:	83 c8 10             	or     $0x10,%eax
  808484:	0f b7 c0             	movzwl %ax,%eax
  808487:	89 04 24             	mov    %eax,(%esp)
  80848a:	e8 c4 f4 ff ff       	call   807953 <htons>
  80848f:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808493:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  808497:	83 c4 10             	add    $0x10,%esp
  80849a:	e9 06 01 00 00       	jmp    8085a5 <tcp_output+0x2cc>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  80849f:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  8084a5:	e9 49 01 00 00       	jmp    8085f3 <tcp_output+0x31a>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  8084aa:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8084af:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8084b2:	83 ec 0c             	sub    $0xc,%esp
  8084b5:	8b 43 10             	mov    0x10(%ebx),%eax
  8084b8:	ff 70 04             	pushl  0x4(%eax)
  8084bb:	e8 e2 f6 ff ff       	call   807ba2 <ntohl>
  8084c0:	89 47 3c             	mov    %eax,0x3c(%edi)
  8084c3:	83 c4 10             	add    $0x10,%esp
  8084c6:	e9 32 01 00 00       	jmp    8085fd <tcp_output+0x324>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8084cb:	83 ec 0c             	sub    $0xc,%esp
  8084ce:	8b 43 10             	mov    0x10(%ebx),%eax
  8084d1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084d5:	50                   	push   %eax
  8084d6:	e8 89 f4 ff ff       	call   807964 <ntohs>
  8084db:	66 d1 e8             	shr    %ax
  8084de:	83 e0 01             	and    $0x1,%eax
  8084e1:	83 c4 10             	add    $0x10,%esp
  8084e4:	e9 aa 01 00 00       	jmp    808693 <tcp_output+0x3ba>
      pcb->snd_max = pcb->snd_nxt;
  8084e9:	89 77 58             	mov    %esi,0x58(%edi)
  8084ec:	e9 b3 01 00 00       	jmp    8086a4 <tcp_output+0x3cb>
    if (TCP_TCPLEN(seg) > 0) {
  8084f1:	83 ec 0c             	sub    $0xc,%esp
  8084f4:	8b 43 10             	mov    0x10(%ebx),%eax
  8084f7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084fb:	50                   	push   %eax
  8084fc:	e8 63 f4 ff ff       	call   807964 <ntohs>
  808501:	66 d1 e8             	shr    %ax
  808504:	83 e0 01             	and    $0x1,%eax
  808507:	0f b7 f6             	movzwl %si,%esi
  80850a:	83 c4 10             	add    $0x10,%esp
  80850d:	01 f0                	add    %esi,%eax
  80850f:	0f 85 ae 01 00 00    	jne    8086c3 <tcp_output+0x3ea>
      tcp_seg_free(seg);
  808515:	83 ec 0c             	sub    $0xc,%esp
  808518:	53                   	push   %ebx
  808519:	e8 53 d4 ff ff       	call   805971 <tcp_seg_free>
  80851e:	83 c4 10             	add    $0x10,%esp
  808521:	eb 06                	jmp    808529 <tcp_output+0x250>
        pcb->unacked = seg;
  808523:	89 5f 78             	mov    %ebx,0x78(%edi)
  808526:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  808529:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  80852c:	85 db                	test   %ebx,%ebx
  80852e:	0f 84 3a 02 00 00    	je     80876e <tcp_output+0x495>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808534:	83 ec 0c             	sub    $0xc,%esp
  808537:	8b 43 10             	mov    0x10(%ebx),%eax
  80853a:	ff 70 04             	pushl  0x4(%eax)
  80853d:	e8 60 f6 ff ff       	call   807ba2 <ntohl>
  808542:	89 c2                	mov    %eax,%edx
  808544:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808548:	2b 47 48             	sub    0x48(%edi),%eax
  80854b:	01 d0                	add    %edx,%eax
  while (seg != NULL &&
  80854d:	83 c4 10             	add    $0x10,%esp
  808550:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  808553:	0f 87 0c 02 00 00    	ja     808765 <tcp_output+0x48c>
    LWIP_ASSERT("RST not expected here!", 
  808559:	83 ec 0c             	sub    $0xc,%esp
  80855c:	8b 43 10             	mov    0x10(%ebx),%eax
  80855f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808563:	50                   	push   %eax
  808564:	e8 fb f3 ff ff       	call   807964 <ntohs>
  808569:	83 c4 10             	add    $0x10,%esp
  80856c:	a8 04                	test   $0x4,%al
  80856e:	0f 85 e3 fe ff ff    	jne    808457 <tcp_output+0x17e>
    if((tcp_do_output_nagle(pcb) == 0) &&
  808574:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808578:	74 1c                	je     808596 <tcp_output+0x2bd>
  80857a:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80857e:	a8 40                	test   $0x40,%al
  808580:	75 14                	jne    808596 <tcp_output+0x2bd>
  808582:	8b 57 74             	mov    0x74(%edi),%edx
  808585:	85 d2                	test   %edx,%edx
  808587:	74 05                	je     80858e <tcp_output+0x2b5>
  808589:	83 3a 00             	cmpl   $0x0,(%edx)
  80858c:	75 08                	jne    808596 <tcp_output+0x2bd>
  80858e:	a8 a0                	test   $0xa0,%al
  808590:	0f 84 cf 01 00 00    	je     808765 <tcp_output+0x48c>
    pcb->unsent = seg->next;
  808596:	8b 03                	mov    (%ebx),%eax
  808598:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  80859b:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  80859f:	0f 85 c9 fe ff ff    	jne    80846e <tcp_output+0x195>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8085a5:	8b 73 10             	mov    0x10(%ebx),%esi
  8085a8:	83 ec 0c             	sub    $0xc,%esp
  8085ab:	ff 77 24             	pushl  0x24(%edi)
  8085ae:	e8 c2 f3 ff ff       	call   807975 <htonl>
  8085b3:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8085b6:	8b 73 10             	mov    0x10(%ebx),%esi
  8085b9:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8085bd:	89 04 24             	mov    %eax,(%esp)
  8085c0:	e8 8e f3 ff ff       	call   807953 <htons>
  8085c5:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  8085c9:	83 c4 10             	add    $0x10,%esp
  8085cc:	83 3f 00             	cmpl   $0x0,(%edi)
  8085cf:	75 17                	jne    8085e8 <tcp_output+0x30f>
    netif = ip_route(&(pcb->remote_ip));
  8085d1:	83 ec 0c             	sub    $0xc,%esp
  8085d4:	ff 75 e4             	pushl  -0x1c(%ebp)
  8085d7:	e8 42 e1 ff ff       	call   80671e <ip_route>
    if (netif == NULL) {
  8085dc:	83 c4 10             	add    $0x10,%esp
  8085df:	85 c0                	test   %eax,%eax
  8085e1:	74 79                	je     80865c <tcp_output+0x383>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8085e3:	8b 40 04             	mov    0x4(%eax),%eax
  8085e6:	89 07                	mov    %eax,(%edi)
  if(pcb->rtime == -1)
  8085e8:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  8085ed:	0f 84 ac fe ff ff    	je     80849f <tcp_output+0x1c6>
  if (pcb->rttest == 0) {
  8085f3:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  8085f7:	0f 84 ad fe ff ff    	je     8084aa <tcp_output+0x1d1>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  8085fd:	8b 53 04             	mov    0x4(%ebx),%edx
  808600:	8b 43 10             	mov    0x10(%ebx),%eax
  808603:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  808606:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  80860a:	8b 53 04             	mov    0x4(%ebx),%edx
  80860d:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  808611:	8b 53 04             	mov    0x4(%ebx),%edx
  808614:	8b 43 10             	mov    0x10(%ebx),%eax
  808617:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  80861a:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808620:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808623:	8b 73 10             	mov    0x10(%ebx),%esi
  808626:	83 ec 0c             	sub    $0xc,%esp
  808629:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80862d:	52                   	push   %edx
  80862e:	6a 06                	push   $0x6
  808630:	ff 75 e4             	pushl  -0x1c(%ebp)
  808633:	57                   	push   %edi
  808634:	50                   	push   %eax
  808635:	e8 e1 ef ff ff       	call   80761b <inet_chksum_pseudo>
  80863a:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80863e:	83 c4 18             	add    $0x18,%esp
  808641:	6a 06                	push   $0x6
  808643:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808647:	50                   	push   %eax
  808648:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80864c:	50                   	push   %eax
  80864d:	ff 75 e4             	pushl  -0x1c(%ebp)
  808650:	57                   	push   %edi
  808651:	ff 73 04             	pushl  0x4(%ebx)
  808654:	e8 d2 e5 ff ff       	call   806c2b <ip_output>
  808659:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80865c:	83 ec 0c             	sub    $0xc,%esp
  80865f:	8b 43 10             	mov    0x10(%ebx),%eax
  808662:	ff 70 04             	pushl  0x4(%eax)
  808665:	e8 38 f5 ff ff       	call   807ba2 <ntohl>
  80866a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80866d:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808671:	8b 43 10             	mov    0x10(%ebx),%eax
  808674:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808678:	89 04 24             	mov    %eax,(%esp)
  80867b:	e8 e4 f2 ff ff       	call   807964 <ntohs>
  808680:	89 c2                	mov    %eax,%edx
  808682:	83 c4 10             	add    $0x10,%esp
  808685:	b8 01 00 00 00       	mov    $0x1,%eax
  80868a:	f6 c2 01             	test   $0x1,%dl
  80868d:	0f 84 38 fe ff ff    	je     8084cb <tcp_output+0x1f2>
  808693:	01 c6                	add    %eax,%esi
  808695:	03 75 e0             	add    -0x20(%ebp),%esi
  808698:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80869b:	39 77 58             	cmp    %esi,0x58(%edi)
  80869e:	0f 88 45 fe ff ff    	js     8084e9 <tcp_output+0x210>
    if (TCP_TCPLEN(seg) > 0) {
  8086a4:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8086a8:	83 ec 0c             	sub    $0xc,%esp
  8086ab:	8b 43 10             	mov    0x10(%ebx),%eax
  8086ae:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8086b2:	50                   	push   %eax
  8086b3:	e8 ac f2 ff ff       	call   807964 <ntohs>
  8086b8:	83 c4 10             	add    $0x10,%esp
  8086bb:	a8 01                	test   $0x1,%al
  8086bd:	0f 84 2e fe ff ff    	je     8084f1 <tcp_output+0x218>
      seg->next = NULL;
  8086c3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  8086c9:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8086cd:	0f 84 50 fe ff ff    	je     808523 <tcp_output+0x24a>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8086d3:	83 ec 0c             	sub    $0xc,%esp
  8086d6:	8b 43 10             	mov    0x10(%ebx),%eax
  8086d9:	ff 70 04             	pushl  0x4(%eax)
  8086dc:	e8 c1 f4 ff ff       	call   807ba2 <ntohl>
  8086e1:	89 c6                	mov    %eax,%esi
  8086e3:	83 c4 04             	add    $0x4,%esp
  8086e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8086e9:	8b 40 10             	mov    0x10(%eax),%eax
  8086ec:	ff 70 04             	pushl  0x4(%eax)
  8086ef:	e8 ae f4 ff ff       	call   807ba2 <ntohl>
  8086f4:	83 c4 10             	add    $0x10,%esp
  8086f7:	39 c6                	cmp    %eax,%esi
  8086f9:	78 0d                	js     808708 <tcp_output+0x42f>
          useg->next = seg;
  8086fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8086fe:	89 18                	mov    %ebx,(%eax)
  808700:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808703:	e9 21 fe ff ff       	jmp    808529 <tcp_output+0x250>
          seg->next = pcb->unacked;
  808708:	8b 47 78             	mov    0x78(%edi),%eax
  80870b:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80870d:	89 5f 78             	mov    %ebx,0x78(%edi)
  808710:	e9 14 fe ff ff       	jmp    808529 <tcp_output+0x250>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808715:	8d 47 04             	lea    0x4(%edi),%eax
  808718:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80871b:	e9 0c fe ff ff       	jmp    80852c <tcp_output+0x253>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808720:	83 ec 0c             	sub    $0xc,%esp
  808723:	8b 43 10             	mov    0x10(%ebx),%eax
  808726:	ff 70 04             	pushl  0x4(%eax)
  808729:	e8 74 f4 ff ff       	call   807ba2 <ntohl>
  80872e:	89 c2                	mov    %eax,%edx
  808730:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808734:	2b 47 48             	sub    0x48(%edi),%eax
  808737:	01 d0                	add    %edx,%eax
  808739:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  if (seg != NULL && pcb->persist_backoff == 0 && 
  80873d:	83 c4 10             	add    $0x10,%esp
  808740:	39 d0                	cmp    %edx,%eax
  808742:	76 2a                	jbe    80876e <tcp_output+0x495>
    pcb->persist_cnt = 0;
  808744:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  80874b:	00 00 00 
    pcb->persist_backoff = 1;
  80874e:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  808755:	eb 17                	jmp    80876e <tcp_output+0x495>
    return ERR_OK;
  808757:	b8 00 00 00 00       	mov    $0x0,%eax
  80875c:	eb 19                	jmp    808777 <tcp_output+0x49e>
      return ERR_BUF;
  80875e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808763:	eb 12                	jmp    808777 <tcp_output+0x49e>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  808765:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80876c:	74 b2                	je     808720 <tcp_output+0x447>
  pcb->flags &= ~TF_NAGLEMEMERR;
  80876e:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808772:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808777:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80877a:	5b                   	pop    %ebx
  80877b:	5e                   	pop    %esi
  80877c:	5f                   	pop    %edi
  80877d:	5d                   	pop    %ebp
  80877e:	c3                   	ret    

0080877f <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80877f:	f3 0f 1e fb          	endbr32 
  808783:	55                   	push   %ebp
  808784:	89 e5                	mov    %esp,%ebp
  808786:	57                   	push   %edi
  808787:	56                   	push   %esi
  808788:	53                   	push   %ebx
  808789:	83 ec 20             	sub    $0x20,%esp
  80878c:	8b 7d 18             	mov    0x18(%ebp),%edi
  80878f:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808792:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808795:	6a 00                	push   $0x0
  808797:	6a 14                	push   $0x14
  808799:	6a 01                	push   $0x1
  80879b:	e8 45 c3 ff ff       	call   804ae5 <pbuf_alloc>
  if (p == NULL) {
  8087a0:	83 c4 10             	add    $0x10,%esp
  8087a3:	85 c0                	test   %eax,%eax
  8087a5:	0f 84 e2 00 00 00    	je     80888d <tcp_rst+0x10e>
  8087ab:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087ad:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8087b2:	0f 86 dd 00 00 00    	jbe    808895 <tcp_rst+0x116>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8087b8:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8087bb:	83 ec 0c             	sub    $0xc,%esp
  8087be:	0f b7 ff             	movzwl %di,%edi
  8087c1:	57                   	push   %edi
  8087c2:	e8 8c f1 ff ff       	call   807953 <htons>
  8087c7:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  8087ca:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8087ce:	89 04 24             	mov    %eax,(%esp)
  8087d1:	e8 7d f1 ff ff       	call   807953 <htons>
  8087d6:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  8087da:	83 c4 04             	add    $0x4,%esp
  8087dd:	ff 75 08             	pushl  0x8(%ebp)
  8087e0:	e8 90 f1 ff ff       	call   807975 <htonl>
  8087e5:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  8087e8:	83 c4 04             	add    $0x4,%esp
  8087eb:	ff 75 0c             	pushl  0xc(%ebp)
  8087ee:	e8 82 f1 ff ff       	call   807975 <htonl>
  8087f3:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  8087f6:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8087fa:	89 04 24             	mov    %eax,(%esp)
  8087fd:	e8 62 f1 ff ff       	call   807964 <ntohs>
  808802:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808807:	83 c8 14             	or     $0x14,%eax
  80880a:	89 04 24             	mov    %eax,(%esp)
  80880d:	e8 41 f1 ff ff       	call   807953 <htons>
  808812:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808816:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80881d:	e8 31 f1 ff ff       	call   807953 <htons>
  808822:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808826:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80882c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808830:	89 04 24             	mov    %eax,(%esp)
  808833:	e8 2c f1 ff ff       	call   807964 <ntohs>
  808838:	83 e0 3f             	and    $0x3f,%eax
  80883b:	80 cc 50             	or     $0x50,%ah
  80883e:	89 04 24             	mov    %eax,(%esp)
  808841:	e8 0d f1 ff ff       	call   807953 <htons>
  808846:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80884a:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808850:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808854:	89 04 24             	mov    %eax,(%esp)
  808857:	6a 06                	push   $0x6
  808859:	ff 75 14             	pushl  0x14(%ebp)
  80885c:	ff 75 10             	pushl  0x10(%ebp)
  80885f:	56                   	push   %esi
  808860:	e8 b6 ed ff ff       	call   80761b <inet_chksum_pseudo>
  808865:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808869:	83 c4 18             	add    $0x18,%esp
  80886c:	6a 06                	push   $0x6
  80886e:	6a 00                	push   $0x0
  808870:	68 ff 00 00 00       	push   $0xff
  808875:	ff 75 14             	pushl  0x14(%ebp)
  808878:	ff 75 10             	pushl  0x10(%ebp)
  80887b:	56                   	push   %esi
  80887c:	e8 aa e3 ff ff       	call   806c2b <ip_output>
  pbuf_free(p);
  808881:	83 c4 14             	add    $0x14,%esp
  808884:	56                   	push   %esi
  808885:	e8 91 c1 ff ff       	call   804a1b <pbuf_free>
  80888a:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80888d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808890:	5b                   	pop    %ebx
  808891:	5e                   	pop    %esi
  808892:	5f                   	pop    %edi
  808893:	5d                   	pop    %ebp
  808894:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808895:	83 ec 04             	sub    $0x4,%esp
  808898:	68 78 25 81 00       	push   $0x812578
  80889d:	68 bd 02 00 00       	push   $0x2bd
  8088a2:	68 a6 25 81 00       	push   $0x8125a6
  8088a7:	e8 8b 60 00 00       	call   80e937 <_panic>

008088ac <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8088ac:	f3 0f 1e fb          	endbr32 
  8088b0:	55                   	push   %ebp
  8088b1:	89 e5                	mov    %esp,%ebp
  8088b3:	53                   	push   %ebx
  8088b4:	83 ec 04             	sub    $0x4,%esp
  8088b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8088ba:	8b 43 78             	mov    0x78(%ebx),%eax
  8088bd:	85 c0                	test   %eax,%eax
  8088bf:	74 41                	je     808902 <tcp_rexmit_rto+0x56>
  8088c1:	89 c2                	mov    %eax,%edx
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8088c3:	8b 00                	mov    (%eax),%eax
  8088c5:	85 c0                	test   %eax,%eax
  8088c7:	75 f8                	jne    8088c1 <tcp_rexmit_rto+0x15>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8088c9:	8b 43 74             	mov    0x74(%ebx),%eax
  8088cc:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8088ce:	8b 43 78             	mov    0x78(%ebx),%eax
  8088d1:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8088d4:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8088db:	83 ec 0c             	sub    $0xc,%esp
  8088de:	8b 40 10             	mov    0x10(%eax),%eax
  8088e1:	ff 70 04             	pushl  0x4(%eax)
  8088e4:	e8 b9 f2 ff ff       	call   807ba2 <ntohl>
  8088e9:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8088ec:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8088f0:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8088f7:	89 1c 24             	mov    %ebx,(%esp)
  8088fa:	e8 da f9 ff ff       	call   8082d9 <tcp_output>
  8088ff:	83 c4 10             	add    $0x10,%esp
}
  808902:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808905:	c9                   	leave  
  808906:	c3                   	ret    

00808907 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808907:	f3 0f 1e fb          	endbr32 
  80890b:	55                   	push   %ebp
  80890c:	89 e5                	mov    %esp,%ebp
  80890e:	53                   	push   %ebx
  80890f:	83 ec 04             	sub    $0x4,%esp
  808912:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808915:	8b 43 78             	mov    0x78(%ebx),%eax
  808918:	85 c0                	test   %eax,%eax
  80891a:	74 37                	je     808953 <tcp_rexmit+0x4c>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  80891c:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  80891e:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808921:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808923:	8b 43 78             	mov    0x78(%ebx),%eax
  808926:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808929:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80892c:	83 ec 0c             	sub    $0xc,%esp
  80892f:	8b 40 10             	mov    0x10(%eax),%eax
  808932:	ff 70 04             	pushl  0x4(%eax)
  808935:	e8 68 f2 ff ff       	call   807ba2 <ntohl>
  80893a:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80893d:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808941:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808948:	89 1c 24             	mov    %ebx,(%esp)
  80894b:	e8 89 f9 ff ff       	call   8082d9 <tcp_output>
  808950:	83 c4 10             	add    $0x10,%esp
}
  808953:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808956:	c9                   	leave  
  808957:	c3                   	ret    

00808958 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808958:	f3 0f 1e fb          	endbr32 
  80895c:	55                   	push   %ebp
  80895d:	89 e5                	mov    %esp,%ebp
  80895f:	57                   	push   %edi
  808960:	56                   	push   %esi
  808961:	53                   	push   %ebx
  808962:	83 ec 20             	sub    $0x20,%esp
  808965:	8b 7d 08             	mov    0x8(%ebp),%edi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808968:	6a 00                	push   $0x0
  80896a:	6a 14                	push   $0x14
  80896c:	6a 01                	push   $0x1
  80896e:	e8 72 c1 ff ff       	call   804ae5 <pbuf_alloc>
   
  if(p == NULL) {
  808973:	83 c4 10             	add    $0x10,%esp
  808976:	85 c0                	test   %eax,%eax
  808978:	0f 84 e5 00 00 00    	je     808a63 <tcp_keepalive+0x10b>
  80897e:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808980:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808985:	0f 86 e0 00 00 00    	jbe    808a6b <tcp_keepalive+0x113>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80898b:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80898e:	83 ec 0c             	sub    $0xc,%esp
  808991:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  808995:	50                   	push   %eax
  808996:	e8 b8 ef ff ff       	call   807953 <htons>
  80899b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80899e:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8089a2:	89 04 24             	mov    %eax,(%esp)
  8089a5:	e8 a9 ef ff ff       	call   807953 <htons>
  8089aa:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8089ae:	8b 47 54             	mov    0x54(%edi),%eax
  8089b1:	83 e8 01             	sub    $0x1,%eax
  8089b4:	89 04 24             	mov    %eax,(%esp)
  8089b7:	e8 b9 ef ff ff       	call   807975 <htonl>
  8089bc:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8089bf:	83 c4 04             	add    $0x4,%esp
  8089c2:	ff 77 24             	pushl  0x24(%edi)
  8089c5:	e8 ab ef ff ff       	call   807975 <htonl>
  8089ca:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8089cd:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8089d1:	89 04 24             	mov    %eax,(%esp)
  8089d4:	e8 8b ef ff ff       	call   807964 <ntohs>
  8089d9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8089de:	89 04 24             	mov    %eax,(%esp)
  8089e1:	e8 6d ef ff ff       	call   807953 <htons>
  8089e6:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8089ea:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8089ee:	89 04 24             	mov    %eax,(%esp)
  8089f1:	e8 5d ef ff ff       	call   807953 <htons>
  8089f6:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  8089fa:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808a00:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808a04:	89 04 24             	mov    %eax,(%esp)
  808a07:	e8 58 ef ff ff       	call   807964 <ntohs>
  808a0c:	83 e0 3f             	and    $0x3f,%eax
  808a0f:	80 cc 50             	or     $0x50,%ah
  808a12:	89 04 24             	mov    %eax,(%esp)
  808a15:	e8 39 ef ff ff       	call   807953 <htons>
  808a1a:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808a1e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808a24:	8d 47 04             	lea    0x4(%edi),%eax
  808a27:	89 c2                	mov    %eax,%edx
  808a29:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808a2d:	89 04 24             	mov    %eax,(%esp)
  808a30:	6a 06                	push   $0x6
  808a32:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808a35:	52                   	push   %edx
  808a36:	57                   	push   %edi
  808a37:	56                   	push   %esi
  808a38:	e8 de eb ff ff       	call   80761b <inet_chksum_pseudo>
  808a3d:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808a41:	83 c4 18             	add    $0x18,%esp
  808a44:	6a 06                	push   $0x6
  808a46:	6a 00                	push   $0x0
  808a48:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808a4c:	50                   	push   %eax
  808a4d:	ff 75 e4             	pushl  -0x1c(%ebp)
  808a50:	57                   	push   %edi
  808a51:	56                   	push   %esi
  808a52:	e8 d4 e1 ff ff       	call   806c2b <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808a57:	83 c4 14             	add    $0x14,%esp
  808a5a:	56                   	push   %esi
  808a5b:	e8 bb bf ff ff       	call   804a1b <pbuf_free>
  808a60:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808a63:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808a66:	5b                   	pop    %ebx
  808a67:	5e                   	pop    %esi
  808a68:	5f                   	pop    %edi
  808a69:	5d                   	pop    %ebp
  808a6a:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808a6b:	83 ec 04             	sub    $0x4,%esp
  808a6e:	68 78 25 81 00       	push   $0x812578
  808a73:	68 39 03 00 00       	push   $0x339
  808a78:	68 a6 25 81 00       	push   $0x8125a6
  808a7d:	e8 b5 5e 00 00       	call   80e937 <_panic>

00808a82 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808a82:	f3 0f 1e fb          	endbr32 
  808a86:	55                   	push   %ebp
  808a87:	89 e5                	mov    %esp,%ebp
  808a89:	57                   	push   %edi
  808a8a:	56                   	push   %esi
  808a8b:	53                   	push   %ebx
  808a8c:	83 ec 1c             	sub    $0x1c,%esp
  808a8f:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808a92:	8b 46 78             	mov    0x78(%esi),%eax
  808a95:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808a98:	85 c0                	test   %eax,%eax
  808a9a:	0f 84 10 01 00 00    	je     808bb0 <tcp_zero_window_probe+0x12e>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808aa0:	83 ec 04             	sub    $0x4,%esp
  808aa3:	6a 00                	push   $0x0
  808aa5:	6a 15                	push   $0x15
  808aa7:	6a 01                	push   $0x1
  808aa9:	e8 37 c0 ff ff       	call   804ae5 <pbuf_alloc>
  808aae:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808ab0:	83 c4 10             	add    $0x10,%esp
  808ab3:	85 c0                	test   %eax,%eax
  808ab5:	0f 84 ed 00 00 00    	je     808ba8 <tcp_zero_window_probe+0x126>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808abb:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808ac0:	0f 86 f9 00 00 00    	jbe    808bbf <tcp_zero_window_probe+0x13d>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808ac6:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808ac9:	83 ec 0c             	sub    $0xc,%esp
  808acc:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808ad0:	50                   	push   %eax
  808ad1:	e8 7d ee ff ff       	call   807953 <htons>
  808ad6:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808ad9:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808add:	89 04 24             	mov    %eax,(%esp)
  808ae0:	e8 6e ee ff ff       	call   807953 <htons>
  808ae5:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808ae9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808aec:	8b 40 10             	mov    0x10(%eax),%eax
  808aef:	8b 40 04             	mov    0x4(%eax),%eax
  808af2:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808af5:	83 c4 04             	add    $0x4,%esp
  808af8:	ff 76 24             	pushl  0x24(%esi)
  808afb:	e8 75 ee ff ff       	call   807975 <htonl>
  808b00:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808b03:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808b07:	89 04 24             	mov    %eax,(%esp)
  808b0a:	e8 55 ee ff ff       	call   807964 <ntohs>
  808b0f:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808b14:	89 04 24             	mov    %eax,(%esp)
  808b17:	e8 37 ee ff ff       	call   807953 <htons>
  808b1c:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808b20:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808b24:	89 04 24             	mov    %eax,(%esp)
  808b27:	e8 27 ee ff ff       	call   807953 <htons>
  808b2c:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808b30:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808b36:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808b3a:	89 04 24             	mov    %eax,(%esp)
  808b3d:	e8 22 ee ff ff       	call   807964 <ntohs>
  808b42:	83 e0 3f             	and    $0x3f,%eax
  808b45:	80 cc 50             	or     $0x50,%ah
  808b48:	89 04 24             	mov    %eax,(%esp)
  808b4b:	e8 03 ee ff ff       	call   807953 <htons>
  808b50:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808b54:	8b 47 04             	mov    0x4(%edi),%eax
  808b57:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808b5a:	8b 51 08             	mov    0x8(%ecx),%edx
  808b5d:	0f b6 12             	movzbl (%edx),%edx
  808b60:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808b63:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808b69:	8d 46 04             	lea    0x4(%esi),%eax
  808b6c:	89 c1                	mov    %eax,%ecx
  808b6e:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808b72:	89 04 24             	mov    %eax,(%esp)
  808b75:	6a 06                	push   $0x6
  808b77:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808b7a:	51                   	push   %ecx
  808b7b:	56                   	push   %esi
  808b7c:	57                   	push   %edi
  808b7d:	e8 99 ea ff ff       	call   80761b <inet_chksum_pseudo>
  808b82:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808b86:	83 c4 18             	add    $0x18,%esp
  808b89:	6a 06                	push   $0x6
  808b8b:	6a 00                	push   $0x0
  808b8d:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808b91:	50                   	push   %eax
  808b92:	ff 75 e4             	pushl  -0x1c(%ebp)
  808b95:	56                   	push   %esi
  808b96:	57                   	push   %edi
  808b97:	e8 8f e0 ff ff       	call   806c2b <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808b9c:	83 c4 14             	add    $0x14,%esp
  808b9f:	57                   	push   %edi
  808ba0:	e8 76 be ff ff       	call   804a1b <pbuf_free>
  808ba5:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808ba8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808bab:	5b                   	pop    %ebx
  808bac:	5e                   	pop    %esi
  808bad:	5f                   	pop    %edi
  808bae:	5d                   	pop    %ebp
  808baf:	c3                   	ret    
    seg = pcb->unsent;
  808bb0:	8b 46 74             	mov    0x74(%esi),%eax
  808bb3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(seg == NULL)
  808bb6:	85 c0                	test   %eax,%eax
  808bb8:	74 ee                	je     808ba8 <tcp_zero_window_probe+0x126>
  808bba:	e9 e1 fe ff ff       	jmp    808aa0 <tcp_zero_window_probe+0x1e>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808bbf:	83 ec 04             	sub    $0x4,%esp
  808bc2:	68 78 25 81 00       	push   $0x812578
  808bc7:	68 8c 03 00 00       	push   $0x38c
  808bcc:	68 a6 25 81 00       	push   $0x8125a6
  808bd1:	e8 61 5d 00 00       	call   80e937 <_panic>

00808bd6 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  808bd6:	f3 0f 1e fb          	endbr32 
  808bda:	55                   	push   %ebp
  808bdb:	89 e5                	mov    %esp,%ebp
  808bdd:	57                   	push   %edi
  808bde:	56                   	push   %esi
  808bdf:	53                   	push   %ebx
  808be0:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808be3:	8b 45 08             	mov    0x8(%ebp),%eax
  808be6:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  808be9:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  808bed:	0f b7 07             	movzwl (%edi),%eax
  808bf0:	50                   	push   %eax
  808bf1:	e8 6e ed ff ff       	call   807964 <ntohs>
  808bf6:	66 c1 e8 08          	shr    $0x8,%ax
  808bfa:	83 e0 0f             	and    $0xf,%eax
  808bfd:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808c04:	83 c4 10             	add    $0x10,%esp
  808c07:	39 c3                	cmp    %eax,%ebx
  808c09:	7c 29                	jl     808c34 <udp_input+0x5e>
  808c0b:	83 ec 0c             	sub    $0xc,%esp
  808c0e:	0f b7 07             	movzwl (%edi),%eax
  808c11:	50                   	push   %eax
  808c12:	e8 4d ed ff ff       	call   807964 <ntohs>
  808c17:	83 c4 08             	add    $0x8,%esp
  808c1a:	66 c1 e8 06          	shr    $0x6,%ax
  808c1e:	83 e0 3c             	and    $0x3c,%eax
  808c21:	f7 d8                	neg    %eax
  808c23:	98                   	cwtl   
  808c24:	50                   	push   %eax
  808c25:	ff 75 08             	pushl  0x8(%ebp)
  808c28:	e8 1b bd ff ff       	call   804948 <pbuf_header>
  808c2d:	83 c4 10             	add    $0x10,%esp
  808c30:	84 c0                	test   %al,%al
  808c32:	74 16                	je     808c4a <udp_input+0x74>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808c34:	83 ec 0c             	sub    $0xc,%esp
  808c37:	ff 75 08             	pushl  0x8(%ebp)
  808c3a:	e8 dc bd ff ff       	call   804a1b <pbuf_free>
    goto end;
  808c3f:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808c42:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808c45:	5b                   	pop    %ebx
  808c46:	5e                   	pop    %esi
  808c47:	5f                   	pop    %edi
  808c48:	5d                   	pop    %ebp
  808c49:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  808c4a:	8b 45 08             	mov    0x8(%ebp),%eax
  808c4d:	8b 70 04             	mov    0x4(%eax),%esi
  808c50:	89 75 d8             	mov    %esi,-0x28(%ebp)
  src = ntohs(udphdr->src);
  808c53:	83 ec 0c             	sub    $0xc,%esp
  808c56:	0f b7 06             	movzwl (%esi),%eax
  808c59:	50                   	push   %eax
  808c5a:	e8 05 ed ff ff       	call   807964 <ntohs>
  808c5f:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  808c63:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808c67:	89 04 24             	mov    %eax,(%esp)
  808c6a:	e8 f5 ec ff ff       	call   807964 <ntohs>
  808c6f:	89 c6                	mov    %eax,%esi
  if (dest == DHCP_CLIENT_PORT) {
  808c71:	83 c4 10             	add    $0x10,%esp
  808c74:	66 83 f8 44          	cmp    $0x44,%ax
  808c78:	74 1f                	je     808c99 <udp_input+0xc3>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808c7a:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
    uncon_pcb = NULL;
  808c80:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  808c85:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808c8c:	8d 47 10             	lea    0x10(%edi),%eax
  808c8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  808c92:	89 7d dc             	mov    %edi,-0x24(%ebp)
  808c95:	89 cf                	mov    %ecx,%edi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808c97:	eb 51                	jmp    808cea <udp_input+0x114>
    if (src == DHCP_SERVER_PORT) {
  808c99:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  808c9e:	0f 85 c9 01 00 00    	jne    808e6d <udp_input+0x297>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808ca4:	8b 45 0c             	mov    0xc(%ebp),%eax
  808ca7:	8b 40 20             	mov    0x20(%eax),%eax
  808caa:	85 c0                	test   %eax,%eax
  808cac:	0f 84 bb 01 00 00    	je     808e6d <udp_input+0x297>
  808cb2:	8b 58 08             	mov    0x8(%eax),%ebx
  808cb5:	85 db                	test   %ebx,%ebx
  808cb7:	0f 84 b0 01 00 00    	je     808e6d <udp_input+0x297>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808cbd:	8b 43 04             	mov    0x4(%ebx),%eax
  808cc0:	85 c0                	test   %eax,%eax
  808cc2:	0f 84 b5 01 00 00    	je     808e7d <udp_input+0x2a7>
  808cc8:	3b 47 0c             	cmp    0xc(%edi),%eax
  808ccb:	0f 85 9c 01 00 00    	jne    808e6d <udp_input+0x297>
  808cd1:	e9 a7 01 00 00       	jmp    808e7d <udp_input+0x2a7>
        if ((uncon_pcb == NULL) && 
  808cd6:	85 ff                	test   %edi,%edi
  808cd8:	74 43                	je     808d1d <udp_input+0x147>
      if ((local_match != 0) &&
  808cda:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808cde:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  808ce2:	74 42                	je     808d26 <udp_input+0x150>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808ce4:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808ce7:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808cea:	85 db                	test   %ebx,%ebx
  808cec:	0f 84 6e 01 00 00    	je     808e60 <udp_input+0x28a>
      if ((pcb->local_port == dest) &&
  808cf2:	66 3b 73 12          	cmp    0x12(%ebx),%si
  808cf6:	75 ec                	jne    808ce4 <udp_input+0x10e>
          (ip_addr_isany(&pcb->local_ip) ||
  808cf8:	8b 03                	mov    (%ebx),%eax
  808cfa:	85 c0                	test   %eax,%eax
  808cfc:	74 d8                	je     808cd6 <udp_input+0x100>
  808cfe:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808d01:	3b 41 10             	cmp    0x10(%ecx),%eax
  808d04:	74 d0                	je     808cd6 <udp_input+0x100>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808d06:	83 ec 08             	sub    $0x8,%esp
  808d09:	ff 75 0c             	pushl  0xc(%ebp)
  808d0c:	ff 75 d4             	pushl  -0x2c(%ebp)
  808d0f:	e8 c3 d9 ff ff       	call   8066d7 <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808d14:	83 c4 10             	add    $0x10,%esp
  808d17:	84 c0                	test   %al,%al
  808d19:	74 c9                	je     808ce4 <udp_input+0x10e>
  808d1b:	eb b9                	jmp    808cd6 <udp_input+0x100>
  808d1d:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  808d21:	0f 44 fb             	cmove  %ebx,%edi
  808d24:	eb b4                	jmp    808cda <udp_input+0x104>
          (ip_addr_isany(&pcb->remote_ip) ||
  808d26:	8b 43 04             	mov    0x4(%ebx),%eax
  808d29:	85 c0                	test   %eax,%eax
  808d2b:	74 08                	je     808d35 <udp_input+0x15f>
  808d2d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808d30:	3b 42 0c             	cmp    0xc(%edx),%eax
  808d33:	75 af                	jne    808ce4 <udp_input+0x10e>
  808d35:	8b 7d dc             	mov    -0x24(%ebp),%edi
        if (prev != NULL) {
  808d38:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808d3b:	85 d2                	test   %edx,%edx
  808d3d:	0f 84 3a 01 00 00    	je     808e7d <udp_input+0x2a7>
          prev->next = pcb->next;
  808d43:	8b 43 0c             	mov    0xc(%ebx),%eax
  808d46:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808d49:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808d4e:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808d51:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808d57:	e9 21 01 00 00       	jmp    808e7d <udp_input+0x2a7>
  808d5c:	89 c3                	mov    %eax,%ebx
  808d5e:	e9 1a 01 00 00       	jmp    808e7d <udp_input+0x2a7>
          pbuf_free(p);
  808d63:	83 ec 0c             	sub    $0xc,%esp
  808d66:	ff 75 08             	pushl  0x8(%ebp)
  808d69:	e8 ad bc ff ff       	call   804a1b <pbuf_free>
          goto end;
  808d6e:	83 c4 10             	add    $0x10,%esp
  808d71:	e9 cc fe ff ff       	jmp    808c42 <udp_input+0x6c>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808d76:	83 ec 04             	sub    $0x4,%esp
  808d79:	68 cb 25 81 00       	push   $0x8125cb
  808d7e:	68 0a 01 00 00       	push   $0x10a
  808d83:	68 f6 25 81 00       	push   $0x8125f6
  808d88:	e8 aa 5b 00 00       	call   80e937 <_panic>
        pbuf_free(p);
  808d8d:	83 ec 0c             	sub    $0xc,%esp
  808d90:	ff 75 08             	pushl  0x8(%ebp)
  808d93:	e8 83 bc ff ff       	call   804a1b <pbuf_free>
        goto end;
  808d98:	83 c4 10             	add    $0x10,%esp
  808d9b:	e9 a2 fe ff ff       	jmp    808c42 <udp_input+0x6c>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808da0:	83 ec 08             	sub    $0x8,%esp
  808da3:	ff 75 0c             	pushl  0xc(%ebp)
  808da6:	8d 47 10             	lea    0x10(%edi),%eax
  808da9:	50                   	push   %eax
  808daa:	e8 28 d9 ff ff       	call   8066d7 <ip_addr_isbroadcast>
  808daf:	83 c4 10             	add    $0x10,%esp
  808db2:	84 c0                	test   %al,%al
  808db4:	75 25                	jne    808ddb <udp_input+0x205>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808db6:	8b 5f 10             	mov    0x10(%edi),%ebx
  808db9:	83 ec 0c             	sub    $0xc,%esp
  808dbc:	68 00 00 00 f0       	push   $0xf0000000
  808dc1:	e8 dc ed ff ff       	call   807ba2 <ntohl>
  808dc6:	21 c3                	and    %eax,%ebx
  808dc8:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808dcf:	e8 ce ed ff ff       	call   807ba2 <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808dd4:	83 c4 10             	add    $0x10,%esp
  808dd7:	39 c3                	cmp    %eax,%ebx
  808dd9:	75 13                	jne    808dee <udp_input+0x218>
      pbuf_free(p);
  808ddb:	83 ec 0c             	sub    $0xc,%esp
  808dde:	ff 75 08             	pushl  0x8(%ebp)
  808de1:	e8 35 bc ff ff       	call   804a1b <pbuf_free>
  808de6:	83 c4 10             	add    $0x10,%esp
  808de9:	e9 54 fe ff ff       	jmp    808c42 <udp_input+0x6c>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808dee:	83 ec 0c             	sub    $0xc,%esp
  808df1:	0f b7 07             	movzwl (%edi),%eax
  808df4:	50                   	push   %eax
  808df5:	e8 6a eb ff ff       	call   807964 <ntohs>
  808dfa:	83 c4 08             	add    $0x8,%esp
  808dfd:	66 c1 e8 08          	shr    $0x8,%ax
  808e01:	83 e0 0f             	and    $0xf,%eax
  808e04:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808e0b:	98                   	cwtl   
  808e0c:	50                   	push   %eax
  808e0d:	ff 75 08             	pushl  0x8(%ebp)
  808e10:	e8 33 bb ff ff       	call   804948 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808e15:	83 c4 10             	add    $0x10,%esp
  808e18:	8b 45 08             	mov    0x8(%ebp),%eax
  808e1b:	3b 78 04             	cmp    0x4(%eax),%edi
  808e1e:	75 12                	jne    808e32 <udp_input+0x25c>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808e20:	83 ec 08             	sub    $0x8,%esp
  808e23:	6a 03                	push   $0x3
  808e25:	ff 75 08             	pushl  0x8(%ebp)
  808e28:	e8 d4 58 00 00       	call   80e701 <icmp_dest_unreach>
  808e2d:	83 c4 10             	add    $0x10,%esp
  808e30:	eb a9                	jmp    808ddb <udp_input+0x205>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808e32:	83 ec 04             	sub    $0x4,%esp
  808e35:	68 0a 26 81 00       	push   $0x81260a
  808e3a:	68 25 01 00 00       	push   $0x125
  808e3f:	68 f6 25 81 00       	push   $0x8125f6
  808e44:	e8 ee 5a 00 00       	call   80e937 <_panic>
    pbuf_free(p);
  808e49:	83 ec 0c             	sub    $0xc,%esp
  808e4c:	ff 75 08             	pushl  0x8(%ebp)
  808e4f:	e8 c7 bb ff ff       	call   804a1b <pbuf_free>
  808e54:	83 c4 10             	add    $0x10,%esp
  808e57:	f3 0f 1e fb          	endbr32 
}
  808e5b:	e9 e2 fd ff ff       	jmp    808c42 <udp_input+0x6c>
  808e60:	89 f8                	mov    %edi,%eax
  808e62:	8b 7d dc             	mov    -0x24(%ebp),%edi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808e65:	85 c0                	test   %eax,%eax
  808e67:	0f 85 ef fe ff ff    	jne    808d5c <udp_input+0x186>
  808e6d:	8b 45 0c             	mov    0xc(%ebp),%eax
  808e70:	8b 57 10             	mov    0x10(%edi),%edx
  808e73:	bb 00 00 00 00       	mov    $0x0,%ebx
  808e78:	39 50 04             	cmp    %edx,0x4(%eax)
  808e7b:	75 cc                	jne    808e49 <udp_input+0x273>
      if (udphdr->chksum != 0) {
  808e7d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808e80:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808e85:	74 29                	je     808eb0 <udp_input+0x2da>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808e87:	83 ec 0c             	sub    $0xc,%esp
  808e8a:	8b 45 08             	mov    0x8(%ebp),%eax
  808e8d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808e91:	50                   	push   %eax
  808e92:	6a 11                	push   $0x11
  808e94:	8d 47 10             	lea    0x10(%edi),%eax
  808e97:	50                   	push   %eax
  808e98:	8d 47 0c             	lea    0xc(%edi),%eax
  808e9b:	50                   	push   %eax
  808e9c:	ff 75 08             	pushl  0x8(%ebp)
  808e9f:	e8 77 e7 ff ff       	call   80761b <inet_chksum_pseudo>
  808ea4:	83 c4 20             	add    $0x20,%esp
  808ea7:	66 85 c0             	test   %ax,%ax
  808eaa:	0f 85 b3 fe ff ff    	jne    808d63 <udp_input+0x18d>
    if(pbuf_header(p, -UDP_HLEN)) {
  808eb0:	83 ec 08             	sub    $0x8,%esp
  808eb3:	6a f8                	push   $0xfffffff8
  808eb5:	ff 75 08             	pushl  0x8(%ebp)
  808eb8:	e8 8b ba ff ff       	call   804948 <pbuf_header>
  808ebd:	83 c4 10             	add    $0x10,%esp
  808ec0:	84 c0                	test   %al,%al
  808ec2:	0f 85 ae fe ff ff    	jne    808d76 <udp_input+0x1a0>
    if (pcb != NULL) {
  808ec8:	85 db                	test   %ebx,%ebx
  808eca:	0f 84 d0 fe ff ff    	je     808da0 <udp_input+0x1ca>
      if (pcb->recv != NULL) {
  808ed0:	8b 43 18             	mov    0x18(%ebx),%eax
  808ed3:	85 c0                	test   %eax,%eax
  808ed5:	0f 84 b2 fe ff ff    	je     808d8d <udp_input+0x1b7>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808edb:	83 ec 0c             	sub    $0xc,%esp
  808ede:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  808ee2:	52                   	push   %edx
  808ee3:	83 c7 0c             	add    $0xc,%edi
  808ee6:	57                   	push   %edi
  808ee7:	ff 75 08             	pushl  0x8(%ebp)
  808eea:	53                   	push   %ebx
  808eeb:	ff 73 1c             	pushl  0x1c(%ebx)
  808eee:	ff d0                	call   *%eax
  808ef0:	83 c4 20             	add    $0x20,%esp
  808ef3:	e9 4a fd ff ff       	jmp    808c42 <udp_input+0x6c>

00808ef8 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808ef8:	f3 0f 1e fb          	endbr32 
  808efc:	55                   	push   %ebp
  808efd:	89 e5                	mov    %esp,%ebp
  808eff:	57                   	push   %edi
  808f00:	56                   	push   %esi
  808f01:	53                   	push   %ebx
  808f02:	83 ec 0c             	sub    $0xc,%esp
  808f05:	8b 55 08             	mov    0x8(%ebp),%edx
  808f08:	8b 7d 10             	mov    0x10(%ebp),%edi
  808f0b:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808f0d:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  rebind = 0;
  808f12:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808f17:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808f1c:	eb 1a                	jmp    808f38 <udp_bind+0x40>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808f1e:	83 ec 04             	sub    $0x4,%esp
  808f21:	68 1e 26 81 00       	push   $0x81261e
  808f26:	68 41 02 00 00       	push   $0x241
  808f2b:	68 f6 25 81 00       	push   $0x8125f6
  808f30:	e8 02 5a 00 00       	call   80e937 <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808f35:	8b 40 0c             	mov    0xc(%eax),%eax
  808f38:	85 c0                	test   %eax,%eax
  808f3a:	74 0c                	je     808f48 <udp_bind+0x50>
    if (pcb == ipcb) {
  808f3c:	39 d0                	cmp    %edx,%eax
  808f3e:	75 f5                	jne    808f35 <udp_bind+0x3d>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808f40:	84 db                	test   %bl,%bl
  808f42:	75 da                	jne    808f1e <udp_bind+0x26>
      rebind = 1;
  808f44:	89 f3                	mov    %esi,%ebx
  808f46:	eb ed                	jmp    808f35 <udp_bind+0x3d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808f48:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808f4c:	74 05                	je     808f53 <udp_bind+0x5b>
  808f4e:	8b 45 0c             	mov    0xc(%ebp),%eax
  808f51:	8b 00                	mov    (%eax),%eax
  808f53:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808f55:	66 85 ff             	test   %di,%di
  808f58:	75 2e                	jne    808f88 <udp_bind+0x90>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808f5a:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808f60:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808f62:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808f67:	eb 03                	jmp    808f6c <udp_bind+0x74>
        port++;
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808f69:	8b 40 0c             	mov    0xc(%eax),%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808f6c:	85 c0                	test   %eax,%eax
  808f6e:	74 14                	je     808f84 <udp_bind+0x8c>
  808f70:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808f75:	74 0d                	je     808f84 <udp_bind+0x8c>
      if (ipcb->local_port == port) {
  808f77:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808f7b:	75 ec                	jne    808f69 <udp_bind+0x71>
        port++;
  808f7d:	83 c1 01             	add    $0x1,%ecx
        ipcb = udp_pcbs;
  808f80:	89 f0                	mov    %esi,%eax
  808f82:	eb e8                	jmp    808f6c <udp_bind+0x74>
    }
    if (ipcb != NULL) {
  808f84:	85 c0                	test   %eax,%eax
  808f86:	75 28                	jne    808fb0 <udp_bind+0xb8>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808f88:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808f8c:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808f91:	84 db                	test   %bl,%bl
  808f93:	75 13                	jne    808fa8 <udp_bind+0xb0>
    pcb->next = udp_pcbs;
  808f95:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808f9a:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808f9d:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
  return ERR_OK;
  808fa3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808fa8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808fab:	5b                   	pop    %ebx
  808fac:	5e                   	pop    %esi
  808fad:	5f                   	pop    %edi
  808fae:	5d                   	pop    %ebp
  808faf:	c3                   	ret    
      return ERR_USE;
  808fb0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808fb5:	eb f1                	jmp    808fa8 <udp_bind+0xb0>

00808fb7 <udp_sendto_if>:
{
  808fb7:	f3 0f 1e fb          	endbr32 
  808fbb:	55                   	push   %ebp
  808fbc:	89 e5                	mov    %esp,%ebp
  808fbe:	57                   	push   %edi
  808fbf:	56                   	push   %esi
  808fc0:	53                   	push   %ebx
  808fc1:	83 ec 1c             	sub    $0x1c,%esp
  808fc4:	8b 7d 08             	mov    0x8(%ebp),%edi
  808fc7:	8b 45 14             	mov    0x14(%ebp),%eax
  808fca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808fcd:	66 83 7f 12 00       	cmpw   $0x0,0x12(%edi)
  808fd2:	75 19                	jne    808fed <udp_sendto_if+0x36>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808fd4:	83 ec 04             	sub    $0x4,%esp
  808fd7:	6a 00                	push   $0x0
  808fd9:	57                   	push   %edi
  808fda:	57                   	push   %edi
  808fdb:	e8 18 ff ff ff       	call   808ef8 <udp_bind>
  808fe0:	89 c6                	mov    %eax,%esi
    if (err != ERR_OK) {
  808fe2:	83 c4 10             	add    $0x10,%esp
  808fe5:	84 c0                	test   %al,%al
  808fe7:	0f 85 b7 00 00 00    	jne    8090a4 <udp_sendto_if+0xed>
  if (pbuf_header(p, UDP_HLEN)) {
  808fed:	83 ec 08             	sub    $0x8,%esp
  808ff0:	6a 08                	push   $0x8
  808ff2:	ff 75 0c             	pushl  0xc(%ebp)
  808ff5:	e8 4e b9 ff ff       	call   804948 <pbuf_header>
  808ffa:	83 c4 10             	add    $0x10,%esp
    q = p;
  808ffd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (pbuf_header(p, UDP_HLEN)) {
  809000:	84 c0                	test   %al,%al
  809002:	0f 85 a6 00 00 00    	jne    8090ae <udp_sendto_if+0xf7>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  809008:	66 83 7b 0a 07       	cmpw   $0x7,0xa(%ebx)
  80900d:	0f 86 ca 00 00 00    	jbe    8090dd <udp_sendto_if+0x126>
  udphdr = q->payload;
  809013:	8b 73 04             	mov    0x4(%ebx),%esi
  udphdr->src = htons(pcb->local_port);
  809016:	83 ec 0c             	sub    $0xc,%esp
  809019:	0f b7 47 12          	movzwl 0x12(%edi),%eax
  80901d:	50                   	push   %eax
  80901e:	e8 30 e9 ff ff       	call   807953 <htons>
  809023:	66 89 06             	mov    %ax,(%esi)
  udphdr->dest = htons(dst_port);
  809026:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80902a:	89 04 24             	mov    %eax,(%esp)
  80902d:	e8 21 e9 ff ff       	call   807953 <htons>
  809032:	66 89 46 02          	mov    %ax,0x2(%esi)
  udphdr->chksum = 0x0000; 
  809036:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
  if (ip_addr_isany(&pcb->local_ip)) {
  80903c:	8b 07                	mov    (%edi),%eax
  80903e:	83 c4 10             	add    $0x10,%esp
  809041:	85 c0                	test   %eax,%eax
  809043:	0f 85 ab 00 00 00    	jne    8090f4 <udp_sendto_if+0x13d>
    src_ip = &(netif->ip_addr);
  809049:	8b 45 18             	mov    0x18(%ebp),%eax
  80904c:	83 c0 04             	add    $0x4,%eax
  80904f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  809052:	83 ec 0c             	sub    $0xc,%esp
  809055:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809059:	50                   	push   %eax
  80905a:	e8 f4 e8 ff ff       	call   807953 <htons>
  80905f:	66 89 46 04          	mov    %ax,0x4(%esi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  809063:	83 c4 10             	add    $0x10,%esp
  809066:	f6 47 10 01          	testb  $0x1,0x10(%edi)
  80906a:	0f 84 ac 00 00 00    	je     80911c <udp_sendto_if+0x165>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  809070:	83 ec 04             	sub    $0x4,%esp
  809073:	ff 75 18             	pushl  0x18(%ebp)
  809076:	6a 11                	push   $0x11
  809078:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80907c:	50                   	push   %eax
  80907d:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  809081:	50                   	push   %eax
  809082:	ff 75 10             	pushl  0x10(%ebp)
  809085:	ff 75 e4             	pushl  -0x1c(%ebp)
  809088:	53                   	push   %ebx
  809089:	e8 17 da ff ff       	call   806aa5 <ip_output_if>
  80908e:	89 c6                	mov    %eax,%esi
  if (q != p) {
  809090:	83 c4 20             	add    $0x20,%esp
  809093:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  809096:	74 0c                	je     8090a4 <udp_sendto_if+0xed>
    pbuf_free(q);
  809098:	83 ec 0c             	sub    $0xc,%esp
  80909b:	53                   	push   %ebx
  80909c:	e8 7a b9 ff ff       	call   804a1b <pbuf_free>
  8090a1:	83 c4 10             	add    $0x10,%esp
}
  8090a4:	89 f0                	mov    %esi,%eax
  8090a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8090a9:	5b                   	pop    %ebx
  8090aa:	5e                   	pop    %esi
  8090ab:	5f                   	pop    %edi
  8090ac:	5d                   	pop    %ebp
  8090ad:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  8090ae:	83 ec 04             	sub    $0x4,%esp
  8090b1:	6a 00                	push   $0x0
  8090b3:	6a 08                	push   $0x8
  8090b5:	6a 01                	push   $0x1
  8090b7:	e8 29 ba ff ff       	call   804ae5 <pbuf_alloc>
  8090bc:	89 c3                	mov    %eax,%ebx
    if (q == NULL) {
  8090be:	83 c4 10             	add    $0x10,%esp
  8090c1:	85 c0                	test   %eax,%eax
  8090c3:	0f 84 80 00 00 00    	je     809149 <udp_sendto_if+0x192>
    pbuf_chain(q, p);
  8090c9:	83 ec 08             	sub    $0x8,%esp
  8090cc:	ff 75 0c             	pushl  0xc(%ebp)
  8090cf:	50                   	push   %eax
  8090d0:	e8 28 be ff ff       	call   804efd <pbuf_chain>
  8090d5:	83 c4 10             	add    $0x10,%esp
  8090d8:	e9 2b ff ff ff       	jmp    809008 <udp_sendto_if+0x51>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  8090dd:	83 ec 04             	sub    $0x4,%esp
  8090e0:	68 2c 26 81 00       	push   $0x81262c
  8090e5:	68 b1 01 00 00       	push   $0x1b1
  8090ea:	68 f6 25 81 00       	push   $0x8125f6
  8090ef:	e8 43 58 00 00       	call   80e937 <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8090f4:	8b 4d 18             	mov    0x18(%ebp),%ecx
  8090f7:	3b 41 04             	cmp    0x4(%ecx),%eax
  8090fa:	75 08                	jne    809104 <udp_sendto_if+0x14d>
  if (ip_addr_isany(&pcb->local_ip)) {
  8090fc:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8090ff:	e9 4e ff ff ff       	jmp    809052 <udp_sendto_if+0x9b>
      return ERR_VAL;
  809104:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
      if (q != p) {
  809109:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  80910c:	74 96                	je     8090a4 <udp_sendto_if+0xed>
        pbuf_free(q);
  80910e:	83 ec 0c             	sub    $0xc,%esp
  809111:	53                   	push   %ebx
  809112:	e8 04 b9 ff ff       	call   804a1b <pbuf_free>
  809117:	83 c4 10             	add    $0x10,%esp
  80911a:	eb 88                	jmp    8090a4 <udp_sendto_if+0xed>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80911c:	83 ec 0c             	sub    $0xc,%esp
  80911f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809123:	50                   	push   %eax
  809124:	6a 11                	push   $0x11
  809126:	ff 75 10             	pushl  0x10(%ebp)
  809129:	ff 75 e4             	pushl  -0x1c(%ebp)
  80912c:	53                   	push   %ebx
  80912d:	e8 e9 e4 ff ff       	call   80761b <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  809132:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  809135:	66 85 c0             	test   %ax,%ax
  809138:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80913d:	0f 44 c2             	cmove  %edx,%eax
  809140:	66 89 46 06          	mov    %ax,0x6(%esi)
  809144:	e9 27 ff ff ff       	jmp    809070 <udp_sendto_if+0xb9>
      return ERR_MEM;
  809149:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80914e:	e9 51 ff ff ff       	jmp    8090a4 <udp_sendto_if+0xed>

00809153 <udp_sendto>:
{
  809153:	f3 0f 1e fb          	endbr32 
  809157:	55                   	push   %ebp
  809158:	89 e5                	mov    %esp,%ebp
  80915a:	56                   	push   %esi
  80915b:	53                   	push   %ebx
  80915c:	8b 75 10             	mov    0x10(%ebp),%esi
  80915f:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  809162:	83 ec 0c             	sub    $0xc,%esp
  809165:	56                   	push   %esi
  809166:	e8 b3 d5 ff ff       	call   80671e <ip_route>
  if (netif == NULL) {
  80916b:	83 c4 10             	add    $0x10,%esp
  80916e:	85 c0                	test   %eax,%eax
  809170:	74 1e                	je     809190 <udp_sendto+0x3d>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  809172:	83 ec 0c             	sub    $0xc,%esp
  809175:	50                   	push   %eax
  809176:	0f b7 db             	movzwl %bx,%ebx
  809179:	53                   	push   %ebx
  80917a:	56                   	push   %esi
  80917b:	ff 75 0c             	pushl  0xc(%ebp)
  80917e:	ff 75 08             	pushl  0x8(%ebp)
  809181:	e8 31 fe ff ff       	call   808fb7 <udp_sendto_if>
  809186:	83 c4 20             	add    $0x20,%esp
}
  809189:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80918c:	5b                   	pop    %ebx
  80918d:	5e                   	pop    %esi
  80918e:	5d                   	pop    %ebp
  80918f:	c3                   	ret    
    return ERR_RTE;
  809190:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809195:	eb f2                	jmp    809189 <udp_sendto+0x36>

00809197 <udp_send>:
{
  809197:	f3 0f 1e fb          	endbr32 
  80919b:	55                   	push   %ebp
  80919c:	89 e5                	mov    %esp,%ebp
  80919e:	83 ec 08             	sub    $0x8,%esp
  8091a1:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  8091a4:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  8091a8:	52                   	push   %edx
  8091a9:	8d 50 04             	lea    0x4(%eax),%edx
  8091ac:	52                   	push   %edx
  8091ad:	ff 75 0c             	pushl  0xc(%ebp)
  8091b0:	50                   	push   %eax
  8091b1:	e8 9d ff ff ff       	call   809153 <udp_sendto>
}
  8091b6:	c9                   	leave  
  8091b7:	c3                   	ret    

008091b8 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8091b8:	f3 0f 1e fb          	endbr32 
  8091bc:	55                   	push   %ebp
  8091bd:	89 e5                	mov    %esp,%ebp
  8091bf:	57                   	push   %edi
  8091c0:	56                   	push   %esi
  8091c1:	53                   	push   %ebx
  8091c2:	83 ec 0c             	sub    $0xc,%esp
  8091c5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8091c8:	8b 75 0c             	mov    0xc(%ebp),%esi
  8091cb:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  8091ce:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  8091d3:	74 2b                	je     809200 <udp_connect+0x48>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  8091d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8091da:	85 f6                	test   %esi,%esi
  8091dc:	74 02                	je     8091e0 <udp_connect+0x28>
  8091de:	8b 06                	mov    (%esi),%eax
  8091e0:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  8091e3:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  8091e7:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8091eb:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  8091f1:	89 d0                	mov    %edx,%eax
  8091f3:	85 c0                	test   %eax,%eax
  8091f5:	74 1e                	je     809215 <udp_connect+0x5d>
    if (pcb == ipcb) {
  8091f7:	39 d8                	cmp    %ebx,%eax
  8091f9:	74 2b                	je     809226 <udp_connect+0x6e>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8091fb:	8b 40 0c             	mov    0xc(%eax),%eax
  8091fe:	eb f3                	jmp    8091f3 <udp_connect+0x3b>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  809200:	83 ec 04             	sub    $0x4,%esp
  809203:	6a 00                	push   $0x0
  809205:	53                   	push   %ebx
  809206:	53                   	push   %ebx
  809207:	e8 ec fc ff ff       	call   808ef8 <udp_bind>
    if (err != ERR_OK)
  80920c:	83 c4 10             	add    $0x10,%esp
  80920f:	84 c0                	test   %al,%al
  809211:	74 c2                	je     8091d5 <udp_connect+0x1d>
  809213:	eb 09                	jmp    80921e <udp_connect+0x66>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  809215:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  809218:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
}
  80921e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809221:	5b                   	pop    %ebx
  809222:	5e                   	pop    %esi
  809223:	5f                   	pop    %edi
  809224:	5d                   	pop    %ebp
  809225:	c3                   	ret    
      return ERR_OK;
  809226:	b8 00 00 00 00       	mov    $0x0,%eax
  80922b:	eb f1                	jmp    80921e <udp_connect+0x66>

0080922d <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80922d:	f3 0f 1e fb          	endbr32 
  809231:	55                   	push   %ebp
  809232:	89 e5                	mov    %esp,%ebp
  809234:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  809237:	8b 15 68 22 81 00    	mov    0x812268,%edx
  80923d:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  809240:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  809246:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80924a:	5d                   	pop    %ebp
  80924b:	c3                   	ret    

0080924c <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80924c:	f3 0f 1e fb          	endbr32 
  809250:	55                   	push   %ebp
  809251:	89 e5                	mov    %esp,%ebp
  809253:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  809256:	8b 55 0c             	mov    0xc(%ebp),%edx
  809259:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80925c:	8b 55 10             	mov    0x10(%ebp),%edx
  80925f:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  809262:	5d                   	pop    %ebp
  809263:	c3                   	ret    

00809264 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  809264:	f3 0f 1e fb          	endbr32 
  809268:	55                   	push   %ebp
  809269:	89 e5                	mov    %esp,%ebp
  80926b:	83 ec 08             	sub    $0x8,%esp
  80926e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  809271:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  809276:	39 c8                	cmp    %ecx,%eax
  809278:	75 1b                	jne    809295 <udp_remove+0x31>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80927a:	8b 41 0c             	mov    0xc(%ecx),%eax
  80927d:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  809282:	83 ec 08             	sub    $0x8,%esp
  809285:	51                   	push   %ecx
  809286:	6a 01                	push   $0x1
  809288:	e8 0b b4 ff ff       	call   804698 <memp_free>
}
  80928d:	83 c4 10             	add    $0x10,%esp
  809290:	c9                   	leave  
  809291:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  809292:	8b 40 0c             	mov    0xc(%eax),%eax
  809295:	85 c0                	test   %eax,%eax
  809297:	74 e9                	je     809282 <udp_remove+0x1e>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  809299:	8b 50 0c             	mov    0xc(%eax),%edx
  80929c:	39 ca                	cmp    %ecx,%edx
  80929e:	75 f2                	jne    809292 <udp_remove+0x2e>
  8092a0:	85 d2                	test   %edx,%edx
  8092a2:	74 ee                	je     809292 <udp_remove+0x2e>
        pcb2->next = pcb->next;
  8092a4:	8b 51 0c             	mov    0xc(%ecx),%edx
  8092a7:	89 50 0c             	mov    %edx,0xc(%eax)
  8092aa:	eb e6                	jmp    809292 <udp_remove+0x2e>

008092ac <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8092ac:	f3 0f 1e fb          	endbr32 
  8092b0:	55                   	push   %ebp
  8092b1:	89 e5                	mov    %esp,%ebp
  8092b3:	53                   	push   %ebx
  8092b4:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8092b7:	6a 01                	push   $0x1
  8092b9:	e8 80 b3 ff ff       	call   80463e <memp_malloc>
  8092be:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  8092c0:	83 c4 10             	add    $0x10,%esp
  8092c3:	85 c0                	test   %eax,%eax
  8092c5:	74 14                	je     8092db <udp_new+0x2f>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  8092c7:	83 ec 04             	sub    $0x4,%esp
  8092ca:	6a 20                	push   $0x20
  8092cc:	6a 00                	push   $0x0
  8092ce:	50                   	push   %eax
  8092cf:	e8 06 5f 00 00       	call   80f1da <memset>
    pcb->ttl = UDP_TTL;
  8092d4:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  8092d8:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  8092db:	89 d8                	mov    %ebx,%eax
  8092dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8092e0:	c9                   	leave  
  8092e1:	c3                   	ret    

008092e2 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  8092e2:	55                   	push   %ebp
  8092e3:	89 e5                	mov    %esp,%ebp
  8092e5:	56                   	push   %esi
  8092e6:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  8092e7:	85 c0                	test   %eax,%eax
  8092e9:	74 35                	je     809320 <free_etharp_q+0x3e>
  8092eb:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8092ed:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8092f1:	74 44                	je     809337 <free_etharp_q+0x55>
  8092f3:	89 de                	mov    %ebx,%esi
  while (q) {
    r = q;
    q = q->next;
  8092f5:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8092f7:	8b 46 04             	mov    0x4(%esi),%eax
  8092fa:	85 c0                	test   %eax,%eax
  8092fc:	74 50                	je     80934e <free_etharp_q+0x6c>
    pbuf_free(r->p);
  8092fe:	83 ec 0c             	sub    $0xc,%esp
  809301:	50                   	push   %eax
  809302:	e8 14 b7 ff ff       	call   804a1b <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  809307:	83 c4 08             	add    $0x8,%esp
  80930a:	56                   	push   %esi
  80930b:	6a 0a                	push   $0xa
  80930d:	e8 86 b3 ff ff       	call   804698 <memp_free>
  while (q) {
  809312:	83 c4 10             	add    $0x10,%esp
  809315:	85 db                	test   %ebx,%ebx
  809317:	75 da                	jne    8092f3 <free_etharp_q+0x11>
  }
}
  809319:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80931c:	5b                   	pop    %ebx
  80931d:	5e                   	pop    %esi
  80931e:	5d                   	pop    %ebp
  80931f:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  809320:	83 ec 04             	sub    $0x4,%esp
  809323:	68 6c 1d 81 00       	push   $0x811d6c
  809328:	68 93 00 00 00       	push   $0x93
  80932d:	68 5a 26 81 00       	push   $0x81265a
  809332:	e8 00 56 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  809337:	83 ec 04             	sub    $0x4,%esp
  80933a:	68 72 26 81 00       	push   $0x812672
  80933f:	68 94 00 00 00       	push   $0x94
  809344:	68 5a 26 81 00       	push   $0x81265a
  809349:	e8 e9 55 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80934e:	83 ec 04             	sub    $0x4,%esp
  809351:	68 7f 26 81 00       	push   $0x81267f
  809356:	68 98 00 00 00       	push   $0x98
  80935b:	68 5a 26 81 00       	push   $0x81265a
  809360:	e8 d2 55 00 00       	call   80e937 <_panic>

00809365 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809365:	55                   	push   %ebp
  809366:	89 e5                	mov    %esp,%ebp
  809368:	57                   	push   %edi
  809369:	56                   	push   %esi
  80936a:	53                   	push   %ebx
  80936b:	83 ec 1c             	sub    $0x1c,%esp
  80936e:	89 c3                	mov    %eax,%ebx
  809370:	89 55 e0             	mov    %edx,-0x20(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809373:	85 c0                	test   %eax,%eax
  809375:	0f 84 86 00 00 00    	je     809401 <find_entry+0x9c>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80937b:	0f b6 05 00 4a b3 00 	movzbl 0xb34a00,%eax
  809382:	0f b6 d0             	movzbl %al,%edx
  809385:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809388:	83 b9 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ecx)
  80938f:	74 42                	je     8093d3 <find_entry+0x6e>
  809391:	bf 00 00 00 00       	mov    $0x0,%edi
  809396:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  80939a:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80939e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8093a2:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  8093a6:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8093aa:	b8 00 00 00 00       	mov    $0x0,%eax
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8093af:	0f b6 d0             	movzbl %al,%edx
  8093b2:	6b d2 1c             	imul   $0x1c,%edx,%edx
  8093b5:	83 ba 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%edx)
  8093bc:	75 63                	jne    809421 <find_entry+0xbc>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8093be:	89 c2                	mov    %eax,%edx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8093c0:	83 c0 01             	add    $0x1,%eax
  8093c3:	3c 09                	cmp    $0x9,%al
  8093c5:	0f 87 07 01 00 00    	ja     8094d2 <find_entry+0x16d>
  8093cb:	88 55 e7             	mov    %dl,-0x19(%ebp)
  8093ce:	e9 98 00 00 00       	jmp    80946b <find_entry+0x106>
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  8093d3:	8b b9 24 4a b3 00    	mov    0xb34a24(%ecx),%edi
  8093d9:	39 3b                	cmp    %edi,(%ebx)
  8093db:	0f 84 3e 01 00 00    	je     80951f <find_entry+0x1ba>
  8093e1:	bf 00 00 00 00       	mov    $0x0,%edi
  8093e6:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  8093ea:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8093ee:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8093f2:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  8093f6:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8093fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8093ff:	eb ae                	jmp    8093af <find_entry+0x4a>
  809401:	bf 00 00 00 00       	mov    $0x0,%edi
  809406:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  80940a:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80940e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809412:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  809416:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80941a:	b8 00 00 00 00       	mov    $0x0,%eax
  80941f:	eb 8e                	jmp    8093af <find_entry+0x4a>
  809421:	ba 0a 00 00 00       	mov    $0xa,%edx
  809426:	88 55 e7             	mov    %dl,-0x19(%ebp)
  809429:	eb 40                	jmp    80946b <find_entry+0x106>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80942b:	85 db                	test   %ebx,%ebx
  80942d:	74 0d                	je     80943c <find_entry+0xd7>
  80942f:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809432:	8b 96 24 4a b3 00    	mov    0xb34a24(%esi),%edx
  809438:	39 13                	cmp    %edx,(%ebx)
  80943a:	74 6d                	je     8094a9 <find_entry+0x144>
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80943c:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  80943f:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  809446:	74 68                	je     8094b0 <find_entry+0x14b>
        if (arp_table[i].ctime >= age_queue) {
  809448:	0f b6 8e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ecx
  80944f:	89 fa                	mov    %edi,%edx
  809451:	38 d1                	cmp    %dl,%cl
  809453:	72 05                	jb     80945a <find_entry+0xf5>
          old_queue = i;
  809455:	88 45 df             	mov    %al,-0x21(%ebp)
          age_queue = arp_table[i].ctime;
  809458:	89 cf                	mov    %ecx,%edi
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80945a:	83 c0 01             	add    $0x1,%eax
  80945d:	3c 09                	cmp    $0x9,%al
  80945f:	77 6d                	ja     8094ce <find_entry+0x169>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809461:	80 7d e7 0a          	cmpb   $0xa,-0x19(%ebp)
  809465:	0f 84 44 ff ff ff    	je     8093af <find_entry+0x4a>
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80946b:	0f b6 c8             	movzbl %al,%ecx
  80946e:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809471:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  809477:	83 fe 01             	cmp    $0x1,%esi
  80947a:	74 af                	je     80942b <find_entry+0xc6>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80947c:	83 fe 02             	cmp    $0x2,%esi
  80947f:	75 d9                	jne    80945a <find_entry+0xf5>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809481:	85 db                	test   %ebx,%ebx
  809483:	74 0d                	je     809492 <find_entry+0x12d>
  809485:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809488:	8b 96 24 4a b3 00    	mov    0xb34a24(%esi),%edx
  80948e:	39 13                	cmp    %edx,(%ebx)
  809490:	74 35                	je     8094c7 <find_entry+0x162>
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  809492:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  809495:	0f b6 89 34 4a b3 00 	movzbl 0xb34a34(%ecx),%ecx
  80949c:	3a 4d e6             	cmp    -0x1a(%ebp),%cl
  80949f:	72 b9                	jb     80945a <find_entry+0xf5>
        old_stable = i;
  8094a1:	88 45 e5             	mov    %al,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  8094a4:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  8094a7:	eb b1                	jmp    80945a <find_entry+0xf5>
        etharp_cached_entry = i;
  8094a9:	a2 00 4a b3 00       	mov    %al,0xb34a00
        return i;
  8094ae:	eb 6f                	jmp    80951f <find_entry+0x1ba>
        if (arp_table[i].ctime >= age_pending) {
  8094b0:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8094b3:	0f b6 89 34 4a b3 00 	movzbl 0xb34a34(%ecx),%ecx
  8094ba:	3a 4d e4             	cmp    -0x1c(%ebp),%cl
  8094bd:	72 9b                	jb     80945a <find_entry+0xf5>
          old_pending = i;
  8094bf:	88 45 de             	mov    %al,-0x22(%ebp)
          age_pending = arp_table[i].ctime;
  8094c2:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  8094c5:	eb 93                	jmp    80945a <find_entry+0xf5>
        etharp_cached_entry = i;
  8094c7:	a2 00 4a b3 00       	mov    %al,0xb34a00
        return i;
  8094cc:	eb 51                	jmp    80951f <find_entry+0x1ba>
  8094ce:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8094d2:	80 fa 0a             	cmp    $0xa,%dl
  8094d5:	74 50                	je     809527 <find_entry+0x1c2>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8094d7:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  8094db:	0f 85 e3 00 00 00    	jne    8095c4 <find_entry+0x25f>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8094e1:	89 d6                	mov    %edx,%esi
  if (empty < ARP_TABLE_SIZE) {
  8094e3:	80 fa 09             	cmp    $0x9,%dl
  8094e6:	7f 53                	jg     80953b <find_entry+0x1d6>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8094e8:	89 f0                	mov    %esi,%eax
  8094ea:	3c 09                	cmp    $0x9,%al
  8094ec:	0f 87 b1 00 00 00    	ja     8095a3 <find_entry+0x23e>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  8094f2:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  8094f5:	6b d0 1c             	imul   $0x1c,%eax,%edx
  8094f8:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  8094ff:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809502:	85 db                	test   %ebx,%ebx
  809504:	74 08                	je     80950e <find_entry+0x1a9>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809506:	8b 0b                	mov    (%ebx),%ecx
  809508:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  80950e:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809511:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809518:	89 f0                	mov    %esi,%eax
  80951a:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  80951f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809522:	5b                   	pop    %ebx
  809523:	5e                   	pop    %esi
  809524:	5f                   	pop    %edi
  809525:	5d                   	pop    %ebp
  809526:	c3                   	ret    
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809527:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80952b:	0f 84 89 00 00 00    	je     8095ba <find_entry+0x255>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809531:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  809535:	0f 85 9d 00 00 00    	jne    8095d8 <find_entry+0x273>
  else if (old_stable < ARP_TABLE_SIZE) {
  80953b:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  80953f:	3c 09                	cmp    $0x9,%al
  809541:	7f 28                	jg     80956b <find_entry+0x206>
    i = old_stable;
  809543:	89 c6                	mov    %eax,%esi
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809545:	0f b6 c0             	movzbl %al,%eax
  809548:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80954b:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  809552:	74 94                	je     8094e8 <find_entry+0x183>
  809554:	83 ec 04             	sub    $0x4,%esp
  809557:	68 8c 26 81 00       	push   $0x81268c
  80955c:	68 75 01 00 00       	push   $0x175
  809561:	68 5a 26 81 00       	push   $0x81265a
  809566:	e8 cc 53 00 00       	call   80e937 <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  80956b:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
    i = old_pending;
  80956f:	89 c6                	mov    %eax,%esi
  } else if (old_pending < ARP_TABLE_SIZE) {
  809571:	3c 09                	cmp    $0x9,%al
  809573:	0f 8e 6f ff ff ff    	jle    8094e8 <find_entry+0x183>
  } else if (old_queue < ARP_TABLE_SIZE) {
  809579:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  80957d:	3c 09                	cmp    $0x9,%al
  80957f:	7f 4d                	jg     8095ce <find_entry+0x269>
    i = old_queue;
  809581:	89 c6                	mov    %eax,%esi
    free_etharp_q(arp_table[i].q);
  809583:	0f b6 f8             	movzbl %al,%edi
  809586:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809589:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  80958f:	e8 4e fd ff ff       	call   8092e2 <free_etharp_q>
    arp_table[i].q = NULL;
  809594:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  80959b:	00 00 00 
  80959e:	e9 45 ff ff ff       	jmp    8094e8 <find_entry+0x183>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8095a3:	83 ec 04             	sub    $0x4,%esp
  8095a6:	68 a3 26 81 00       	push   $0x8126a3
  8095ab:	68 8b 01 00 00       	push   $0x18b
  8095b0:	68 5a 26 81 00       	push   $0x81265a
  8095b5:	e8 7d 53 00 00       	call   80e937 <_panic>
    return (s8_t)ERR_MEM;
  8095ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8095bf:	e9 5b ff ff ff       	jmp    80951f <find_entry+0x1ba>
  8095c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8095c9:	e9 51 ff ff ff       	jmp    80951f <find_entry+0x1ba>
    return (s8_t)ERR_MEM;
  8095ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8095d3:	e9 47 ff ff ff       	jmp    80951f <find_entry+0x1ba>
    return (s8_t)ERR_MEM;
  8095d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8095dd:	e9 3d ff ff ff       	jmp    80951f <find_entry+0x1ba>

008095e2 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8095e2:	55                   	push   %ebp
  8095e3:	89 e5                	mov    %esp,%ebp
  8095e5:	57                   	push   %edi
  8095e6:	56                   	push   %esi
  8095e7:	53                   	push   %ebx
  8095e8:	83 ec 1c             	sub    $0x1c,%esp
  8095eb:	89 d7                	mov    %edx,%edi
  8095ed:	8b 55 08             	mov    0x8(%ebp),%edx
  struct eth_hdr *ethhdr = p->payload;
  8095f0:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8095f3:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8095f7:	75 45                	jne    80963e <etharp_send_ip+0x5c>
  8095f9:	89 c6                	mov    %eax,%esi
  8095fb:	b8 05 00 00 00       	mov    $0x5,%eax
  809600:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  809603:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  809607:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80960a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80960d:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809611:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  809615:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809618:	83 f8 ff             	cmp    $0xffffffff,%eax
  80961b:	75 e6                	jne    809603 <etharp_send_ip+0x21>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80961d:	83 ec 0c             	sub    $0xc,%esp
  809620:	68 00 08 00 00       	push   $0x800
  809625:	e8 29 e3 ff ff       	call   807953 <htons>
  80962a:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80962e:	83 c4 08             	add    $0x8,%esp
  809631:	57                   	push   %edi
  809632:	56                   	push   %esi
  809633:	ff 56 18             	call   *0x18(%esi)
}
  809636:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809639:	5b                   	pop    %ebx
  80963a:	5e                   	pop    %esi
  80963b:	5f                   	pop    %edi
  80963c:	5d                   	pop    %ebp
  80963d:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80963e:	83 ec 04             	sub    $0x4,%esp
  809641:	68 d0 26 81 00       	push   $0x8126d0
  809646:	68 b2 01 00 00       	push   $0x1b2
  80964b:	68 5a 26 81 00       	push   $0x81265a
  809650:	e8 e2 52 00 00       	call   80e937 <_panic>

00809655 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809655:	55                   	push   %ebp
  809656:	89 e5                	mov    %esp,%ebp
  809658:	57                   	push   %edi
  809659:	56                   	push   %esi
  80965a:	53                   	push   %ebx
  80965b:	83 ec 1c             	sub    $0x1c,%esp
  80965e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809661:	89 cb                	mov    %ecx,%ebx
  809663:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809666:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809669:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80966d:	0f 85 ae 00 00 00    	jne    809721 <update_arp_entry+0xcc>
  809673:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809675:	85 d2                	test   %edx,%edx
  809677:	0f 84 fe 00 00 00    	je     80977b <update_arp_entry+0x126>
  80967d:	83 3a 00             	cmpl   $0x0,(%edx)
  809680:	0f 84 fc 00 00 00    	je     809782 <update_arp_entry+0x12d>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809686:	83 ec 08             	sub    $0x8,%esp
  809689:	ff 75 e4             	pushl  -0x1c(%ebp)
  80968c:	52                   	push   %edx
  80968d:	e8 45 d0 ff ff       	call   8066d7 <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  809692:	83 c4 10             	add    $0x10,%esp
  809695:	84 c0                	test   %al,%al
  809697:	0f 85 ec 00 00 00    	jne    809789 <update_arp_entry+0x134>
      ip_addr_ismulticast(ipaddr)) {
  80969d:	8b 3e                	mov    (%esi),%edi
  80969f:	83 ec 0c             	sub    $0xc,%esp
  8096a2:	68 00 00 00 f0       	push   $0xf0000000
  8096a7:	e8 f6 e4 ff ff       	call   807ba2 <ntohl>
  8096ac:	21 c7                	and    %eax,%edi
  8096ae:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8096b5:	e8 e8 e4 ff ff       	call   807ba2 <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8096ba:	83 c4 10             	add    $0x10,%esp
  8096bd:	39 c7                	cmp    %eax,%edi
  8096bf:	0f 84 cb 00 00 00    	je     809790 <update_arp_entry+0x13b>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8096c5:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  8096c9:	89 f0                	mov    %esi,%eax
  8096cb:	e8 95 fc ff ff       	call   809365 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8096d0:	84 c0                	test   %al,%al
  8096d2:	0f 88 9b 00 00 00    	js     809773 <update_arp_entry+0x11e>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8096d8:	0f be c0             	movsbl %al,%eax
  8096db:	6b f0 1c             	imul   $0x1c,%eax,%esi
  8096de:	c7 86 30 4a b3 00 02 	movl   $0x2,0xb34a30(%esi)
  8096e5:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8096e8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8096eb:	89 8e 38 4a b3 00    	mov    %ecx,0xb34a38(%esi)
  8096f1:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8096f6:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  8096fb:	88 8c 16 2d 4a b3 00 	mov    %cl,0xb34a2d(%esi,%edx,1)
  809702:	83 ea 01             	sub    $0x1,%edx
  while (k > 0) {
  809705:	83 fa fa             	cmp    $0xfffffffa,%edx
  809708:	75 ec                	jne    8096f6 <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80970a:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80970d:	c6 82 34 4a b3 00 00 	movb   $0x0,0xb34a34(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809714:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809716:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809719:	83 c0 25             	add    $0x25,%eax
  80971c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  80971f:	eb 48                	jmp    809769 <update_arp_entry+0x114>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809721:	83 ec 04             	sub    $0x4,%esp
  809724:	68 14 27 81 00       	push   $0x812714
  809729:	68 d9 01 00 00       	push   $0x1d9
  80972e:	68 5a 26 81 00       	push   $0x81265a
  809733:	e8 ff 51 00 00       	call   80e937 <_panic>
    arp_table[i].q = q->next;
  809738:	8b 10                	mov    (%eax),%edx
  80973a:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    p = q->p;
  809740:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  809743:	83 ec 08             	sub    $0x8,%esp
  809746:	50                   	push   %eax
  809747:	6a 0a                	push   $0xa
  809749:	e8 4a af ff ff       	call   804698 <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80974e:	89 1c 24             	mov    %ebx,(%esp)
  809751:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809754:	89 fa                	mov    %edi,%edx
  809756:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809759:	e8 84 fe ff ff       	call   8095e2 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80975e:	89 3c 24             	mov    %edi,(%esp)
  809761:	e8 b5 b2 ff ff       	call   804a1b <pbuf_free>
  809766:	83 c4 10             	add    $0x10,%esp
  while (arp_table[i].q != NULL) {
  809769:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  80976f:	85 c0                	test   %eax,%eax
  809771:	75 c5                	jne    809738 <update_arp_entry+0xe3>
  }
#endif
  return ERR_OK;
}
  809773:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809776:	5b                   	pop    %ebx
  809777:	5e                   	pop    %esi
  809778:	5f                   	pop    %edi
  809779:	5d                   	pop    %ebp
  80977a:	c3                   	ret    
    return ERR_ARG;
  80977b:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809780:	eb f1                	jmp    809773 <update_arp_entry+0x11e>
  809782:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809787:	eb ea                	jmp    809773 <update_arp_entry+0x11e>
  809789:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80978e:	eb e3                	jmp    809773 <update_arp_entry+0x11e>
  809790:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809795:	eb dc                	jmp    809773 <update_arp_entry+0x11e>

00809797 <etharp_tmr>:
{
  809797:	f3 0f 1e fb          	endbr32 
  80979b:	55                   	push   %ebp
  80979c:	89 e5                	mov    %esp,%ebp
  80979e:	57                   	push   %edi
  80979f:	56                   	push   %esi
  8097a0:	53                   	push   %ebx
  8097a1:	83 ec 0c             	sub    $0xc,%esp
  8097a4:	bb 20 4a b3 00       	mov    $0xb34a20,%ebx
  8097a9:	bf 38 4b b3 00       	mov    $0xb34b38,%edi
  8097ae:	eb 1f                	jmp    8097cf <etharp_tmr+0x38>
      if (arp_table[i].q != NULL) {
  8097b0:	8b 06                	mov    (%esi),%eax
  8097b2:	85 c0                	test   %eax,%eax
  8097b4:	74 0b                	je     8097c1 <etharp_tmr+0x2a>
        free_etharp_q(arp_table[i].q);
  8097b6:	e8 27 fb ff ff       	call   8092e2 <free_etharp_q>
        arp_table[i].q = NULL;
  8097bb:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8097c1:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8097c8:	83 c3 1c             	add    $0x1c,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8097cb:	39 fb                	cmp    %edi,%ebx
  8097cd:	74 23                	je     8097f2 <etharp_tmr+0x5b>
  8097cf:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  8097d1:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  8097d5:	83 c0 01             	add    $0x1,%eax
  8097d8:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8097db:	8b 53 10             	mov    0x10(%ebx),%edx
  8097de:	3c ef                	cmp    $0xef,%al
  8097e0:	76 05                	jbe    8097e7 <etharp_tmr+0x50>
  8097e2:	83 fa 02             	cmp    $0x2,%edx
  8097e5:	74 c9                	je     8097b0 <etharp_tmr+0x19>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  8097e7:	3c 01                	cmp    $0x1,%al
  8097e9:	76 dd                	jbe    8097c8 <etharp_tmr+0x31>
  8097eb:	83 fa 01             	cmp    $0x1,%edx
  8097ee:	75 d8                	jne    8097c8 <etharp_tmr+0x31>
  8097f0:	eb be                	jmp    8097b0 <etharp_tmr+0x19>
}
  8097f2:	83 c4 0c             	add    $0xc,%esp
  8097f5:	5b                   	pop    %ebx
  8097f6:	5e                   	pop    %esi
  8097f7:	5f                   	pop    %edi
  8097f8:	5d                   	pop    %ebp
  8097f9:	c3                   	ret    

008097fa <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  8097fa:	f3 0f 1e fb          	endbr32 
  8097fe:	55                   	push   %ebp
  8097ff:	89 e5                	mov    %esp,%ebp
  809801:	53                   	push   %ebx
  809802:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809805:	ba 02 00 00 00       	mov    $0x2,%edx
  80980a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80980d:	e8 53 fb ff ff       	call   809365 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809812:	84 c0                	test   %al,%al
  809814:	78 31                	js     809847 <etharp_find_addr+0x4d>
  809816:	0f be d0             	movsbl %al,%edx
  809819:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80981c:	83 ba 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%edx)
  809823:	75 29                	jne    80984e <etharp_find_addr+0x54>
  809825:	0f be d0             	movsbl %al,%edx
  809828:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  80982b:	8d 9a 28 4a b3 00    	lea    0xb34a28(%edx),%ebx
  809831:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809834:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809836:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  80983c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80983f:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  809841:	83 c4 04             	add    $0x4,%esp
  809844:	5b                   	pop    %ebx
  809845:	5d                   	pop    %ebp
  809846:	c3                   	ret    
  return -1;
  809847:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80984c:	eb f3                	jmp    809841 <etharp_find_addr+0x47>
  80984e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809853:	eb ec                	jmp    809841 <etharp_find_addr+0x47>

00809855 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809855:	f3 0f 1e fb          	endbr32 
  809859:	55                   	push   %ebp
  80985a:	89 e5                	mov    %esp,%ebp
  80985c:	83 ec 08             	sub    $0x8,%esp
  80985f:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809862:	85 c0                	test   %eax,%eax
  809864:	74 13                	je     809879 <etharp_ip_input+0x24>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809866:	8b 55 0c             	mov    0xc(%ebp),%edx
  809869:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80986c:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  80986f:	33 48 04             	xor    0x4(%eax),%ecx
  809872:	85 48 08             	test   %ecx,0x8(%eax)
  809875:	74 19                	je     809890 <etharp_ip_input+0x3b>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  809877:	c9                   	leave  
  809878:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809879:	83 ec 04             	sub    $0x4,%esp
  80987c:	68 e2 19 81 00       	push   $0x8119e2
  809881:	68 48 02 00 00       	push   $0x248
  809886:	68 5a 26 81 00       	push   $0x81265a
  80988b:	e8 a7 50 00 00       	call   80e937 <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809890:	8d 4a 06             	lea    0x6(%edx),%ecx
  809893:	83 c2 1c             	add    $0x1c,%edx
  809896:	83 ec 0c             	sub    $0xc,%esp
  809899:	6a 00                	push   $0x0
  80989b:	e8 b5 fd ff ff       	call   809655 <update_arp_entry>
  8098a0:	83 c4 10             	add    $0x10,%esp
  8098a3:	eb d2                	jmp    809877 <etharp_ip_input+0x22>

008098a5 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8098a5:	f3 0f 1e fb          	endbr32 
  8098a9:	55                   	push   %ebp
  8098aa:	89 e5                	mov    %esp,%ebp
  8098ac:	57                   	push   %edi
  8098ad:	56                   	push   %esi
  8098ae:	53                   	push   %ebx
  8098af:	83 ec 1c             	sub    $0x1c,%esp
  8098b2:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8098b5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8098b9:	74 4d                	je     809908 <etharp_arp_input+0x63>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8098bb:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  8098c0:	76 5d                	jbe    80991f <etharp_arp_input+0x7a>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  8098c2:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8098c5:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  8098c9:	83 ec 0c             	sub    $0xc,%esp
  8098cc:	6a 01                	push   $0x1
  8098ce:	e8 80 e0 ff ff       	call   807953 <htons>
  8098d3:	83 c4 10             	add    $0x10,%esp
  8098d6:	66 39 c7             	cmp    %ax,%di
  8098d9:	75 19                	jne    8098f4 <etharp_arp_input+0x4f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8098db:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  8098df:	83 ec 0c             	sub    $0xc,%esp
  8098e2:	68 04 06 00 00       	push   $0x604
  8098e7:	e8 67 e0 ff ff       	call   807953 <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8098ec:	83 c4 10             	add    $0x10,%esp
  8098ef:	66 39 c7             	cmp    %ax,%di
  8098f2:	74 39                	je     80992d <etharp_arp_input+0x88>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8098f4:	83 ec 0c             	sub    $0xc,%esp
  8098f7:	53                   	push   %ebx
  8098f8:	e8 1e b1 ff ff       	call   804a1b <pbuf_free>
    return;
  8098fd:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  809900:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809903:	5b                   	pop    %ebx
  809904:	5e                   	pop    %esi
  809905:	5f                   	pop    %edi
  809906:	5d                   	pop    %ebp
  809907:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809908:	83 ec 04             	sub    $0x4,%esp
  80990b:	68 e2 19 81 00       	push   $0x8119e2
  809910:	68 75 02 00 00       	push   $0x275
  809915:	68 5a 26 81 00       	push   $0x81265a
  80991a:	e8 18 50 00 00       	call   80e937 <_panic>
    pbuf_free(p);
  80991f:	83 ec 0c             	sub    $0xc,%esp
  809922:	53                   	push   %ebx
  809923:	e8 f3 b0 ff ff       	call   804a1b <pbuf_free>
    return;
  809928:	83 c4 10             	add    $0x10,%esp
  80992b:	eb d3                	jmp    809900 <etharp_arp_input+0x5b>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80992d:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  809931:	83 ec 0c             	sub    $0xc,%esp
  809934:	68 00 08 00 00       	push   $0x800
  809939:	e8 15 e0 ff ff       	call   807953 <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80993e:	83 c4 10             	add    $0x10,%esp
  809941:	66 39 c7             	cmp    %ax,%di
  809944:	75 ae                	jne    8098f4 <etharp_arp_input+0x4f>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809946:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80994a:	83 ec 0c             	sub    $0xc,%esp
  80994d:	68 06 08 00 00       	push   $0x806
  809952:	e8 fc df ff ff       	call   807953 <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809957:	83 c4 10             	add    $0x10,%esp
  80995a:	66 39 c7             	cmp    %ax,%di
  80995d:	75 95                	jne    8098f4 <etharp_arp_input+0x4f>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80995f:	83 ec 04             	sub    $0x4,%esp
  809962:	6a 04                	push   $0x4
  809964:	8d 46 1c             	lea    0x1c(%esi),%eax
  809967:	50                   	push   %eax
  809968:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80996b:	50                   	push   %eax
  80996c:	e8 1b 59 00 00       	call   80f28c <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809971:	83 c4 0c             	add    $0xc,%esp
  809974:	6a 04                	push   $0x4
  809976:	8d 46 26             	lea    0x26(%esi),%eax
  809979:	50                   	push   %eax
  80997a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80997d:	50                   	push   %eax
  80997e:	e8 09 59 00 00       	call   80f28c <memcpy>
  if (netif->ip_addr.addr == 0) {
  809983:	8b 45 08             	mov    0x8(%ebp),%eax
  809986:	8b 40 04             	mov    0x4(%eax),%eax
  809989:	83 c4 10             	add    $0x10,%esp
  80998c:	85 c0                	test   %eax,%eax
  80998e:	74 05                	je     809995 <etharp_arp_input+0xf0>
  if (for_us) {
  809990:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  809993:	74 3f                	je     8099d4 <etharp_arp_input+0x12f>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809995:	8d 4e 16             	lea    0x16(%esi),%ecx
  809998:	83 ec 0c             	sub    $0xc,%esp
  80999b:	6a 00                	push   $0x0
  80999d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8099a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8099a3:	e8 ad fc ff ff       	call   809655 <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8099a8:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8099ac:	89 04 24             	mov    %eax,(%esp)
  8099af:	e8 9f df ff ff       	call   807953 <htons>
  8099b4:	83 c4 10             	add    $0x10,%esp
  8099b7:	66 83 f8 01          	cmp    $0x1,%ax
  8099bb:	74 06                	je     8099c3 <etharp_arp_input+0x11e>
  8099bd:	66 83 f8 02          	cmp    $0x2,%ax
  8099c1:	74 3f                	je     809a02 <etharp_arp_input+0x15d>
  pbuf_free(p);
  8099c3:	83 ec 0c             	sub    $0xc,%esp
  8099c6:	53                   	push   %ebx
  8099c7:	e8 4f b0 ff ff       	call   804a1b <pbuf_free>
  8099cc:	83 c4 10             	add    $0x10,%esp
  8099cf:	e9 2c ff ff ff       	jmp    809900 <etharp_arp_input+0x5b>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  8099d4:	8d 4e 16             	lea    0x16(%esi),%ecx
  8099d7:	83 ec 0c             	sub    $0xc,%esp
  8099da:	6a 01                	push   $0x1
  8099dc:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8099df:	8b 45 08             	mov    0x8(%ebp),%eax
  8099e2:	e8 6e fc ff ff       	call   809655 <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8099e7:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8099eb:	89 04 24             	mov    %eax,(%esp)
  8099ee:	e8 60 df ff ff       	call   807953 <htons>
  8099f3:	83 c4 10             	add    $0x10,%esp
  8099f6:	66 83 f8 01          	cmp    $0x1,%ax
  8099fa:	74 1a                	je     809a16 <etharp_arp_input+0x171>
  8099fc:	66 83 f8 02          	cmp    $0x2,%ax
  809a00:	75 c1                	jne    8099c3 <etharp_arp_input+0x11e>
    dhcp_arp_reply(netif, &sipaddr);
  809a02:	83 ec 08             	sub    $0x8,%esp
  809a05:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809a08:	50                   	push   %eax
  809a09:	ff 75 08             	pushl  0x8(%ebp)
  809a0c:	e8 48 a0 ff ff       	call   803a59 <dhcp_arp_reply>
    break;
  809a11:	83 c4 10             	add    $0x10,%esp
  809a14:	eb ad                	jmp    8099c3 <etharp_arp_input+0x11e>
      hdr->opcode = htons(ARP_REPLY);
  809a16:	83 ec 0c             	sub    $0xc,%esp
  809a19:	6a 02                	push   $0x2
  809a1b:	e8 33 df ff ff       	call   807953 <htons>
  809a20:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  809a24:	8b 46 1c             	mov    0x1c(%esi),%eax
  809a27:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809a2a:	8b 45 08             	mov    0x8(%ebp),%eax
  809a2d:	8b 40 04             	mov    0x4(%eax),%eax
  809a30:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809a33:	83 c4 10             	add    $0x10,%esp
  809a36:	8b 45 08             	mov    0x8(%ebp),%eax
  809a39:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809a3d:	75 3e                	jne    809a7d <etharp_arp_input+0x1d8>
  809a3f:	8d 46 05             	lea    0x5(%esi),%eax
  809a42:	8b 55 0c             	mov    0xc(%ebp),%edx
  809a45:	83 c2 05             	add    $0x5,%edx
  809a48:	89 f7                	mov    %esi,%edi
  809a4a:	89 c6                	mov    %eax,%esi
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809a4c:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  809a50:	88 48 20             	mov    %cl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809a53:	88 08                	mov    %cl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809a55:	0f b6 0a             	movzbl (%edx),%ecx
  809a58:	88 48 16             	mov    %cl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809a5b:	88 48 06             	mov    %cl,0x6(%eax)
  809a5e:	83 e8 01             	sub    $0x1,%eax
  809a61:	83 ea 01             	sub    $0x1,%edx
      while(i > 0) {
  809a64:	39 fe                	cmp    %edi,%esi
  809a66:	75 e2                	jne    809a4a <etharp_arp_input+0x1a5>
      netif->linkoutput(netif, p);
  809a68:	83 ec 08             	sub    $0x8,%esp
  809a6b:	53                   	push   %ebx
  809a6c:	ff 75 08             	pushl  0x8(%ebp)
  809a6f:	8b 45 08             	mov    0x8(%ebp),%eax
  809a72:	ff 50 18             	call   *0x18(%eax)
  809a75:	83 c4 10             	add    $0x10,%esp
  809a78:	e9 46 ff ff ff       	jmp    8099c3 <etharp_arp_input+0x11e>
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809a7d:	83 ec 04             	sub    $0x4,%esp
  809a80:	68 d0 26 81 00       	push   $0x8126d0
  809a85:	68 c6 02 00 00       	push   $0x2c6
  809a8a:	68 5a 26 81 00       	push   $0x81265a
  809a8f:	e8 a3 4e 00 00       	call   80e937 <_panic>

00809a94 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  809a94:	f3 0f 1e fb          	endbr32 
  809a98:	55                   	push   %ebp
  809a99:	89 e5                	mov    %esp,%ebp
  809a9b:	57                   	push   %edi
  809a9c:	56                   	push   %esi
  809a9d:	53                   	push   %ebx
  809a9e:	83 ec 10             	sub    $0x10,%esp
  809aa1:	8b 7d 08             	mov    0x8(%ebp),%edi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809aa4:	6a 00                	push   $0x0
  809aa6:	6a 2a                	push   $0x2a
  809aa8:	6a 02                	push   $0x2
  809aaa:	e8 36 b0 ff ff       	call   804ae5 <pbuf_alloc>
  if (p == NULL) {
  809aaf:	83 c4 10             	add    $0x10,%esp
  809ab2:	85 c0                	test   %eax,%eax
  809ab4:	0f 84 f8 00 00 00    	je     809bb2 <etharp_request+0x11e>
  809aba:	89 c6                	mov    %eax,%esi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809abc:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809ac1:	0f 86 bd 00 00 00    	jbe    809b84 <etharp_request+0xf0>
  hdr = p->payload;
  809ac7:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  809aca:	83 ec 0c             	sub    $0xc,%esp
  809acd:	6a 01                	push   $0x1
  809acf:	e8 7f de ff ff       	call   807953 <htons>
  809ad4:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809ad8:	83 c4 10             	add    $0x10,%esp
  809adb:	80 7f 24 06          	cmpb   $0x6,0x24(%edi)
  809adf:	0f 85 b6 00 00 00    	jne    809b9b <etharp_request+0x107>
  809ae5:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  809aea:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  809aef:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809af3:	0f b6 90 bc 27 81 00 	movzbl 0x8127bc(%eax),%edx
  809afa:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809afe:	0f b6 90 c4 27 81 00 	movzbl 0x8127c4(%eax),%edx
  809b05:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809b08:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  809b0d:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  809b11:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809b14:	83 f8 ff             	cmp    $0xffffffff,%eax
  809b17:	75 d1                	jne    809aea <etharp_request+0x56>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809b19:	8b 47 04             	mov    0x4(%edi),%eax
  809b1c:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  809b1f:	8b 45 0c             	mov    0xc(%ebp),%eax
  809b22:	8b 00                	mov    (%eax),%eax
  809b24:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809b27:	83 ec 0c             	sub    $0xc,%esp
  809b2a:	6a 01                	push   $0x1
  809b2c:	e8 22 de ff ff       	call   807953 <htons>
  809b31:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809b35:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809b3c:	e8 12 de ff ff       	call   807953 <htons>
  809b41:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809b45:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809b4c:	e8 02 de ff ff       	call   807953 <htons>
  809b51:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809b55:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809b5c:	e8 f2 dd ff ff       	call   807953 <htons>
  809b61:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  809b65:	83 c4 08             	add    $0x8,%esp
  809b68:	56                   	push   %esi
  809b69:	57                   	push   %edi
  809b6a:	ff 57 18             	call   *0x18(%edi)
  809b6d:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  809b6f:	89 34 24             	mov    %esi,(%esp)
  809b72:	e8 a4 ae ff ff       	call   804a1b <pbuf_free>
  return result;
  809b77:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809b7a:	89 d8                	mov    %ebx,%eax
  809b7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809b7f:	5b                   	pop    %ebx
  809b80:	5e                   	pop    %esi
  809b81:	5f                   	pop    %edi
  809b82:	5d                   	pop    %ebp
  809b83:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809b84:	83 ec 04             	sub    $0x4,%esp
  809b87:	68 3c 27 81 00       	push   $0x81273c
  809b8c:	68 1b 04 00 00       	push   $0x41b
  809b91:	68 5a 26 81 00       	push   $0x81265a
  809b96:	e8 9c 4d 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809b9b:	83 ec 04             	sub    $0x4,%esp
  809b9e:	68 d0 26 81 00       	push   $0x8126d0
  809ba3:	68 22 04 00 00       	push   $0x422
  809ba8:	68 5a 26 81 00       	push   $0x81265a
  809bad:	e8 85 4d 00 00       	call   80e937 <_panic>
    return ERR_MEM;
  809bb2:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  809bb7:	eb c1                	jmp    809b7a <etharp_request+0xe6>

00809bb9 <etharp_query>:
{
  809bb9:	f3 0f 1e fb          	endbr32 
  809bbd:	55                   	push   %ebp
  809bbe:	89 e5                	mov    %esp,%ebp
  809bc0:	57                   	push   %edi
  809bc1:	56                   	push   %esi
  809bc2:	53                   	push   %ebx
  809bc3:	83 ec 14             	sub    $0x14,%esp
  809bc6:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809bc9:	ff 75 08             	pushl  0x8(%ebp)
  809bcc:	56                   	push   %esi
  809bcd:	e8 05 cb ff ff       	call   8066d7 <ip_addr_isbroadcast>
  809bd2:	83 c4 10             	add    $0x10,%esp
  809bd5:	84 c0                	test   %al,%al
  809bd7:	0f 85 9f 01 00 00    	jne    809d7c <etharp_query+0x1c3>
      ip_addr_ismulticast(ipaddr) ||
  809bdd:	8b 1e                	mov    (%esi),%ebx
  809bdf:	83 ec 0c             	sub    $0xc,%esp
  809be2:	68 00 00 00 f0       	push   $0xf0000000
  809be7:	e8 b6 df ff ff       	call   807ba2 <ntohl>
  809bec:	21 c3                	and    %eax,%ebx
  809bee:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809bf5:	e8 a8 df ff ff       	call   807ba2 <ntohl>
  809bfa:	83 c4 10             	add    $0x10,%esp
  809bfd:	39 c3                	cmp    %eax,%ebx
  809bff:	0f 84 81 01 00 00    	je     809d86 <etharp_query+0x1cd>
      ip_addr_isany(ipaddr)) {
  809c05:	83 3e 00             	cmpl   $0x0,(%esi)
  809c08:	0f 84 82 01 00 00    	je     809d90 <etharp_query+0x1d7>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  809c0e:	ba 01 00 00 00       	mov    $0x1,%edx
  809c13:	89 f0                	mov    %esi,%eax
  809c15:	e8 4b f7 ff ff       	call   809365 <find_entry>
  809c1a:	89 c3                	mov    %eax,%ebx
  if (i < 0) {
  809c1c:	84 c0                	test   %al,%al
  809c1e:	0f 88 76 01 00 00    	js     809d9a <etharp_query+0x1e1>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  809c24:	0f be f8             	movsbl %al,%edi
  809c27:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c2a:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809c30:	85 c0                	test   %eax,%eax
  809c32:	75 26                	jne    809c5a <etharp_query+0xa1>
    arp_table[i].state = ETHARP_STATE_PENDING;
  809c34:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c37:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  809c3e:	00 00 00 
    result = etharp_request(netif, ipaddr);
  809c41:	83 ec 08             	sub    $0x8,%esp
  809c44:	56                   	push   %esi
  809c45:	ff 75 08             	pushl  0x8(%ebp)
  809c48:	e8 47 fe ff ff       	call   809a94 <etharp_request>
  809c4d:	89 c6                	mov    %eax,%esi
  if (q != NULL) {
  809c4f:	83 c4 10             	add    $0x10,%esp
  809c52:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809c56:	74 2d                	je     809c85 <etharp_query+0xcc>
  809c58:	eb 18                	jmp    809c72 <etharp_query+0xb9>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809c5a:	8d 50 ff             	lea    -0x1(%eax),%edx
  809c5d:	83 fa 01             	cmp    $0x1,%edx
  809c60:	77 2d                	ja     809c8f <etharp_query+0xd6>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809c62:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809c66:	74 d9                	je     809c41 <etharp_query+0x88>
  809c68:	83 f8 01             	cmp    $0x1,%eax
  809c6b:	74 d4                	je     809c41 <etharp_query+0x88>
  err_t result = ERR_MEM;
  809c6d:	be ff ff ff ff       	mov    $0xffffffff,%esi
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809c72:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c75:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809c7b:	83 f8 02             	cmp    $0x2,%eax
  809c7e:	74 26                	je     809ca6 <etharp_query+0xed>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809c80:	83 f8 01             	cmp    $0x1,%eax
  809c83:	74 48                	je     809ccd <etharp_query+0x114>
}
  809c85:	89 f0                	mov    %esi,%eax
  809c87:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809c8a:	5b                   	pop    %ebx
  809c8b:	5e                   	pop    %esi
  809c8c:	5f                   	pop    %edi
  809c8d:	5d                   	pop    %ebp
  809c8e:	c3                   	ret    
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809c8f:	83 ec 04             	sub    $0x4,%esp
  809c92:	68 70 27 81 00       	push   $0x812770
  809c97:	68 90 03 00 00       	push   $0x390
  809c9c:	68 5a 26 81 00       	push   $0x81265a
  809ca1:	e8 91 4c 00 00       	call   80e937 <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  809ca6:	8b 45 08             	mov    0x8(%ebp),%eax
  809ca9:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809cac:	83 ec 0c             	sub    $0xc,%esp
  809caf:	0f be c3             	movsbl %bl,%eax
  809cb2:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809cb5:	05 28 4a b3 00       	add    $0xb34a28,%eax
  809cba:	50                   	push   %eax
  809cbb:	8b 55 10             	mov    0x10(%ebp),%edx
  809cbe:	8b 45 08             	mov    0x8(%ebp),%eax
  809cc1:	e8 1c f9 ff ff       	call   8095e2 <etharp_send_ip>
  809cc6:	89 c6                	mov    %eax,%esi
  809cc8:	83 c4 10             	add    $0x10,%esp
  809ccb:	eb b8                	jmp    809c85 <etharp_query+0xcc>
      p = q;
  809ccd:	8b 45 10             	mov    0x10(%ebp),%eax
  809cd0:	eb 27                	jmp    809cf9 <etharp_query+0x140>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809cd2:	83 ec 04             	sub    $0x4,%esp
  809cd5:	68 b6 26 81 00       	push   $0x8126b6
  809cda:	68 b1 03 00 00       	push   $0x3b1
  809cdf:	68 5a 26 81 00       	push   $0x81265a
  809ce4:	e8 4e 4c 00 00       	call   80e937 <_panic>
        if(p->type != PBUF_ROM) {
  809ce9:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809ced:	75 23                	jne    809d12 <etharp_query+0x159>
        p = p->next;
  809cef:	8b 00                	mov    (%eax),%eax
      while (p) {
  809cf1:	85 c0                	test   %eax,%eax
  809cf3:	0f 84 a8 00 00 00    	je     809da1 <etharp_query+0x1e8>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809cf9:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809cfd:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809d01:	75 e6                	jne    809ce9 <etharp_query+0x130>
  809d03:	83 38 00             	cmpl   $0x0,(%eax)
  809d06:	75 ca                	jne    809cd2 <etharp_query+0x119>
        if(p->type != PBUF_ROM) {
  809d08:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809d0c:	0f 84 8f 00 00 00    	je     809da1 <etharp_query+0x1e8>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809d12:	83 ec 04             	sub    $0x4,%esp
  809d15:	6a 00                	push   $0x0
  809d17:	0f b7 d2             	movzwl %dx,%edx
  809d1a:	52                   	push   %edx
  809d1b:	6a 03                	push   $0x3
  809d1d:	e8 c3 ad ff ff       	call   804ae5 <pbuf_alloc>
  809d22:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  809d24:	83 c4 10             	add    $0x10,%esp
  809d27:	85 c0                	test   %eax,%eax
  809d29:	0f 84 56 ff ff ff    	je     809c85 <etharp_query+0xcc>
          if (pbuf_copy(p, q) != ERR_OK) {
  809d2f:	83 ec 08             	sub    $0x8,%esp
  809d32:	ff 75 10             	pushl  0x10(%ebp)
  809d35:	53                   	push   %ebx
  809d36:	e8 91 b2 ff ff       	call   804fcc <pbuf_copy>
  809d3b:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809d3e:	89 5d 10             	mov    %ebx,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809d41:	84 c0                	test   %al,%al
  809d43:	74 6a                	je     809daf <etharp_query+0x1f6>
            pbuf_free(p);
  809d45:	83 ec 0c             	sub    $0xc,%esp
  809d48:	53                   	push   %ebx
  809d49:	e8 cd ac ff ff       	call   804a1b <pbuf_free>
  809d4e:	83 c4 10             	add    $0x10,%esp
  809d51:	e9 2f ff ff ff       	jmp    809c85 <etharp_query+0xcc>
            arp_table[i].q = new_entry;
  809d56:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809d59:	89 87 20 4a b3 00    	mov    %eax,0xb34a20(%edi)
          result = ERR_OK;
  809d5f:	be 00 00 00 00       	mov    $0x0,%esi
  809d64:	e9 1c ff ff ff       	jmp    809c85 <etharp_query+0xcc>
          pbuf_free(p);
  809d69:	83 ec 0c             	sub    $0xc,%esp
  809d6c:	ff 75 10             	pushl  0x10(%ebp)
  809d6f:	e8 a7 ac ff ff       	call   804a1b <pbuf_free>
  809d74:	83 c4 10             	add    $0x10,%esp
  809d77:	e9 09 ff ff ff       	jmp    809c85 <etharp_query+0xcc>
    return ERR_ARG;
  809d7c:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809d81:	e9 ff fe ff ff       	jmp    809c85 <etharp_query+0xcc>
  809d86:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809d8b:	e9 f5 fe ff ff       	jmp    809c85 <etharp_query+0xcc>
  809d90:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809d95:	e9 eb fe ff ff       	jmp    809c85 <etharp_query+0xcc>
    return (err_t)i;
  809d9a:	89 c6                	mov    %eax,%esi
  809d9c:	e9 e4 fe ff ff       	jmp    809c85 <etharp_query+0xcc>
        pbuf_ref(p);
  809da1:	83 ec 0c             	sub    $0xc,%esp
  809da4:	ff 75 10             	pushl  0x10(%ebp)
  809da7:	e8 cc b0 ff ff       	call   804e78 <pbuf_ref>
  809dac:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809daf:	83 ec 0c             	sub    $0xc,%esp
  809db2:	6a 0a                	push   $0xa
  809db4:	e8 85 a8 ff ff       	call   80463e <memp_malloc>
        if (new_entry != NULL) {
  809db9:	83 c4 10             	add    $0x10,%esp
  809dbc:	85 c0                	test   %eax,%eax
  809dbe:	74 a9                	je     809d69 <etharp_query+0x1b0>
          new_entry->next = 0;
  809dc0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809dc6:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809dc9:	89 48 04             	mov    %ecx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809dcc:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809dcf:	8b 92 20 4a b3 00    	mov    0xb34a20(%edx),%edx
  809dd5:	85 d2                	test   %edx,%edx
  809dd7:	0f 84 79 ff ff ff    	je     809d56 <etharp_query+0x19d>
  809ddd:	89 d1                	mov    %edx,%ecx
            while (r->next != NULL) {
  809ddf:	8b 12                	mov    (%edx),%edx
  809de1:	85 d2                	test   %edx,%edx
  809de3:	75 f8                	jne    809ddd <etharp_query+0x224>
            r->next = new_entry;
  809de5:	89 01                	mov    %eax,(%ecx)
          result = ERR_OK;
  809de7:	be 00 00 00 00       	mov    $0x0,%esi
  809dec:	e9 94 fe ff ff       	jmp    809c85 <etharp_query+0xcc>

00809df1 <etharp_output>:
{
  809df1:	f3 0f 1e fb          	endbr32 
  809df5:	55                   	push   %ebp
  809df6:	89 e5                	mov    %esp,%ebp
  809df8:	57                   	push   %edi
  809df9:	56                   	push   %esi
  809dfa:	53                   	push   %ebx
  809dfb:	83 ec 24             	sub    $0x24,%esp
  809dfe:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809e01:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809e04:	6a 0e                	push   $0xe
  809e06:	ff 75 0c             	pushl  0xc(%ebp)
  809e09:	e8 3a ab ff ff       	call   804948 <pbuf_header>
  809e0e:	83 c4 10             	add    $0x10,%esp
  809e11:	84 c0                	test   %al,%al
  809e13:	0f 85 c0 00 00 00    	jne    809ed9 <etharp_output+0xe8>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809e19:	83 ec 08             	sub    $0x8,%esp
  809e1c:	53                   	push   %ebx
  809e1d:	56                   	push   %esi
  809e1e:	e8 b4 c8 ff ff       	call   8066d7 <ip_addr_isbroadcast>
  809e23:	83 c4 10             	add    $0x10,%esp
  809e26:	84 c0                	test   %al,%al
  809e28:	0f 85 8a 00 00 00    	jne    809eb8 <etharp_output+0xc7>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809e2e:	8b 3e                	mov    (%esi),%edi
  809e30:	83 ec 0c             	sub    $0xc,%esp
  809e33:	68 00 00 00 f0       	push   $0xf0000000
  809e38:	e8 65 dd ff ff       	call   807ba2 <ntohl>
  809e3d:	21 c7                	and    %eax,%edi
  809e3f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809e46:	e8 57 dd ff ff       	call   807ba2 <ntohl>
  809e4b:	83 c4 10             	add    $0x10,%esp
  809e4e:	39 c7                	cmp    %eax,%edi
  809e50:	74 25                	je     809e77 <etharp_output+0x86>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809e52:	8b 06                	mov    (%esi),%eax
  809e54:	33 43 04             	xor    0x4(%ebx),%eax
  809e57:	85 43 08             	test   %eax,0x8(%ebx)
  809e5a:	74 09                	je     809e65 <etharp_output+0x74>
      if (netif->gw.addr != 0) {
  809e5c:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809e60:	74 7e                	je     809ee0 <etharp_output+0xef>
        ipaddr = &(netif->gw);
  809e62:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809e65:	83 ec 04             	sub    $0x4,%esp
  809e68:	ff 75 0c             	pushl  0xc(%ebp)
  809e6b:	56                   	push   %esi
  809e6c:	53                   	push   %ebx
  809e6d:	e8 47 fd ff ff       	call   809bb9 <etharp_query>
  809e72:	83 c4 10             	add    $0x10,%esp
  809e75:	eb 5a                	jmp    809ed1 <etharp_output+0xe0>
    mcastaddr.addr[0] = 0x01;
  809e77:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809e7b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809e7f:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809e83:	83 ec 0c             	sub    $0xc,%esp
  809e86:	ff 36                	pushl  (%esi)
  809e88:	e8 15 dd ff ff       	call   807ba2 <ntohl>
  809e8d:	c1 e8 10             	shr    $0x10,%eax
  809e90:	83 e0 7f             	and    $0x7f,%eax
  809e93:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809e96:	83 c4 04             	add    $0x4,%esp
  809e99:	ff 36                	pushl  (%esi)
  809e9b:	e8 02 dd ff ff       	call   807ba2 <ntohl>
  809ea0:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809ea3:	83 c4 04             	add    $0x4,%esp
  809ea6:	ff 36                	pushl  (%esi)
  809ea8:	e8 f5 dc ff ff       	call   807ba2 <ntohl>
  809ead:	88 45 e7             	mov    %al,-0x19(%ebp)
  809eb0:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809eb3:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809eb6:	eb 05                	jmp    809ebd <etharp_output+0xcc>
    dest = (struct eth_addr *)&ethbroadcast;
  809eb8:	b8 c4 27 81 00       	mov    $0x8127c4,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809ebd:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809ec0:	83 ec 0c             	sub    $0xc,%esp
  809ec3:	50                   	push   %eax
  809ec4:	8b 55 0c             	mov    0xc(%ebp),%edx
  809ec7:	89 d8                	mov    %ebx,%eax
  809ec9:	e8 14 f7 ff ff       	call   8095e2 <etharp_send_ip>
  809ece:	83 c4 10             	add    $0x10,%esp
}
  809ed1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809ed4:	5b                   	pop    %ebx
  809ed5:	5e                   	pop    %esi
  809ed6:	5f                   	pop    %edi
  809ed7:	5d                   	pop    %ebp
  809ed8:	c3                   	ret    
    return ERR_BUF;
  809ed9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809ede:	eb f1                	jmp    809ed1 <etharp_output+0xe0>
        return ERR_RTE;
  809ee0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809ee5:	eb ea                	jmp    809ed1 <etharp_output+0xe0>

00809ee7 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809ee7:	f3 0f 1e fb          	endbr32 
  809eeb:	55                   	push   %ebp
  809eec:	89 e5                	mov    %esp,%ebp
  809eee:	56                   	push   %esi
  809eef:	53                   	push   %ebx
  809ef0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809ef3:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809ef6:	83 ec 0c             	sub    $0xc,%esp
  809ef9:	8b 43 04             	mov    0x4(%ebx),%eax
  809efc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809f00:	50                   	push   %eax
  809f01:	e8 4d da ff ff       	call   807953 <htons>
  809f06:	83 c4 10             	add    $0x10,%esp
  809f09:	66 3d 00 08          	cmp    $0x800,%ax
  809f0d:	74 14                	je     809f23 <ethernet_input+0x3c>
  809f0f:	66 3d 06 08          	cmp    $0x806,%ax
  809f13:	74 50                	je     809f65 <ethernet_input+0x7e>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809f15:	83 ec 0c             	sub    $0xc,%esp
  809f18:	53                   	push   %ebx
  809f19:	e8 fd aa ff ff       	call   804a1b <pbuf_free>
      p = NULL;
      break;
  809f1e:	83 c4 10             	add    $0x10,%esp
  809f21:	eb 53                	jmp    809f76 <ethernet_input+0x8f>
      etharp_ip_input(netif, p);
  809f23:	83 ec 08             	sub    $0x8,%esp
  809f26:	53                   	push   %ebx
  809f27:	56                   	push   %esi
  809f28:	e8 28 f9 ff ff       	call   809855 <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809f2d:	83 c4 08             	add    $0x8,%esp
  809f30:	6a f2                	push   $0xfffffff2
  809f32:	53                   	push   %ebx
  809f33:	e8 10 aa ff ff       	call   804948 <pbuf_header>
  809f38:	83 c4 10             	add    $0x10,%esp
  809f3b:	84 c0                	test   %al,%al
  809f3d:	75 0f                	jne    809f4e <ethernet_input+0x67>
        ip_input(p, netif);
  809f3f:	83 ec 08             	sub    $0x8,%esp
  809f42:	56                   	push   %esi
  809f43:	53                   	push   %ebx
  809f44:	e8 36 c8 ff ff       	call   80677f <ip_input>
      break;
  809f49:	83 c4 10             	add    $0x10,%esp
  809f4c:	eb 28                	jmp    809f76 <ethernet_input+0x8f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809f4e:	83 ec 04             	sub    $0x4,%esp
  809f51:	68 98 27 81 00       	push   $0x812798
  809f56:	68 7e 04 00 00       	push   $0x47e
  809f5b:	68 5a 26 81 00       	push   $0x81265a
  809f60:	e8 d2 49 00 00       	call   80e937 <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809f65:	83 ec 04             	sub    $0x4,%esp
  809f68:	53                   	push   %ebx
  809f69:	8d 46 25             	lea    0x25(%esi),%eax
  809f6c:	50                   	push   %eax
  809f6d:	56                   	push   %esi
  809f6e:	e8 32 f9 ff ff       	call   8098a5 <etharp_arp_input>
      break;
  809f73:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809f76:	b8 00 00 00 00       	mov    $0x0,%eax
  809f7b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809f7e:	5b                   	pop    %ebx
  809f7f:	5e                   	pop    %esi
  809f80:	5d                   	pop    %ebp
  809f81:	c3                   	ret    

00809f82 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809f82:	f3 0f 1e fb          	endbr32 
  809f86:	55                   	push   %ebp
  809f87:	89 e5                	mov    %esp,%ebp
  809f89:	53                   	push   %ebx
  809f8a:	83 ec 10             	sub    $0x10,%esp
  809f8d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809f90:	ff 73 04             	pushl  0x4(%ebx)
  809f93:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809f95:	89 1c 24             	mov    %ebx,(%esp)
  809f98:	e8 27 67 00 00       	call   8106c4 <free>
}
  809f9d:	83 c4 10             	add    $0x10,%esp
  809fa0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809fa3:	c9                   	leave  
  809fa4:	c3                   	ret    

00809fa5 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809fa5:	f3 0f 1e fb          	endbr32 
  809fa9:	55                   	push   %ebp
  809faa:	89 e5                	mov    %esp,%ebp
  809fac:	83 ec 08             	sub    $0x8,%esp
  809faf:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809fb2:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809fb7:	89 c8                	mov    %ecx,%eax
  809fb9:	f7 e2                	mul    %edx
  809fbb:	89 d0                	mov    %edx,%eax
  809fbd:	c1 e8 08             	shr    $0x8,%eax
  809fc0:	b2 00                	mov    $0x0,%dl
  809fc2:	01 c2                	add    %eax,%edx
  809fc4:	89 c8                	mov    %ecx,%eax
  809fc6:	29 d0                	sub    %edx,%eax
  809fc8:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809fcf:	85 c0                	test   %eax,%eax
  809fd1:	74 2a                	je     809ffd <timeout_cleanup+0x58>
	if (t->tid == tid) {
  809fd3:	39 08                	cmp    %ecx,(%eax)
  809fd5:	74 05                	je     809fdc <timeout_cleanup+0x37>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809fd7:	8b 40 08             	mov    0x8(%eax),%eax
  809fda:	eb f3                	jmp    809fcf <timeout_cleanup+0x2a>
	    LIST_REMOVE(t, link);
  809fdc:	8b 50 08             	mov    0x8(%eax),%edx
  809fdf:	85 d2                	test   %edx,%edx
  809fe1:	74 06                	je     809fe9 <timeout_cleanup+0x44>
  809fe3:	8b 48 0c             	mov    0xc(%eax),%ecx
  809fe6:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809fe9:	8b 50 0c             	mov    0xc(%eax),%edx
  809fec:	8b 48 08             	mov    0x8(%eax),%ecx
  809fef:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809ff1:	83 ec 0c             	sub    $0xc,%esp
  809ff4:	50                   	push   %eax
  809ff5:	e8 ca 66 00 00       	call   8106c4 <free>
	    goto done;
  809ffa:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809ffd:	c9                   	leave  
  809ffe:	c3                   	ret    

00809fff <sys_init>:
{
  809fff:	f3 0f 1e fb          	endbr32 
  80a003:	55                   	push   %ebp
  80a004:	89 e5                	mov    %esp,%ebp
  80a006:	56                   	push   %esi
  80a007:	53                   	push   %ebx
  80a008:	8b 0d 60 9d b3 00    	mov    0xb39d60,%ecx
  80a00e:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  80a013:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  80a018:	eb 0e                	jmp    80a028 <sys_init+0x29>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a01a:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  80a021:	83 c0 14             	add    $0x14,%eax
    for (i = 0; i < NSEM; i++) {
  80a024:	39 f0                	cmp    %esi,%eax
  80a026:	74 19                	je     80a041 <sys_init+0x42>
  80a028:	89 ca                	mov    %ecx,%edx
  80a02a:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  80a02c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a032:	89 50 0c             	mov    %edx,0xc(%eax)
  80a035:	85 d2                	test   %edx,%edx
  80a037:	74 e1                	je     80a01a <sys_init+0x1b>
  80a039:	8d 58 0c             	lea    0xc(%eax),%ebx
  80a03c:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a03f:	eb d9                	jmp    80a01a <sys_init+0x1b>
  80a041:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  80a048:	b1 b3 00 
  80a04b:	8b 0d 44 4f b3 00    	mov    0xb34f44,%ecx
  80a051:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  80a056:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  80a05b:	eb 13                	jmp    80a070 <sys_init+0x71>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a05d:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  80a064:	4f b3 00 
  80a067:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NMBOX; i++) {
  80a06c:	39 f0                	cmp    %esi,%eax
  80a06e:	74 22                	je     80a092 <sys_init+0x93>
  80a070:	89 ca                	mov    %ecx,%edx
  80a072:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  80a074:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a07a:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80a080:	85 d2                	test   %edx,%edx
  80a082:	74 d9                	je     80a05d <sys_init+0x5e>
  80a084:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80a08a:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80a090:	eb cb                	jmp    80a05d <sys_init+0x5e>
  80a092:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  80a099:	9c b3 00 
}
  80a09c:	5b                   	pop    %ebx
  80a09d:	5e                   	pop    %esi
  80a09e:	5d                   	pop    %ebp
  80a09f:	c3                   	ret    

0080a0a0 <sys_sem_new>:
{
  80a0a0:	f3 0f 1e fb          	endbr32 
  80a0a4:	55                   	push   %ebp
  80a0a5:	89 e5                	mov    %esp,%ebp
  80a0a7:	53                   	push   %ebx
  80a0a8:	83 ec 04             	sub    $0x4,%esp
  80a0ab:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80a0ae:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  80a0b3:	85 c0                	test   %eax,%eax
  80a0b5:	74 3e                	je     80a0f5 <sys_sem_new+0x55>
    LIST_REMOVE(se, link);
  80a0b7:	8b 48 0c             	mov    0xc(%eax),%ecx
  80a0ba:	85 c9                	test   %ecx,%ecx
  80a0bc:	74 06                	je     80a0c4 <sys_sem_new+0x24>
  80a0be:	8b 58 10             	mov    0x10(%eax),%ebx
  80a0c1:	89 59 10             	mov    %ebx,0x10(%ecx)
  80a0c4:	8b 48 10             	mov    0x10(%eax),%ecx
  80a0c7:	8b 58 0c             	mov    0xc(%eax),%ebx
  80a0ca:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  80a0cc:	83 38 00             	cmpl   $0x0,(%eax)
  80a0cf:	74 3b                	je     80a10c <sys_sem_new+0x6c>
    se->freed = 0;
  80a0d1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  80a0d7:	0f b6 d2             	movzbl %dl,%edx
  80a0da:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  80a0de:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80a0e2:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  80a0e7:	c1 f8 02             	sar    $0x2,%eax
  80a0ea:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80a0f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a0f3:	c9                   	leave  
  80a0f4:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80a0f5:	83 ec 0c             	sub    $0xc,%esp
  80a0f8:	68 cc 27 81 00       	push   $0x8127cc
  80a0fd:	e8 1c 49 00 00       	call   80ea1e <cprintf>
	return SYS_SEM_NULL;
  80a102:	83 c4 10             	add    $0x10,%esp
  80a105:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a10a:	eb e4                	jmp    80a0f0 <sys_sem_new+0x50>
    assert(se->freed);
  80a10c:	68 41 29 81 00       	push   $0x812941
  80a111:	68 4b 29 81 00       	push   $0x81294b
  80a116:	68 8d 00 00 00       	push   $0x8d
  80a11b:	68 60 29 81 00       	push   $0x812960
  80a120:	e8 12 48 00 00       	call   80e937 <_panic>

0080a125 <sys_sem_free>:
{
  80a125:	f3 0f 1e fb          	endbr32 
  80a129:	55                   	push   %ebp
  80a12a:	89 e5                	mov    %esp,%ebp
  80a12c:	83 ec 08             	sub    $0x8,%esp
  80a12f:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a132:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a135:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a13c:	00 
  80a13d:	75 5a                	jne    80a199 <sys_sem_free+0x74>
    sems[sem].freed = 1;
  80a13f:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a142:	c1 e2 02             	shl    $0x2,%edx
  80a145:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  80a14c:	00 00 00 
    sems[sem].gen++;
  80a14f:	83 82 84 9d b3 00 01 	addl   $0x1,0xb39d84(%edx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a156:	8b 0d 60 9d b3 00    	mov    0xb39d60,%ecx
  80a15c:	89 8a 8c 9d b3 00    	mov    %ecx,0xb39d8c(%edx)
  80a162:	85 c9                	test   %ecx,%ecx
  80a164:	74 0d                	je     80a173 <sys_sem_free+0x4e>
  80a166:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a169:	8d 14 95 8c 9d b3 00 	lea    0xb39d8c(,%edx,4),%edx
  80a170:	89 51 10             	mov    %edx,0x10(%ecx)
  80a173:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a17a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a17d:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  80a184:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  80a18a:	01 d0                	add    %edx,%eax
  80a18c:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  80a193:	60 9d b3 00 
}
  80a197:	c9                   	leave  
  80a198:	c3                   	ret    
    assert(!sems[sem].freed);
  80a199:	68 7d 29 81 00       	push   $0x81297d
  80a19e:	68 4b 29 81 00       	push   $0x81294b
  80a1a3:	68 98 00 00 00       	push   $0x98
  80a1a8:	68 60 29 81 00       	push   $0x812960
  80a1ad:	e8 85 47 00 00       	call   80e937 <_panic>

0080a1b2 <sys_mbox_free>:
{
  80a1b2:	f3 0f 1e fb          	endbr32 
  80a1b6:	55                   	push   %ebp
  80a1b7:	89 e5                	mov    %esp,%ebp
  80a1b9:	56                   	push   %esi
  80a1ba:	53                   	push   %ebx
  80a1bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a1be:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1c4:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a1cb:	75 72                	jne    80a23f <sys_mbox_free+0x8d>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a1cd:	83 ec 0c             	sub    $0xc,%esp
  80a1d0:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a1d6:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  80a1dc:	e8 44 ff ff ff       	call   80a125 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a1e1:	83 c4 04             	add    $0x4,%esp
  80a1e4:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a1ea:	e8 36 ff ff ff       	call   80a125 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a1ef:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  80a1f4:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  80a1fa:	83 c4 10             	add    $0x10,%esp
  80a1fd:	85 c0                	test   %eax,%eax
  80a1ff:	74 12                	je     80a213 <sys_mbox_free+0x61>
  80a201:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a207:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  80a20d:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a213:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a219:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  80a21f:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  80a224:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  80a22b:	4f b3 00 
    mboxes[mbox].freed = 1;
  80a22e:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  80a235:	00 00 00 
}
  80a238:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a23b:	5b                   	pop    %ebx
  80a23c:	5e                   	pop    %esi
  80a23d:	5d                   	pop    %ebp
  80a23e:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a23f:	68 8e 29 81 00       	push   $0x81298e
  80a244:	68 4b 29 81 00       	push   $0x81294b
  80a249:	6a 62                	push   $0x62
  80a24b:	68 60 29 81 00       	push   $0x812960
  80a250:	e8 e2 46 00 00       	call   80e937 <_panic>

0080a255 <sys_mbox_new>:
{
  80a255:	f3 0f 1e fb          	endbr32 
  80a259:	55                   	push   %ebp
  80a25a:	89 e5                	mov    %esp,%ebp
  80a25c:	57                   	push   %edi
  80a25d:	56                   	push   %esi
  80a25e:	53                   	push   %ebx
  80a25f:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  80a262:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a266:	0f 8f 9f 00 00 00    	jg     80a30b <sys_mbox_new+0xb6>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a26c:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  80a272:	85 db                	test   %ebx,%ebx
  80a274:	0f 84 a7 00 00 00    	je     80a321 <sys_mbox_new+0xcc>
    LIST_REMOVE(mbe, link);
  80a27a:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a280:	85 c0                	test   %eax,%eax
  80a282:	74 0c                	je     80a290 <sys_mbox_new+0x3b>
  80a284:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a28a:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a290:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a296:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a29c:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a29e:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a2a1:	0f 84 91 00 00 00    	je     80a338 <sys_mbox_new+0xe3>
    mbe->freed = 0;
  80a2a7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  80a2ad:	89 de                	mov    %ebx,%esi
  80a2af:	81 ee 60 4f b3 00    	sub    $0xb34f60,%esi
  80a2b5:	c1 fe 02             	sar    $0x2,%esi
  80a2b8:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  80a2be:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  80a2c0:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a2c7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a2ce:	83 ec 0c             	sub    $0xc,%esp
  80a2d1:	6a 00                	push   $0x0
  80a2d3:	e8 c8 fd ff ff       	call   80a0a0 <sys_sem_new>
  80a2d8:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a2de:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a2e5:	e8 b6 fd ff ff       	call   80a0a0 <sys_sem_new>
  80a2ea:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a2f0:	83 c4 10             	add    $0x10,%esp
  80a2f3:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a2fa:	74 52                	je     80a34e <sys_mbox_new+0xf9>
  80a2fc:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a2ff:	74 4d                	je     80a34e <sys_mbox_new+0xf9>
}
  80a301:	89 f8                	mov    %edi,%eax
  80a303:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a306:	5b                   	pop    %ebx
  80a307:	5e                   	pop    %esi
  80a308:	5f                   	pop    %edi
  80a309:	5d                   	pop    %ebp
  80a30a:	c3                   	ret    
    assert(size < MBOXSLOTS);
  80a30b:	68 a2 29 81 00       	push   $0x8129a2
  80a310:	68 4b 29 81 00       	push   $0x81294b
  80a315:	6a 45                	push   $0x45
  80a317:	68 60 29 81 00       	push   $0x812960
  80a31c:	e8 16 46 00 00       	call   80e937 <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a321:	83 ec 0c             	sub    $0xc,%esp
  80a324:	68 f4 27 81 00       	push   $0x8127f4
  80a329:	e8 f0 46 00 00       	call   80ea1e <cprintf>
	return SYS_MBOX_NULL;
  80a32e:	83 c4 10             	add    $0x10,%esp
  80a331:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a336:	eb c9                	jmp    80a301 <sys_mbox_new+0xac>
    assert(mbe->freed);
  80a338:	68 b3 29 81 00       	push   $0x8129b3
  80a33d:	68 4b 29 81 00       	push   $0x81294b
  80a342:	6a 4c                	push   $0x4c
  80a344:	68 60 29 81 00       	push   $0x812960
  80a349:	e8 e9 45 00 00       	call   80e937 <_panic>
	sys_mbox_free(i);
  80a34e:	83 ec 0c             	sub    $0xc,%esp
  80a351:	56                   	push   %esi
  80a352:	e8 5b fe ff ff       	call   80a1b2 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a357:	c7 04 24 1c 28 81 00 	movl   $0x81281c,(%esp)
  80a35e:	e8 bb 46 00 00       	call   80ea1e <cprintf>
	return SYS_MBOX_NULL;
  80a363:	83 c4 10             	add    $0x10,%esp
  80a366:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a36b:	eb 94                	jmp    80a301 <sys_mbox_new+0xac>

0080a36d <sys_sem_signal>:
{
  80a36d:	f3 0f 1e fb          	endbr32 
  80a371:	55                   	push   %ebp
  80a372:	89 e5                	mov    %esp,%ebp
  80a374:	83 ec 08             	sub    $0x8,%esp
  80a377:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a37a:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a37d:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a384:	00 
  80a385:	75 18                	jne    80a39f <sys_sem_signal+0x32>
    sems[sem].counter++;
  80a387:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a38a:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  80a391:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a396:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a39b:	75 1b                	jne    80a3b8 <sys_sem_signal+0x4b>
}
  80a39d:	c9                   	leave  
  80a39e:	c3                   	ret    
    assert(!sems[sem].freed);
  80a39f:	68 7d 29 81 00       	push   $0x81297d
  80a3a4:	68 4b 29 81 00       	push   $0x81294b
  80a3a9:	68 a1 00 00 00       	push   $0xa1
  80a3ae:	68 60 29 81 00       	push   $0x812960
  80a3b3:	e8 7f 45 00 00       	call   80e937 <_panic>
	sems[sem].waiters = 0;
  80a3b8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a3bf:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a3c2:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  80a3c9:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a3cc:	83 ec 0c             	sub    $0xc,%esp
  80a3cf:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  80a3d6:	50                   	push   %eax
  80a3d7:	e8 cf 04 00 00       	call   80a8ab <thread_wakeup>
  80a3dc:	83 c4 10             	add    $0x10,%esp
}
  80a3df:	eb bc                	jmp    80a39d <sys_sem_signal+0x30>

0080a3e1 <sys_arch_sem_wait>:
{
  80a3e1:	f3 0f 1e fb          	endbr32 
  80a3e5:	55                   	push   %ebp
  80a3e6:	89 e5                	mov    %esp,%ebp
  80a3e8:	57                   	push   %edi
  80a3e9:	56                   	push   %esi
  80a3ea:	53                   	push   %ebx
  80a3eb:	83 ec 1c             	sub    $0x1c,%esp
  80a3ee:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a3f1:	8b 45 08             	mov    0x8(%ebp),%eax
  80a3f4:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a3f7:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  80a3fe:	00 
  80a3ff:	75 2c                	jne    80a42d <sys_arch_sem_wait+0x4c>
    int gen = sems[sem].gen;
  80a401:	8b 45 08             	mov    0x8(%ebp),%eax
  80a404:	c1 e0 02             	shl    $0x2,%eax
  80a407:	89 c2                	mov    %eax,%edx
  80a409:	03 55 08             	add    0x8(%ebp),%edx
  80a40c:	8b 1c 95 84 9d b3 00 	mov    0xb39d84(,%edx,4),%ebx
  80a413:	89 5d d8             	mov    %ebx,-0x28(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a416:	8d 04 95 88 9d b3 00 	lea    0xb39d88(,%edx,4),%eax
  80a41d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    u32_t waited = 0;
  80a420:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (sems[sem].counter > 0) {
  80a425:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    while (tm_msec == 0 || waited < tm_msec) {
  80a428:	e9 80 00 00 00       	jmp    80a4ad <sys_arch_sem_wait+0xcc>
    assert(!sems[sem].freed);
  80a42d:	68 7d 29 81 00       	push   $0x81297d
  80a432:	68 4b 29 81 00       	push   $0x81294b
  80a437:	68 ac 00 00 00       	push   $0xac
  80a43c:	68 60 29 81 00       	push   $0x812960
  80a441:	e8 f1 44 00 00       	call   80e937 <_panic>
	if (sems[sem].counter > 0) {
  80a446:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a449:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  80a450:	00 
  80a451:	66 85 c0             	test   %ax,%ax
  80a454:	75 6e                	jne    80a4c4 <sys_arch_sem_wait+0xe3>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a456:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a459:	0f 84 8f 00 00 00    	je     80a4ee <sys_arch_sem_wait+0x10d>
	    uint32_t a = sys_time_msec();
  80a45f:	e8 57 51 00 00       	call   80f5bb <sys_time_msec>
  80a464:	89 c1                	mov    %eax,%ecx
  80a466:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a469:	89 f0                	mov    %esi,%eax
  80a46b:	29 d8                	sub    %ebx,%eax
  80a46d:	01 c8                	add    %ecx,%eax
  80a46f:	85 f6                	test   %esi,%esi
  80a471:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a476:	0f 44 c2             	cmove  %edx,%eax
	    sems[sem].waiters = 1;
  80a479:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a47c:	8d 3c 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edi
  80a483:	66 c7 47 0a 01 00    	movw   $0x1,0xa(%edi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a489:	83 ec 04             	sub    $0x4,%esp
  80a48c:	50                   	push   %eax
  80a48d:	ff 77 08             	pushl  0x8(%edi)
  80a490:	ff 75 dc             	pushl  -0x24(%ebp)
  80a493:	e8 3e 06 00 00       	call   80aad6 <thread_wait>
	    if (gen != sems[sem].gen) {
  80a498:	83 c4 10             	add    $0x10,%esp
  80a49b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a49e:	39 47 04             	cmp    %eax,0x4(%edi)
  80a4a1:	75 34                	jne    80a4d7 <sys_arch_sem_wait+0xf6>
	    uint32_t b = sys_time_msec();
  80a4a3:	e8 13 51 00 00       	call   80f5bb <sys_time_msec>
	    waited += (b - a);
  80a4a8:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a4ab:	01 c3                	add    %eax,%ebx
    while (tm_msec == 0 || waited < tm_msec) {
  80a4ad:	85 f6                	test   %esi,%esi
  80a4af:	74 95                	je     80a446 <sys_arch_sem_wait+0x65>
  80a4b1:	39 f3                	cmp    %esi,%ebx
  80a4b3:	72 91                	jb     80a446 <sys_arch_sem_wait+0x65>
    return SYS_ARCH_TIMEOUT;
  80a4b5:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
  80a4ba:	89 d8                	mov    %ebx,%eax
  80a4bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a4bf:	5b                   	pop    %ebx
  80a4c0:	5e                   	pop    %esi
  80a4c1:	5f                   	pop    %edi
  80a4c2:	5d                   	pop    %ebp
  80a4c3:	c3                   	ret    
	    sems[sem].counter--;
  80a4c4:	8b 55 08             	mov    0x8(%ebp),%edx
  80a4c7:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a4ca:	83 e8 01             	sub    $0x1,%eax
  80a4cd:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a4d4:	00 
	    return waited;
  80a4d5:	eb e3                	jmp    80a4ba <sys_arch_sem_wait+0xd9>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a4d7:	83 ec 0c             	sub    $0xc,%esp
  80a4da:	68 48 28 81 00       	push   $0x812848
  80a4df:	e8 3a 45 00 00       	call   80ea1e <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a4e4:	83 c4 10             	add    $0x10,%esp
  80a4e7:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80a4ec:	eb cc                	jmp    80a4ba <sys_arch_sem_wait+0xd9>
	    return SYS_ARCH_TIMEOUT;
  80a4ee:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80a4f3:	eb c5                	jmp    80a4ba <sys_arch_sem_wait+0xd9>

0080a4f5 <sys_mbox_trypost>:
{
  80a4f5:	f3 0f 1e fb          	endbr32 
  80a4f9:	55                   	push   %ebp
  80a4fa:	89 e5                	mov    %esp,%ebp
  80a4fc:	57                   	push   %edi
  80a4fd:	56                   	push   %esi
  80a4fe:	53                   	push   %ebx
  80a4ff:	83 ec 0c             	sub    $0xc,%esp
  80a502:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a505:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a50b:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a512:	75 7f                	jne    80a593 <sys_mbox_trypost+0x9e>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a514:	83 ec 08             	sub    $0x8,%esp
  80a517:	6a 00                	push   $0x0
  80a519:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a51f:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a525:	e8 b7 fe ff ff       	call   80a3e1 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a52a:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a530:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a536:	83 c4 10             	add    $0x10,%esp
  80a539:	39 ca                	cmp    %ecx,%edx
  80a53b:	74 7a                	je     80a5b7 <sys_mbox_trypost+0xc2>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a53d:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a543:	8d 42 01             	lea    0x1(%edx),%eax
  80a546:	89 c7                	mov    %eax,%edi
  80a548:	c1 ff 1f             	sar    $0x1f,%edi
  80a54b:	c1 ef 1b             	shr    $0x1b,%edi
  80a54e:	01 f8                	add    %edi,%eax
  80a550:	83 e0 1f             	and    $0x1f,%eax
  80a553:	29 f8                	sub    %edi,%eax
  80a555:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a55b:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a55e:	01 d0                	add    %edx,%eax
  80a560:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a563:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a56a:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a56d:	74 3a                	je     80a5a9 <sys_mbox_trypost+0xb4>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a56f:	83 ec 0c             	sub    $0xc,%esp
  80a572:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a578:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a57e:	e8 ea fd ff ff       	call   80a36d <sys_sem_signal>
    return ERR_OK;
  80a583:	83 c4 10             	add    $0x10,%esp
  80a586:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a58b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a58e:	5b                   	pop    %ebx
  80a58f:	5e                   	pop    %esi
  80a590:	5f                   	pop    %edi
  80a591:	5d                   	pop    %ebp
  80a592:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a593:	68 8e 29 81 00       	push   $0x81298e
  80a598:	68 4b 29 81 00       	push   $0x81294b
  80a59d:	6a 72                	push   $0x72
  80a59f:	68 60 29 81 00       	push   $0x812960
  80a5a4:	e8 8e 43 00 00       	call   80e937 <_panic>
	mboxes[mbox].head = slot;
  80a5a9:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a5af:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)
  80a5b5:	eb b8                	jmp    80a56f <sys_mbox_trypost+0x7a>
	return ERR_MEM;
  80a5b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a5bc:	eb cd                	jmp    80a58b <sys_mbox_trypost+0x96>

0080a5be <sys_mbox_post>:
{
  80a5be:	f3 0f 1e fb          	endbr32 
  80a5c2:	55                   	push   %ebp
  80a5c3:	89 e5                	mov    %esp,%ebp
  80a5c5:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a5c8:	ff 75 0c             	pushl  0xc(%ebp)
  80a5cb:	ff 75 08             	pushl  0x8(%ebp)
  80a5ce:	e8 22 ff ff ff       	call   80a4f5 <sys_mbox_trypost>
  80a5d3:	83 c4 10             	add    $0x10,%esp
  80a5d6:	84 c0                	test   %al,%al
  80a5d8:	75 02                	jne    80a5dc <sys_mbox_post+0x1e>
}
  80a5da:	c9                   	leave  
  80a5db:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a5dc:	68 74 28 81 00       	push   $0x812874
  80a5e1:	68 4b 29 81 00       	push   $0x81294b
  80a5e6:	6a 6c                	push   $0x6c
  80a5e8:	68 60 29 81 00       	push   $0x812960
  80a5ed:	e8 45 43 00 00       	call   80e937 <_panic>

0080a5f2 <sys_arch_mbox_fetch>:
{
  80a5f2:	f3 0f 1e fb          	endbr32 
  80a5f6:	55                   	push   %ebp
  80a5f7:	89 e5                	mov    %esp,%ebp
  80a5f9:	57                   	push   %edi
  80a5fa:	56                   	push   %esi
  80a5fb:	53                   	push   %ebx
  80a5fc:	83 ec 0c             	sub    $0xc,%esp
  80a5ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a602:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a605:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a60b:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a612:	0f 85 8a 00 00 00    	jne    80a6a2 <sys_arch_mbox_fetch+0xb0>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a618:	83 ec 08             	sub    $0x8,%esp
  80a61b:	ff 75 10             	pushl  0x10(%ebp)
  80a61e:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a624:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a62a:	e8 b2 fd ff ff       	call   80a3e1 <sys_arch_sem_wait>
  80a62f:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a631:	83 c4 10             	add    $0x10,%esp
  80a634:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a637:	74 5f                	je     80a698 <sys_arch_mbox_fetch+0xa6>
    int slot = mboxes[mbox].head;
  80a639:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a63f:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a645:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a648:	74 71                	je     80a6bb <sys_arch_mbox_fetch+0xc9>
    if (msg)
  80a64a:	85 ff                	test   %edi,%edi
  80a64c:	74 0e                	je     80a65c <sys_arch_mbox_fetch+0x6a>
	*msg = mboxes[mbox].msg[slot];
  80a64e:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a651:	01 c2                	add    %eax,%edx
  80a653:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a65a:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a65c:	83 c0 01             	add    $0x1,%eax
  80a65f:	99                   	cltd   
  80a660:	c1 ea 1b             	shr    $0x1b,%edx
  80a663:	01 d0                	add    %edx,%eax
  80a665:	83 e0 1f             	and    $0x1f,%eax
  80a668:	29 d0                	sub    %edx,%eax
  80a66a:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a670:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a676:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a67c:	3b 42 08             	cmp    0x8(%edx),%eax
  80a67f:	74 51                	je     80a6d2 <sys_arch_mbox_fetch+0xe0>
    sys_sem_signal(mboxes[mbox].free_msg);
  80a681:	83 ec 0c             	sub    $0xc,%esp
  80a684:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a68a:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a690:	e8 d8 fc ff ff       	call   80a36d <sys_sem_signal>
    return waited;
  80a695:	83 c4 10             	add    $0x10,%esp
}
  80a698:	89 f0                	mov    %esi,%eax
  80a69a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a69d:	5b                   	pop    %ebx
  80a69e:	5e                   	pop    %esi
  80a69f:	5f                   	pop    %edi
  80a6a0:	5d                   	pop    %ebp
  80a6a1:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a6a2:	68 8e 29 81 00       	push   $0x81298e
  80a6a7:	68 4b 29 81 00       	push   $0x81294b
  80a6ac:	68 ce 00 00 00       	push   $0xce
  80a6b1:	68 60 29 81 00       	push   $0x812960
  80a6b6:	e8 7c 42 00 00       	call   80e937 <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a6bb:	83 ec 04             	sub    $0x4,%esp
  80a6be:	68 9c 28 81 00       	push   $0x81289c
  80a6c3:	68 d6 00 00 00       	push   $0xd6
  80a6c8:	68 60 29 81 00       	push   $0x812960
  80a6cd:	e8 65 42 00 00       	call   80e937 <_panic>
	mboxes[mbox].head = -1;
  80a6d2:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a6d8:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a6df:	ff ff ff 
  80a6e2:	eb 9d                	jmp    80a681 <sys_arch_mbox_fetch+0x8f>

0080a6e4 <sys_arch_mbox_tryfetch>:
{
  80a6e4:	f3 0f 1e fb          	endbr32 
  80a6e8:	55                   	push   %ebp
  80a6e9:	89 e5                	mov    %esp,%ebp
  80a6eb:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a6ee:	6a fe                	push   $0xfffffffe
  80a6f0:	ff 75 0c             	pushl  0xc(%ebp)
  80a6f3:	ff 75 08             	pushl  0x8(%ebp)
  80a6f6:	e8 f7 fe ff ff       	call   80a5f2 <sys_arch_mbox_fetch>
}
  80a6fb:	c9                   	leave  
  80a6fc:	c3                   	ret    

0080a6fd <sys_thread_new>:
{
  80a6fd:	f3 0f 1e fb          	endbr32 
  80a701:	55                   	push   %ebp
  80a702:	89 e5                	mov    %esp,%ebp
  80a704:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a707:	6a 08                	push   $0x8
  80a709:	e8 66 60 00 00       	call   810774 <malloc>
    if (lt == 0)
  80a70e:	83 c4 10             	add    $0x10,%esp
  80a711:	85 c0                	test   %eax,%eax
  80a713:	74 32                	je     80a747 <sys_thread_new+0x4a>
    if (stacksize > PGSIZE)
  80a715:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a71c:	7f 40                	jg     80a75e <sys_thread_new+0x61>
    lt->func = thread;
  80a71e:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a721:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a723:	8b 55 10             	mov    0x10(%ebp),%edx
  80a726:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a729:	50                   	push   %eax
  80a72a:	68 82 9f 80 00       	push   $0x809f82
  80a72f:	ff 75 08             	pushl  0x8(%ebp)
  80a732:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a735:	50                   	push   %eax
  80a736:	e8 e7 01 00 00       	call   80a922 <thread_create>
    if (r < 0)
  80a73b:	83 c4 10             	add    $0x10,%esp
  80a73e:	85 c0                	test   %eax,%eax
  80a740:	78 33                	js     80a775 <sys_thread_new+0x78>
}
  80a742:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a745:	c9                   	leave  
  80a746:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a747:	83 ec 04             	sub    $0x4,%esp
  80a74a:	68 c4 28 81 00       	push   $0x8128c4
  80a74f:	68 fd 00 00 00       	push   $0xfd
  80a754:	68 60 29 81 00       	push   $0x812960
  80a759:	e8 d9 41 00 00       	call   80e937 <_panic>
	panic("large stack %d", stacksize);
  80a75e:	ff 75 14             	pushl  0x14(%ebp)
  80a761:	68 be 29 81 00       	push   $0x8129be
  80a766:	68 00 01 00 00       	push   $0x100
  80a76b:	68 60 29 81 00       	push   $0x812960
  80a770:	e8 c2 41 00 00       	call   80e937 <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a775:	83 ec 0c             	sub    $0xc,%esp
  80a778:	50                   	push   %eax
  80a779:	e8 ef 04 00 00       	call   80ac6d <e2s>
  80a77e:	50                   	push   %eax
  80a77f:	68 f4 28 81 00       	push   $0x8128f4
  80a784:	68 09 01 00 00       	push   $0x109
  80a789:	68 60 29 81 00       	push   $0x812960
  80a78e:	e8 a4 41 00 00       	call   80e937 <_panic>

0080a793 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a793:	f3 0f 1e fb          	endbr32 
  80a797:	55                   	push   %ebp
  80a798:	89 e5                	mov    %esp,%ebp
  80a79a:	57                   	push   %edi
  80a79b:	56                   	push   %esi
  80a79c:	53                   	push   %ebx
  80a79d:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a7a0:	e8 fa 00 00 00       	call   80a89f <thread_id>
  80a7a5:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a7a7:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a7ac:	f7 e2                	mul    %edx
  80a7ae:	89 d7                	mov    %edx,%edi
  80a7b0:	c1 ef 08             	shr    $0x8,%edi
  80a7b3:	b2 00                	mov    $0x0,%dl
  80a7b5:	01 d7                	add    %edx,%edi
  80a7b7:	89 f0                	mov    %esi,%eax
  80a7b9:	29 f8                	sub    %edi,%eax
  80a7bb:	89 c7                	mov    %eax,%edi
  80a7bd:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a7c4:	85 db                	test   %ebx,%ebx
  80a7c6:	74 09                	je     80a7d1 <sys_arch_timeouts+0x3e>
	if (t->tid == tid)
  80a7c8:	39 33                	cmp    %esi,(%ebx)
  80a7ca:	74 66                	je     80a832 <sys_arch_timeouts+0x9f>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a7cc:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a7cf:	eb f3                	jmp    80a7c4 <sys_arch_timeouts+0x31>
	    goto out;

    t = malloc(sizeof(*t));
  80a7d1:	83 ec 0c             	sub    $0xc,%esp
  80a7d4:	6a 10                	push   $0x10
  80a7d6:	e8 99 5f 00 00       	call   810774 <malloc>
  80a7db:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a7dd:	83 c4 10             	add    $0x10,%esp
  80a7e0:	85 c0                	test   %eax,%eax
  80a7e2:	74 59                	je     80a83d <sys_arch_timeouts+0xaa>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a7e4:	83 ec 0c             	sub    $0xc,%esp
  80a7e7:	68 a5 9f 80 00       	push   $0x809fa5
  80a7ec:	e8 03 01 00 00       	call   80a8f4 <thread_onhalt>
    if (r < 0)
  80a7f1:	83 c4 10             	add    $0x10,%esp
  80a7f4:	85 c0                	test   %eax,%eax
  80a7f6:	78 5c                	js     80a854 <sys_arch_timeouts+0xc1>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a7f8:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a7fa:	83 ec 04             	sub    $0x4,%esp
  80a7fd:	6a 04                	push   $0x4
  80a7ff:	6a 00                	push   $0x0
  80a801:	8d 43 04             	lea    0x4(%ebx),%eax
  80a804:	50                   	push   %eax
  80a805:	e8 d0 49 00 00       	call   80f1da <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a80a:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a811:	89 43 08             	mov    %eax,0x8(%ebx)
  80a814:	83 c4 10             	add    $0x10,%esp
  80a817:	85 c0                	test   %eax,%eax
  80a819:	74 06                	je     80a821 <sys_arch_timeouts+0x8e>
  80a81b:	8d 53 08             	lea    0x8(%ebx),%edx
  80a81e:	89 50 0c             	mov    %edx,0xc(%eax)
  80a821:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a828:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a82f:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a832:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a835:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a838:	5b                   	pop    %ebx
  80a839:	5e                   	pop    %esi
  80a83a:	5f                   	pop    %edi
  80a83b:	5d                   	pop    %ebp
  80a83c:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a83d:	83 ec 04             	sub    $0x4,%esp
  80a840:	68 20 29 81 00       	push   $0x812920
  80a845:	68 2c 01 00 00       	push   $0x12c
  80a84a:	68 60 29 81 00       	push   $0x812960
  80a84f:	e8 e3 40 00 00       	call   80e937 <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a854:	83 ec 0c             	sub    $0xc,%esp
  80a857:	50                   	push   %eax
  80a858:	e8 10 04 00 00       	call   80ac6d <e2s>
  80a85d:	50                   	push   %eax
  80a85e:	68 cd 29 81 00       	push   $0x8129cd
  80a863:	68 30 01 00 00       	push   $0x130
  80a868:	68 60 29 81 00       	push   $0x812960
  80a86d:	e8 c5 40 00 00       	call   80e937 <_panic>

0080a872 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80a872:	f3 0f 1e fb          	endbr32 
}
  80a876:	c3                   	ret    

0080a877 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a877:	f3 0f 1e fb          	endbr32 
}
  80a87b:	c3                   	ret    

0080a87c <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80a87c:	f3 0f 1e fb          	endbr32 
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a880:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a887:	00 00 00 
    tq->tq_last = 0;
  80a88a:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a891:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80a894:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a89b:	00 00 00 
}
  80a89e:	c3                   	ret    

0080a89f <thread_id>:

uint32_t
thread_id(void) {
  80a89f:	f3 0f 1e fb          	endbr32 
    return cur_tc->tc_tid;
  80a8a3:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a8a8:	8b 00                	mov    (%eax),%eax
}
  80a8aa:	c3                   	ret    

0080a8ab <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a8ab:	f3 0f 1e fb          	endbr32 
  80a8af:	55                   	push   %ebp
  80a8b0:	89 e5                	mov    %esp,%ebp
  80a8b2:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a8b5:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a8ba:	eb 07                	jmp    80a8c3 <thread_wakeup+0x18>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
  80a8bc:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a8c0:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a8c3:	85 c0                	test   %eax,%eax
  80a8c5:	74 07                	je     80a8ce <thread_wakeup+0x23>
	if (tc->tc_wait_addr == addr)
  80a8c7:	39 50 48             	cmp    %edx,0x48(%eax)
  80a8ca:	75 f4                	jne    80a8c0 <thread_wakeup+0x15>
  80a8cc:	eb ee                	jmp    80a8bc <thread_wakeup+0x11>
    }
}
  80a8ce:	5d                   	pop    %ebp
  80a8cf:	c3                   	ret    

0080a8d0 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80a8d0:	f3 0f 1e fb          	endbr32 
    struct thread_context *tc = thread_queue.tq_first;
  80a8d4:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    int n = 0;
  80a8d9:	b9 00 00 00 00       	mov    $0x0,%ecx
    while (tc) {
  80a8de:	85 c0                	test   %eax,%eax
  80a8e0:	74 0f                	je     80a8f1 <thread_wakeups_pending+0x21>
	if (tc->tc_wakeup)
  80a8e2:	0f b6 50 4c          	movzbl 0x4c(%eax),%edx
	    ++n;
  80a8e6:	80 fa 01             	cmp    $0x1,%dl
  80a8e9:	83 d9 ff             	sbb    $0xffffffff,%ecx
	tc = tc->tc_queue_link;
  80a8ec:	8b 40 64             	mov    0x64(%eax),%eax
  80a8ef:	eb ed                	jmp    80a8de <thread_wakeups_pending+0xe>
    }
    return n;
}
  80a8f1:	89 c8                	mov    %ecx,%eax
  80a8f3:	c3                   	ret    

0080a8f4 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80a8f4:	f3 0f 1e fb          	endbr32 
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a8f8:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a8fd:	8b 50 60             	mov    0x60(%eax),%edx
  80a900:	83 fa 03             	cmp    $0x3,%edx
  80a903:	7f 17                	jg     80a91c <thread_onhalt+0x28>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a905:	55                   	push   %ebp
  80a906:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a908:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a90b:	89 48 60             	mov    %ecx,0x60(%eax)
  80a90e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a911:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a915:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a91a:	5d                   	pop    %ebp
  80a91b:	c3                   	ret    
	return -E_NO_MEM;
  80a91c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a921:	c3                   	ret    

0080a922 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a922:	f3 0f 1e fb          	endbr32 
  80a926:	55                   	push   %ebp
  80a927:	89 e5                	mov    %esp,%ebp
  80a929:	57                   	push   %edi
  80a92a:	56                   	push   %esi
  80a92b:	53                   	push   %ebx
  80a92c:	83 ec 18             	sub    $0x18,%esp
  80a92f:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a932:	6a 68                	push   $0x68
  80a934:	e8 3b 5e 00 00       	call   810774 <malloc>
    if (!tc)
  80a939:	83 c4 10             	add    $0x10,%esp
  80a93c:	85 c0                	test   %eax,%eax
  80a93e:	0f 84 04 01 00 00    	je     80aa48 <thread_create+0x126>
  80a944:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a946:	83 ec 04             	sub    $0x4,%esp
  80a949:	6a 68                	push   $0x68
  80a94b:	6a 00                	push   $0x0
  80a94d:	50                   	push   %eax
  80a94e:	e8 87 48 00 00       	call   80f1da <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a953:	83 c4 0c             	add    $0xc,%esp
  80a956:	6a 1f                	push   $0x1f
  80a958:	ff 75 0c             	pushl  0xc(%ebp)
  80a95b:	8d 43 08             	lea    0x8(%ebx),%eax
  80a95e:	50                   	push   %eax
  80a95f:	e8 13 47 00 00       	call   80f077 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a964:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a968:	a1 94 b1 b3 00       	mov    0xb3b194,%eax
  80a96d:	8d 50 01             	lea    0x1(%eax),%edx
  80a970:	89 15 94 b1 b3 00    	mov    %edx,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a976:	83 c4 10             	add    $0x10,%esp
  80a979:	83 fa ff             	cmp    $0xffffffff,%edx
  80a97c:	0f 84 91 00 00 00    	je     80aa13 <thread_create+0xf1>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a982:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a984:	83 ec 0c             	sub    $0xc,%esp
  80a987:	68 00 10 00 00       	push   $0x1000
  80a98c:	e8 e3 5d 00 00       	call   810774 <malloc>
  80a991:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a994:	83 c4 10             	add    $0x10,%esp
  80a997:	85 c0                	test   %eax,%eax
  80a999:	0f 84 88 00 00 00    	je     80aa27 <thread_create+0x105>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a99f:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a9a5:	83 ec 04             	sub    $0x4,%esp
  80a9a8:	6a 04                	push   $0x4
  80a9aa:	6a 00                	push   $0x0
  80a9ac:	57                   	push   %edi
  80a9ad:	e8 28 48 00 00       	call   80f1da <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a9b2:	83 c4 0c             	add    $0xc,%esp
  80a9b5:	6a 18                	push   $0x18
  80a9b7:	6a 00                	push   $0x0
  80a9b9:	8d 43 30             	lea    0x30(%ebx),%eax
  80a9bc:	50                   	push   %eax
  80a9bd:	e8 18 48 00 00       	call   80f1da <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a9c2:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a9c5:	c7 43 30 df ab 80 00 	movl   $0x80abdf,0x30(%ebx)
    tc->tc_entry = entry;
  80a9cc:	8b 45 10             	mov    0x10(%ebp),%eax
  80a9cf:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a9d2:	8b 45 14             	mov    0x14(%ebp),%eax
  80a9d5:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a9d8:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a9df:	83 c4 10             	add    $0x10,%esp
  80a9e2:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a9e9:	74 4f                	je     80aa3a <thread_create+0x118>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a9eb:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a9f0:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a9f3:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a9f9:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80a9fe:	85 f6                	test   %esi,%esi
  80aa00:	74 09                	je     80aa0b <thread_create+0xe9>
	*tid = tc->tc_tid;
  80aa02:	8b 03                	mov    (%ebx),%eax
  80aa04:	89 06                	mov    %eax,(%esi)
    return 0;
  80aa06:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80aa0b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aa0e:	5b                   	pop    %ebx
  80aa0f:	5e                   	pop    %esi
  80aa10:	5f                   	pop    %edi
  80aa11:	5d                   	pop    %ebp
  80aa12:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80aa13:	83 ec 04             	sub    $0x4,%esp
  80aa16:	68 e6 29 81 00       	push   $0x8129e6
  80aa1b:	6a 54                	push   $0x54
  80aa1d:	68 04 2a 81 00       	push   $0x812a04
  80aa22:	e8 10 3f 00 00       	call   80e937 <_panic>
	free(tc);
  80aa27:	83 ec 0c             	sub    $0xc,%esp
  80aa2a:	53                   	push   %ebx
  80aa2b:	e8 94 5c 00 00       	call   8106c4 <free>
	return -E_NO_MEM;
  80aa30:	83 c4 10             	add    $0x10,%esp
  80aa33:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80aa38:	eb d1                	jmp    80aa0b <thread_create+0xe9>
	tq->tq_first = tc;
  80aa3a:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80aa40:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80aa46:	eb b1                	jmp    80a9f9 <thread_create+0xd7>
	return -E_NO_MEM;
  80aa48:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80aa4d:	eb bc                	jmp    80aa0b <thread_create+0xe9>

0080aa4f <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80aa4f:	f3 0f 1e fb          	endbr32 
  80aa53:	55                   	push   %ebp
  80aa54:	89 e5                	mov    %esp,%ebp
  80aa56:	53                   	push   %ebx
  80aa57:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80aa5a:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80aa60:	85 db                	test   %ebx,%ebx
  80aa62:	74 2b                	je     80aa8f <thread_yield+0x40>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80aa64:	8b 43 64             	mov    0x64(%ebx),%eax
  80aa67:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80aa6c:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80aa73:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80aa78:	85 c0                	test   %eax,%eax
  80aa7a:	74 3b                	je     80aab7 <thread_yield+0x68>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80aa7c:	83 ec 0c             	sub    $0xc,%esp
  80aa7f:	83 c0 30             	add    $0x30,%eax
  80aa82:	50                   	push   %eax
  80aa83:	e8 78 01 00 00       	call   80ac00 <jos_setjmp>
  80aa88:	83 c4 10             	add    $0x10,%esp
  80aa8b:	85 c0                	test   %eax,%eax
  80aa8d:	74 05                	je     80aa94 <thread_yield+0x45>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80aa8f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aa92:	c9                   	leave  
  80aa93:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80aa94:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80aa99:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80aaa0:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80aaa7:	74 21                	je     80aaca <thread_yield+0x7b>
	tq->tq_last->tc_queue_link = tc;
  80aaa9:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80aaaf:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80aab2:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    cur_tc = next_tc;
  80aab7:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80aabd:	8d 43 30             	lea    0x30(%ebx),%eax
  80aac0:	ba 01 00 00 00       	mov    $0x1,%edx
  80aac5:	e8 66 01 00 00       	call   80ac30 <jos_longjmp>
	tq->tq_first = tc;
  80aaca:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80aacf:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80aad4:	eb e1                	jmp    80aab7 <thread_yield+0x68>

0080aad6 <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80aad6:	f3 0f 1e fb          	endbr32 
  80aada:	55                   	push   %ebp
  80aadb:	89 e5                	mov    %esp,%ebp
  80aadd:	57                   	push   %edi
  80aade:	56                   	push   %esi
  80aadf:	53                   	push   %ebx
  80aae0:	83 ec 0c             	sub    $0xc,%esp
  80aae3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aae6:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80aae9:	e8 cd 4a 00 00       	call   80f5bb <sys_time_msec>
  80aaee:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80aaf0:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80aaf5:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80aaf8:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80aafc:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80aafe:	eb 17                	jmp    80ab17 <thread_wait+0x41>
	if (cur_tc->tc_wakeup)
  80ab00:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80ab05:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80ab09:	84 c0                	test   %al,%al
  80ab0b:	75 1d                	jne    80ab2a <thread_wait+0x54>
	thread_yield();
  80ab0d:	e8 3d ff ff ff       	call   80aa4f <thread_yield>
	p = sys_time_msec();
  80ab12:	e8 a4 4a 00 00       	call   80f5bb <sys_time_msec>
	if (p < s)
  80ab17:	39 f0                	cmp    %esi,%eax
  80ab19:	72 0f                	jb     80ab2a <thread_wait+0x54>
  80ab1b:	39 f8                	cmp    %edi,%eax
  80ab1d:	73 0b                	jae    80ab2a <thread_wait+0x54>
	if (addr && *addr != val)
  80ab1f:	85 db                	test   %ebx,%ebx
  80ab21:	74 dd                	je     80ab00 <thread_wait+0x2a>
  80ab23:	8b 03                	mov    (%ebx),%eax
  80ab25:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80ab28:	74 d6                	je     80ab00 <thread_wait+0x2a>
    cur_tc->tc_wait_addr = 0;
  80ab2a:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80ab2f:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80ab36:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80ab3a:	83 c4 0c             	add    $0xc,%esp
  80ab3d:	5b                   	pop    %ebx
  80ab3e:	5e                   	pop    %esi
  80ab3f:	5f                   	pop    %edi
  80ab40:	5d                   	pop    %ebp
  80ab41:	c3                   	ret    

0080ab42 <thread_halt>:
thread_halt() {
  80ab42:	f3 0f 1e fb          	endbr32 
  80ab46:	55                   	push   %ebp
  80ab47:	89 e5                	mov    %esp,%ebp
  80ab49:	56                   	push   %esi
  80ab4a:	53                   	push   %ebx
    if (!tq->tq_first)
  80ab4b:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80ab51:	85 db                	test   %ebx,%ebx
  80ab53:	74 40                	je     80ab95 <thread_halt+0x53>
    tq->tq_first = tc->tc_queue_link;
  80ab55:	8b 43 64             	mov    0x64(%ebx),%eax
  80ab58:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80ab5d:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80ab64:	be 00 00 00 00       	mov    $0x0,%esi
  80ab69:	eb 0f                	jmp    80ab7a <thread_halt+0x38>
	tc->tc_onhalt[i](tc->tc_tid);
  80ab6b:	83 ec 0c             	sub    $0xc,%esp
  80ab6e:	ff 33                	pushl  (%ebx)
  80ab70:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80ab74:	83 c6 01             	add    $0x1,%esi
  80ab77:	83 c4 10             	add    $0x10,%esp
  80ab7a:	3b 73 60             	cmp    0x60(%ebx),%esi
  80ab7d:	7c ec                	jl     80ab6b <thread_halt+0x29>
    free(tc->tc_stack_bottom);
  80ab7f:	83 ec 0c             	sub    $0xc,%esp
  80ab82:	ff 73 04             	pushl  0x4(%ebx)
  80ab85:	e8 3a 5b 00 00       	call   8106c4 <free>
    free(tc);
  80ab8a:	89 1c 24             	mov    %ebx,(%esp)
  80ab8d:	e8 32 5b 00 00       	call   8106c4 <free>
  80ab92:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80ab95:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80ab9a:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80aba1:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80aba8:	74 29                	je     80abd3 <thread_halt+0x91>
	tq->tq_last->tc_queue_link = tc;
  80abaa:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80abb0:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80abb3:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80abb8:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80abbf:	00 00 00 
    thread_yield();
  80abc2:	e8 88 fe ff ff       	call   80aa4f <thread_yield>
    exit();
  80abc7:	e8 4d 3d 00 00       	call   80e919 <exit>
}
  80abcc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80abcf:	5b                   	pop    %ebx
  80abd0:	5e                   	pop    %esi
  80abd1:	5d                   	pop    %ebp
  80abd2:	c3                   	ret    
	tq->tq_first = tc;
  80abd3:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80abd8:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80abdd:	eb d9                	jmp    80abb8 <thread_halt+0x76>

0080abdf <thread_entry>:
thread_entry(void) {
  80abdf:	f3 0f 1e fb          	endbr32 
  80abe3:	55                   	push   %ebp
  80abe4:	89 e5                	mov    %esp,%ebp
  80abe6:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80abe9:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80abee:	ff 70 2c             	pushl  0x2c(%eax)
  80abf1:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80abf4:	e8 49 ff ff ff       	call   80ab42 <thread_halt>
}
  80abf9:	83 c4 10             	add    $0x10,%esp
  80abfc:	c9                   	leave  
  80abfd:	c3                   	ret    
  80abfe:	66 90                	xchg   %ax,%ax

0080ac00 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80ac00:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80ac04:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80ac07:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80ac09:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80ac0d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80ac10:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80ac13:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80ac16:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80ac19:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80ac1c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80ac21:	c3                   	ret    
  80ac22:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80ac29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0080ac30 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80ac30:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80ac32:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80ac35:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80ac38:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80ac3b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80ac3e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80ac41:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80ac43:	ff e1                	jmp    *%ecx

0080ac45 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80ac45:	f3 0f 1e fb          	endbr32 
  80ac49:	55                   	push   %ebp
  80ac4a:	89 e5                	mov    %esp,%ebp
  80ac4c:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80ac4f:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80ac54:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80ac5b:	ff 75 08             	pushl  0x8(%ebp)
  80ac5e:	68 1f 2a 81 00       	push   $0x812a1f
  80ac63:	e8 b6 3d 00 00       	call   80ea1e <cprintf>
}
  80ac68:	83 c4 10             	add    $0x10,%esp
  80ac6b:	c9                   	leave  
  80ac6c:	c3                   	ret    

0080ac6d <e2s>:
e2s(int err) {
  80ac6d:	f3 0f 1e fb          	endbr32 
  80ac71:	55                   	push   %ebp
  80ac72:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80ac74:	8b 45 08             	mov    0x8(%ebp),%eax
  80ac77:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80ac7e:	5d                   	pop    %ebp
  80ac7f:	c3                   	ret    

0080ac80 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80ac80:	f3 0f 1e fb          	endbr32 
  80ac84:	55                   	push   %ebp
  80ac85:	89 e5                	mov    %esp,%ebp
  80ac87:	57                   	push   %edi
  80ac88:	56                   	push   %esi
  80ac89:	53                   	push   %ebx
  80ac8a:	83 ec 20             	sub    $0x20,%esp
  80ac8d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80ac90:	6a 07                	push   $0x7
  80ac92:	68 00 00 00 10       	push   $0x10000000
  80ac97:	6a 00                	push   $0x0
  80ac99:	e8 f3 47 00 00       	call   80f491 <sys_page_alloc>
    if (r < 0)
  80ac9e:	83 c4 10             	add    $0x10,%esp
  80aca1:	85 c0                	test   %eax,%eax
  80aca3:	78 49                	js     80acee <low_level_output+0x6e>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80aca5:	8b 45 08             	mov    0x8(%ebp),%eax
  80aca8:	8b 40 1c             	mov    0x1c(%eax),%eax
  80acab:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80acae:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80acb3:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80acb8:	85 db                	test   %ebx,%ebx
  80acba:	74 5c                	je     80ad18 <low_level_output+0x98>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80acbc:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80acc0:	0f b7 d0             	movzwl %ax,%edx
  80acc3:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80acc6:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80accc:	7f 34                	jg     80ad02 <low_level_output+0x82>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80acce:	83 ec 04             	sub    $0x4,%esp
  80acd1:	0f b7 c0             	movzwl %ax,%eax
  80acd4:	50                   	push   %eax
  80acd5:	ff 73 04             	pushl  0x4(%ebx)
  80acd8:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80acdb:	50                   	push   %eax
  80acdc:	e8 ab 45 00 00       	call   80f28c <memcpy>
	txsize += q->len;
  80ace1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ace5:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80ace7:	8b 1b                	mov    (%ebx),%ebx
  80ace9:	83 c4 10             	add    $0x10,%esp
  80acec:	eb ca                	jmp    80acb8 <low_level_output+0x38>
	panic("jif: could not allocate page of memory");
  80acee:	83 ec 04             	sub    $0x4,%esp
  80acf1:	68 04 2f 81 00       	push   $0x812f04
  80acf6:	6a 55                	push   $0x55
  80acf8:	68 55 2f 81 00       	push   $0x812f55
  80acfd:	e8 35 3c 00 00       	call   80e937 <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80ad02:	83 ec 0c             	sub    $0xc,%esp
  80ad05:	56                   	push   %esi
  80ad06:	52                   	push   %edx
  80ad07:	68 2c 2f 81 00       	push   $0x812f2c
  80ad0c:	6a 64                	push   $0x64
  80ad0e:	68 55 2f 81 00       	push   $0x812f55
  80ad13:	e8 1f 3c 00 00       	call   80e937 <_panic>
    }

    pkt->jp_len = txsize;
  80ad18:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80ad1e:	6a 07                	push   $0x7
  80ad20:	68 00 00 00 10       	push   $0x10000000
  80ad25:	6a 0b                	push   $0xb
  80ad27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ad2a:	ff 70 04             	pushl  0x4(%eax)
  80ad2d:	e8 f0 4b 00 00       	call   80f922 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80ad32:	83 c4 08             	add    $0x8,%esp
  80ad35:	68 00 00 00 10       	push   $0x10000000
  80ad3a:	6a 00                	push   $0x0
  80ad3c:	e8 9b 47 00 00       	call   80f4dc <sys_page_unmap>

    return ERR_OK;
}
  80ad41:	b8 00 00 00 00       	mov    $0x0,%eax
  80ad46:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ad49:	5b                   	pop    %ebx
  80ad4a:	5e                   	pop    %esi
  80ad4b:	5f                   	pop    %edi
  80ad4c:	5d                   	pop    %ebp
  80ad4d:	c3                   	ret    

0080ad4e <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80ad4e:	f3 0f 1e fb          	endbr32 
  80ad52:	55                   	push   %ebp
  80ad53:	89 e5                	mov    %esp,%ebp
  80ad55:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80ad58:	ff 75 10             	pushl  0x10(%ebp)
  80ad5b:	ff 75 0c             	pushl  0xc(%ebp)
  80ad5e:	ff 75 08             	pushl  0x8(%ebp)
  80ad61:	e8 8b f0 ff ff       	call   809df1 <etharp_output>
}
  80ad66:	c9                   	leave  
  80ad67:	c3                   	ret    

0080ad68 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80ad68:	f3 0f 1e fb          	endbr32 
  80ad6c:	55                   	push   %ebp
  80ad6d:	89 e5                	mov    %esp,%ebp
  80ad6f:	57                   	push   %edi
  80ad70:	56                   	push   %esi
  80ad71:	53                   	push   %ebx
  80ad72:	83 ec 20             	sub    $0x20,%esp
  80ad75:	8b 7d 0c             	mov    0xc(%ebp),%edi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80ad78:	8b 45 08             	mov    0x8(%ebp),%eax
  80ad7b:	8b 40 1c             	mov    0x1c(%eax),%eax
  80ad7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80ad81:	8b 07                	mov    (%edi),%eax
  80ad83:	89 c6                	mov    %eax,%esi
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80ad85:	6a 03                	push   $0x3
  80ad87:	0f b7 c0             	movzwl %ax,%eax
  80ad8a:	50                   	push   %eax
  80ad8b:	6a 03                	push   $0x3
  80ad8d:	e8 53 9d ff ff       	call   804ae5 <pbuf_alloc>
    if (p == 0)
  80ad92:	83 c4 10             	add    $0x10,%esp
  80ad95:	85 c0                	test   %eax,%eax
  80ad97:	0f 84 9c 00 00 00    	je     80ae39 <jif_input+0xd1>
  80ad9d:	89 c3                	mov    %eax,%ebx
    void *rxbuf = (void *) pkt->jp_data;
  80ad9f:	8d 47 04             	lea    0x4(%edi),%eax
  80ada2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80ada5:	89 df                	mov    %ebx,%edi
    int copied = 0;
  80ada7:	ba 00 00 00 00       	mov    $0x0,%edx
	if (bytes > (len - copied))
  80adac:	0f bf c6             	movswl %si,%eax
  80adaf:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80adb2:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  80adb5:	89 d3                	mov    %edx,%ebx
	int bytes = q->len;
  80adb7:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
	if (bytes > (len - copied))
  80adbb:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80adbe:	29 de                	sub    %ebx,%esi
  80adc0:	39 c6                	cmp    %eax,%esi
  80adc2:	0f 4f f0             	cmovg  %eax,%esi
	memcpy(q->payload, rxbuf + copied, bytes);
  80adc5:	83 ec 04             	sub    $0x4,%esp
  80adc8:	56                   	push   %esi
  80adc9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80adcc:	01 d8                	add    %ebx,%eax
  80adce:	50                   	push   %eax
  80adcf:	ff 77 04             	pushl  0x4(%edi)
  80add2:	e8 b5 44 00 00       	call   80f28c <memcpy>
	copied += bytes;
  80add7:	01 f3                	add    %esi,%ebx
    for (q = p; q != NULL; q = q->next) {
  80add9:	8b 3f                	mov    (%edi),%edi
  80addb:	83 c4 10             	add    $0x10,%esp
  80adde:	85 ff                	test   %edi,%edi
  80ade0:	75 d5                	jne    80adb7 <jif_input+0x4f>
  80ade2:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80ade5:	83 ec 0c             	sub    $0xc,%esp
  80ade8:	8b 43 04             	mov    0x4(%ebx),%eax
  80adeb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80adef:	50                   	push   %eax
  80adf0:	e8 5e cb ff ff       	call   807953 <htons>
  80adf5:	83 c4 10             	add    $0x10,%esp
  80adf8:	66 3d 00 08          	cmp    $0x800,%ax
  80adfc:	74 14                	je     80ae12 <jif_input+0xaa>
  80adfe:	66 3d 06 08          	cmp    $0x806,%ax
  80ae02:	74 3d                	je     80ae41 <jif_input+0xd9>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80ae04:	83 ec 0c             	sub    $0xc,%esp
  80ae07:	53                   	push   %ebx
  80ae08:	e8 0e 9c ff ff       	call   804a1b <pbuf_free>
  80ae0d:	83 c4 10             	add    $0x10,%esp
  80ae10:	eb 27                	jmp    80ae39 <jif_input+0xd1>
	etharp_ip_input(netif, p);
  80ae12:	83 ec 08             	sub    $0x8,%esp
  80ae15:	53                   	push   %ebx
  80ae16:	ff 75 08             	pushl  0x8(%ebp)
  80ae19:	e8 37 ea ff ff       	call   809855 <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80ae1e:	83 c4 08             	add    $0x8,%esp
  80ae21:	6a f2                	push   $0xfffffff2
  80ae23:	53                   	push   %ebx
  80ae24:	e8 1f 9b ff ff       	call   804948 <pbuf_header>
	netif->input(p, netif);
  80ae29:	83 c4 08             	add    $0x8,%esp
  80ae2c:	ff 75 08             	pushl  0x8(%ebp)
  80ae2f:	53                   	push   %ebx
  80ae30:	8b 45 08             	mov    0x8(%ebp),%eax
  80ae33:	ff 50 10             	call   *0x10(%eax)
	break;
  80ae36:	83 c4 10             	add    $0x10,%esp
    }
}
  80ae39:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ae3c:	5b                   	pop    %ebx
  80ae3d:	5e                   	pop    %esi
  80ae3e:	5f                   	pop    %edi
  80ae3f:	5d                   	pop    %ebp
  80ae40:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80ae41:	83 ec 04             	sub    $0x4,%esp
  80ae44:	53                   	push   %ebx
  80ae45:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ae48:	ff 30                	pushl  (%eax)
  80ae4a:	ff 75 08             	pushl  0x8(%ebp)
  80ae4d:	e8 53 ea ff ff       	call   8098a5 <etharp_arp_input>
	break;
  80ae52:	83 c4 10             	add    $0x10,%esp
  80ae55:	eb e2                	jmp    80ae39 <jif_input+0xd1>

0080ae57 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80ae57:	f3 0f 1e fb          	endbr32 
  80ae5b:	55                   	push   %ebp
  80ae5c:	89 e5                	mov    %esp,%ebp
  80ae5e:	57                   	push   %edi
  80ae5f:	56                   	push   %esi
  80ae60:	53                   	push   %ebx
  80ae61:	83 ec 28             	sub    $0x28,%esp
  80ae64:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80ae67:	6a 08                	push   $0x8
  80ae69:	e8 6f 95 ff ff       	call   8043dd <mem_malloc>

    if (jif == NULL) {
  80ae6e:	83 c4 10             	add    $0x10,%esp
  80ae71:	85 c0                	test   %eax,%eax
  80ae73:	0f 84 87 00 00 00    	je     80af00 <jif_init+0xa9>
  80ae79:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80ae7b:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80ae7e:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80ae81:	c7 43 14 4e ad 80 00 	movl   $0x80ad4e,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80ae88:	c7 43 18 80 ac 80 00 	movl   $0x80ac80,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80ae8f:	83 ec 04             	sub    $0x4,%esp
  80ae92:	6a 02                	push   $0x2
  80ae94:	68 c0 3c 81 00       	push   $0x813cc0
  80ae99:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80ae9c:	50                   	push   %eax
  80ae9d:	e8 ea 43 00 00       	call   80f28c <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80aea2:	8d 43 25             	lea    0x25(%ebx),%eax
  80aea5:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80aea7:	8b 07                	mov    (%edi),%eax
  80aea9:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80aeac:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80aeb0:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80aeb6:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[0] = 0x52;
  80aeba:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80aebe:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80aec2:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80aec6:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80aeca:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80aece:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80aed2:	c7 04 24 4b 13 81 00 	movl   $0x81134b,(%esp)
  80aed9:	e8 9e cc ff ff       	call   807b7c <inet_addr>
  80aede:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80aee1:	83 c4 0c             	add    $0xc,%esp
  80aee4:	6a 00                	push   $0x0
  80aee6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aee9:	50                   	push   %eax
  80aeea:	53                   	push   %ebx
  80aeeb:	e8 c9 ec ff ff       	call   809bb9 <etharp_query>

    return ERR_OK;
  80aef0:	83 c4 10             	add    $0x10,%esp
  80aef3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80aef8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aefb:	5b                   	pop    %ebx
  80aefc:	5e                   	pop    %esi
  80aefd:	5f                   	pop    %edi
  80aefe:	5d                   	pop    %ebp
  80aeff:	c3                   	ret    
	return ERR_MEM;
  80af00:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80af05:	eb f1                	jmp    80aef8 <jif_init+0xa1>

0080af07 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80af07:	f3 0f 1e fb          	endbr32 
  80af0b:	55                   	push   %ebp
  80af0c:	89 e5                	mov    %esp,%ebp
  80af0e:	56                   	push   %esi
  80af0f:	53                   	push   %ebx
  80af10:	83 ec 28             	sub    $0x28,%esp
  80af13:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80af16:	ff 75 10             	pushl  0x10(%ebp)
  80af19:	ff 75 08             	pushl  0x8(%ebp)
  80af1c:	e8 9b 0f 00 00       	call   80bebc <netconn_alloc>
  80af21:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80af23:	83 c4 10             	add    $0x10,%esp
  80af26:	85 c0                	test   %eax,%eax
  80af28:	74 63                	je     80af8d <netconn_new_with_proto_and_callback+0x86>
    msg.function = do_newconn;
  80af2a:	c7 45 e4 af bd 80 00 	movl   $0x80bdaf,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80af31:	89 f0                	mov    %esi,%eax
  80af33:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80af36:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80af39:	83 ec 0c             	sub    $0xc,%esp
  80af3c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af3f:	50                   	push   %eax
  80af40:	e8 b2 75 ff ff       	call   8024f7 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80af45:	83 c4 10             	add    $0x10,%esp
  80af48:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80af4c:	74 3f                	je     80af8d <netconn_new_with_proto_and_callback+0x86>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80af4e:	8b 73 08             	mov    0x8(%ebx),%esi
  80af51:	85 f6                	test   %esi,%esi
  80af53:	75 41                	jne    80af96 <netconn_new_with_proto_and_callback+0x8f>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80af55:	8b 43 10             	mov    0x10(%ebx),%eax
  80af58:	83 f8 ff             	cmp    $0xffffffff,%eax
  80af5b:	74 4d                	je     80afaa <netconn_new_with_proto_and_callback+0xa3>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80af5d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80af61:	74 5b                	je     80afbe <netconn_new_with_proto_and_callback+0xb7>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80af63:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80af67:	75 69                	jne    80afd2 <netconn_new_with_proto_and_callback+0xcb>
      sys_sem_free(conn->op_completed);
  80af69:	83 ec 0c             	sub    $0xc,%esp
  80af6c:	50                   	push   %eax
  80af6d:	e8 b3 f1 ff ff       	call   80a125 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80af72:	83 c4 04             	add    $0x4,%esp
  80af75:	ff 73 14             	pushl  0x14(%ebx)
  80af78:	e8 35 f2 ff ff       	call   80a1b2 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80af7d:	83 c4 08             	add    $0x8,%esp
  80af80:	53                   	push   %ebx
  80af81:	6a 07                	push   $0x7
  80af83:	e8 10 97 ff ff       	call   804698 <memp_free>
      return NULL;
  80af88:	83 c4 10             	add    $0x10,%esp
  80af8b:	89 f3                	mov    %esi,%ebx
    }
  }
  return conn;
}
  80af8d:	89 d8                	mov    %ebx,%eax
  80af8f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80af92:	5b                   	pop    %ebx
  80af93:	5e                   	pop    %esi
  80af94:	5d                   	pop    %ebp
  80af95:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80af96:	83 ec 04             	sub    $0x4,%esp
  80af99:	68 6c 2f 81 00       	push   $0x812f6c
  80af9e:	6a 52                	push   $0x52
  80afa0:	68 1e 30 81 00       	push   $0x81301e
  80afa5:	e8 8d 39 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80afaa:	83 ec 04             	sub    $0x4,%esp
  80afad:	68 35 30 81 00       	push   $0x813035
  80afb2:	6a 53                	push   $0x53
  80afb4:	68 1e 30 81 00       	push   $0x81301e
  80afb9:	e8 79 39 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80afbe:	83 ec 04             	sub    $0x4,%esp
  80afc1:	68 4e 30 81 00       	push   $0x81304e
  80afc6:	6a 54                	push   $0x54
  80afc8:	68 1e 30 81 00       	push   $0x81301e
  80afcd:	e8 65 39 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80afd2:	83 ec 04             	sub    $0x4,%esp
  80afd5:	68 90 2f 81 00       	push   $0x812f90
  80afda:	6a 55                	push   $0x55
  80afdc:	68 1e 30 81 00       	push   $0x81301e
  80afe1:	e8 51 39 00 00       	call   80e937 <_panic>

0080afe6 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80afe6:	f3 0f 1e fb          	endbr32 
  80afea:	55                   	push   %ebp
  80afeb:	89 e5                	mov    %esp,%ebp
  80afed:	53                   	push   %ebx
  80afee:	83 ec 24             	sub    $0x24,%esp
  80aff1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80aff4:	85 db                	test   %ebx,%ebx
  80aff6:	74 28                	je     80b020 <netconn_delete+0x3a>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80aff8:	c7 45 e4 07 c1 80 00 	movl   $0x80c107,-0x1c(%ebp)
  msg.msg.conn = conn;
  80afff:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b002:	83 ec 0c             	sub    $0xc,%esp
  80b005:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b008:	50                   	push   %eax
  80b009:	e8 e9 74 ff ff       	call   8024f7 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80b00e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80b015:	89 1c 24             	mov    %ebx,(%esp)
  80b018:	e8 51 0f 00 00       	call   80bf6e <netconn_free>

  return ERR_OK;
  80b01d:	83 c4 10             	add    $0x10,%esp
}
  80b020:	b8 00 00 00 00       	mov    $0x0,%eax
  80b025:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b028:	c9                   	leave  
  80b029:	c3                   	ret    

0080b02a <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80b02a:	f3 0f 1e fb          	endbr32 
  80b02e:	55                   	push   %ebp
  80b02f:	89 e5                	mov    %esp,%ebp
  80b031:	83 ec 08             	sub    $0x8,%esp
  80b034:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b037:	85 c0                	test   %eax,%eax
  80b039:	74 04                	je     80b03f <netconn_type+0x15>
  80b03b:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80b03d:	c9                   	leave  
  80b03e:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b03f:	83 ec 04             	sub    $0x4,%esp
  80b042:	68 63 30 81 00       	push   $0x813063
  80b047:	68 84 00 00 00       	push   $0x84
  80b04c:	68 1e 30 81 00       	push   $0x81301e
  80b051:	e8 e1 38 00 00       	call   80e937 <_panic>

0080b056 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80b056:	f3 0f 1e fb          	endbr32 
  80b05a:	55                   	push   %ebp
  80b05b:	89 e5                	mov    %esp,%ebp
  80b05d:	53                   	push   %ebx
  80b05e:	83 ec 24             	sub    $0x24,%esp
  80b061:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b064:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b067:	8b 45 10             	mov    0x10(%ebp),%eax
  80b06a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b06d:	85 db                	test   %ebx,%ebx
  80b06f:	74 30                	je     80b0a1 <netconn_getaddr+0x4b>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b071:	85 d2                	test   %edx,%edx
  80b073:	74 43                	je     80b0b8 <netconn_getaddr+0x62>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b075:	85 c0                	test   %eax,%eax
  80b077:	74 56                	je     80b0cf <netconn_getaddr+0x79>

  msg.function = do_getaddr;
  80b079:	c7 45 e4 76 c5 80 00 	movl   $0x80c576,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b080:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80b083:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80b086:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80b089:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80b08c:	83 ec 0c             	sub    $0xc,%esp
  80b08f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b092:	50                   	push   %eax
  80b093:	e8 5f 74 ff ff       	call   8024f7 <tcpip_apimsg>

  return conn->err;
  80b098:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b09c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b09f:	c9                   	leave  
  80b0a0:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b0a1:	83 ec 04             	sub    $0x4,%esp
  80b0a4:	68 7e 30 81 00       	push   $0x81307e
  80b0a9:	68 98 00 00 00       	push   $0x98
  80b0ae:	68 1e 30 81 00       	push   $0x81301e
  80b0b3:	e8 7f 38 00 00       	call   80e937 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b0b8:	83 ec 04             	sub    $0x4,%esp
  80b0bb:	68 9c 30 81 00       	push   $0x81309c
  80b0c0:	68 99 00 00 00       	push   $0x99
  80b0c5:	68 1e 30 81 00       	push   $0x81301e
  80b0ca:	e8 68 38 00 00       	call   80e937 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b0cf:	83 ec 04             	sub    $0x4,%esp
  80b0d2:	68 ba 30 81 00       	push   $0x8130ba
  80b0d7:	68 9a 00 00 00       	push   $0x9a
  80b0dc:	68 1e 30 81 00       	push   $0x81301e
  80b0e1:	e8 51 38 00 00       	call   80e937 <_panic>

0080b0e6 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b0e6:	f3 0f 1e fb          	endbr32 
  80b0ea:	55                   	push   %ebp
  80b0eb:	89 e5                	mov    %esp,%ebp
  80b0ed:	53                   	push   %ebx
  80b0ee:	83 ec 24             	sub    $0x24,%esp
  80b0f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b0f4:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b0f7:	85 db                	test   %ebx,%ebx
  80b0f9:	74 29                	je     80b124 <netconn_bind+0x3e>

  msg.function = do_bind;
  80b0fb:	c7 45 e4 b4 c1 80 00 	movl   $0x80c1b4,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b102:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b105:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b108:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b10b:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80b10f:	83 ec 0c             	sub    $0xc,%esp
  80b112:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b115:	50                   	push   %eax
  80b116:	e8 dc 73 ff ff       	call   8024f7 <tcpip_apimsg>
  return conn->err;
  80b11b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b11f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b122:	c9                   	leave  
  80b123:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b124:	83 ec 04             	sub    $0x4,%esp
  80b127:	68 d8 30 81 00       	push   $0x8130d8
  80b12c:	68 b5 00 00 00       	push   $0xb5
  80b131:	68 1e 30 81 00       	push   $0x81301e
  80b136:	e8 fc 37 00 00       	call   80e937 <_panic>

0080b13b <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b13b:	f3 0f 1e fb          	endbr32 
  80b13f:	55                   	push   %ebp
  80b140:	89 e5                	mov    %esp,%ebp
  80b142:	53                   	push   %ebx
  80b143:	83 ec 24             	sub    $0x24,%esp
  80b146:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b149:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b14c:	85 db                	test   %ebx,%ebx
  80b14e:	74 29                	je     80b179 <netconn_connect+0x3e>

  msg.function = do_connect;
  80b150:	c7 45 e4 48 c2 80 00 	movl   $0x80c248,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b157:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b15a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b15d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b160:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80b164:	83 ec 0c             	sub    $0xc,%esp
  80b167:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b16a:	50                   	push   %eax
  80b16b:	e8 87 73 ff ff       	call   8024f7 <tcpip_apimsg>
  return conn->err;
  80b170:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b174:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b177:	c9                   	leave  
  80b178:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b179:	83 ec 04             	sub    $0x4,%esp
  80b17c:	68 f3 30 81 00       	push   $0x8130f3
  80b181:	68 cc 00 00 00       	push   $0xcc
  80b186:	68 1e 30 81 00       	push   $0x81301e
  80b18b:	e8 a7 37 00 00       	call   80e937 <_panic>

0080b190 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b190:	f3 0f 1e fb          	endbr32 
  80b194:	55                   	push   %ebp
  80b195:	89 e5                	mov    %esp,%ebp
  80b197:	53                   	push   %ebx
  80b198:	83 ec 24             	sub    $0x24,%esp
  80b19b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b19e:	85 db                	test   %ebx,%ebx
  80b1a0:	74 1f                	je     80b1c1 <netconn_disconnect+0x31>

  msg.function = do_disconnect;
  80b1a2:	c7 45 e4 01 c3 80 00 	movl   $0x80c301,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b1a9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b1ac:	83 ec 0c             	sub    $0xc,%esp
  80b1af:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b1b2:	50                   	push   %eax
  80b1b3:	e8 3f 73 ff ff       	call   8024f7 <tcpip_apimsg>
  return conn->err;
  80b1b8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b1bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b1bf:	c9                   	leave  
  80b1c0:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b1c1:	83 ec 04             	sub    $0x4,%esp
  80b1c4:	68 b4 2f 81 00       	push   $0x812fb4
  80b1c9:	68 e2 00 00 00       	push   $0xe2
  80b1ce:	68 1e 30 81 00       	push   $0x81301e
  80b1d3:	e8 5f 37 00 00       	call   80e937 <_panic>

0080b1d8 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b1d8:	f3 0f 1e fb          	endbr32 
  80b1dc:	55                   	push   %ebp
  80b1dd:	89 e5                	mov    %esp,%ebp
  80b1df:	53                   	push   %ebx
  80b1e0:	83 ec 24             	sub    $0x24,%esp
  80b1e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b1e6:	85 db                	test   %ebx,%ebx
  80b1e8:	74 1f                	je     80b209 <netconn_listen_with_backlog+0x31>

  msg.function = do_listen;
  80b1ea:	c7 45 e4 42 c3 80 00 	movl   $0x80c342,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b1f1:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b1f4:	83 ec 0c             	sub    $0xc,%esp
  80b1f7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b1fa:	50                   	push   %eax
  80b1fb:	e8 f7 72 ff ff       	call   8024f7 <tcpip_apimsg>
  return conn->err;
  80b200:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b204:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b207:	c9                   	leave  
  80b208:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b209:	83 ec 04             	sub    $0x4,%esp
  80b20c:	68 11 31 81 00       	push   $0x813111
  80b211:	68 fa 00 00 00       	push   $0xfa
  80b216:	68 1e 30 81 00       	push   $0x81301e
  80b21b:	e8 17 37 00 00       	call   80e937 <_panic>

0080b220 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b220:	f3 0f 1e fb          	endbr32 
  80b224:	55                   	push   %ebp
  80b225:	89 e5                	mov    %esp,%ebp
  80b227:	53                   	push   %ebx
  80b228:	83 ec 14             	sub    $0x14,%esp
  80b22b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b22e:	85 db                	test   %ebx,%ebx
  80b230:	74 36                	je     80b268 <netconn_accept+0x48>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b232:	8b 43 18             	mov    0x18(%ebx),%eax
  80b235:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b238:	74 45                	je     80b27f <netconn_accept+0x5f>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b23a:	83 ec 04             	sub    $0x4,%esp
  80b23d:	6a 00                	push   $0x0
  80b23f:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b242:	52                   	push   %edx
  80b243:	50                   	push   %eax
  80b244:	e8 a9 f3 ff ff       	call   80a5f2 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b249:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b24c:	83 c4 10             	add    $0x10,%esp
  80b24f:	85 c0                	test   %eax,%eax
  80b251:	74 0d                	je     80b260 <netconn_accept+0x40>
  80b253:	83 ec 04             	sub    $0x4,%esp
  80b256:	6a 00                	push   $0x0
  80b258:	6a 01                	push   $0x1
  80b25a:	53                   	push   %ebx
  80b25b:	ff d0                	call   *%eax
  80b25d:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b260:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b263:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b266:	c9                   	leave  
  80b267:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b268:	83 ec 04             	sub    $0x4,%esp
  80b26b:	68 2e 31 81 00       	push   $0x81312e
  80b270:	68 10 01 00 00       	push   $0x110
  80b275:	68 1e 30 81 00       	push   $0x81301e
  80b27a:	e8 b8 36 00 00       	call   80e937 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b27f:	83 ec 04             	sub    $0x4,%esp
  80b282:	68 d8 2f 81 00       	push   $0x812fd8
  80b287:	68 11 01 00 00       	push   $0x111
  80b28c:	68 1e 30 81 00       	push   $0x81301e
  80b291:	e8 a1 36 00 00       	call   80e937 <_panic>

0080b296 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b296:	f3 0f 1e fb          	endbr32 
  80b29a:	55                   	push   %ebp
  80b29b:	89 e5                	mov    %esp,%ebp
  80b29d:	53                   	push   %ebx
  80b29e:	83 ec 24             	sub    $0x24,%esp
  80b2a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b2a4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b2ab:	85 db                	test   %ebx,%ebx
  80b2ad:	0f 84 cc 00 00 00    	je     80b37f <netconn_recv+0xe9>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b2b3:	8b 43 14             	mov    0x14(%ebx),%eax
  80b2b6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b2b9:	0f 84 d7 00 00 00    	je     80b396 <netconn_recv+0x100>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b2bf:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b2c3:	0f 8c 27 01 00 00    	jl     80b3f0 <netconn_recv+0x15a>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b2c9:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b2cc:	0f 85 e0 00 00 00    	jne    80b3b2 <netconn_recv+0x11c>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b2d2:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b2d6:	0f 84 c5 00 00 00    	je     80b3a1 <netconn_recv+0x10b>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b2dc:	83 ec 0c             	sub    $0xc,%esp
  80b2df:	6a 06                	push   $0x6
  80b2e1:	e8 58 93 ff ff       	call   80463e <memp_malloc>
  80b2e6:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b2e9:	83 c4 10             	add    $0x10,%esp
  80b2ec:	85 c0                	test   %eax,%eax
  80b2ee:	0f 84 b8 00 00 00    	je     80b3ac <netconn_recv+0x116>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b2f4:	83 ec 04             	sub    $0x4,%esp
  80b2f7:	6a 00                	push   $0x0
  80b2f9:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b2fc:	50                   	push   %eax
  80b2fd:	ff 73 14             	pushl  0x14(%ebx)
  80b300:	e8 ed f2 ff ff       	call   80a5f2 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b305:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b308:	83 c4 10             	add    $0x10,%esp
  80b30b:	85 c0                	test   %eax,%eax
  80b30d:	0f 84 e4 00 00 00    	je     80b3f7 <netconn_recv+0x161>
      len = p->tot_len;
  80b313:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b317:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b31b:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b31e:	85 c9                	test   %ecx,%ecx
  80b320:	74 1a                	je     80b33c <netconn_recv+0xa6>
  80b322:	83 ec 04             	sub    $0x4,%esp
  80b325:	0f b7 d2             	movzwl %dx,%edx
  80b328:	52                   	push   %edx
  80b329:	6a 01                	push   $0x1
  80b32b:	53                   	push   %ebx
  80b32c:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b32e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b331:	83 c4 10             	add    $0x10,%esp
  80b334:	85 c0                	test   %eax,%eax
  80b336:	0f 84 cb 00 00 00    	je     80b407 <netconn_recv+0x171>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80b33c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b33f:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80b341:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b344:	89 42 04             	mov    %eax,0x4(%edx)
    buf->port = 0;
  80b347:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
    buf->addr = NULL;
  80b34d:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80b354:	c7 45 e4 d8 c4 80 00 	movl   $0x80c4d8,-0x1c(%ebp)
    msg.msg.conn = conn;
  80b35b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
      msg.msg.msg.r.len = buf->p->tot_len;
  80b35e:	8b 02                	mov    (%edx),%eax
  80b360:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b364:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80b368:	83 ec 0c             	sub    $0xc,%esp
  80b36b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b36e:	50                   	push   %eax
  80b36f:	e8 83 71 ff ff       	call   8024f7 <tcpip_apimsg>
  80b374:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b377:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80b37a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b37d:	c9                   	leave  
  80b37e:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b37f:	83 ec 04             	sub    $0x4,%esp
  80b382:	68 4b 31 81 00       	push   $0x81314b
  80b387:	68 3a 01 00 00       	push   $0x13a
  80b38c:	68 1e 30 81 00       	push   $0x81301e
  80b391:	e8 a1 35 00 00       	call   80e937 <_panic>
    conn->err = ERR_CONN;
  80b396:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b39a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b39f:	eb d9                	jmp    80b37a <netconn_recv+0xe4>
      conn->err = ERR_CONN;
  80b3a1:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b3a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3aa:	eb ce                	jmp    80b37a <netconn_recv+0xe4>
      conn->err = ERR_MEM;
  80b3ac:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b3b0:	eb c8                	jmp    80b37a <netconn_recv+0xe4>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b3b2:	83 ec 04             	sub    $0x4,%esp
  80b3b5:	6a 00                	push   $0x0
  80b3b7:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b3ba:	52                   	push   %edx
  80b3bb:	50                   	push   %eax
  80b3bc:	e8 31 f2 ff ff       	call   80a5f2 <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b3c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b3c4:	83 c4 10             	add    $0x10,%esp
  80b3c7:	85 c0                	test   %eax,%eax
  80b3c9:	74 ac                	je     80b377 <netconn_recv+0xe1>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b3cb:	8b 10                	mov    (%eax),%edx
  80b3cd:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b3d1:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b3d5:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b3d8:	85 d2                	test   %edx,%edx
  80b3da:	74 9b                	je     80b377 <netconn_recv+0xe1>
  80b3dc:	83 ec 04             	sub    $0x4,%esp
  80b3df:	8b 00                	mov    (%eax),%eax
  80b3e1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b3e5:	50                   	push   %eax
  80b3e6:	6a 01                	push   $0x1
  80b3e8:	53                   	push   %ebx
  80b3e9:	ff d2                	call   *%edx
  80b3eb:	83 c4 10             	add    $0x10,%esp
  80b3ee:	eb 87                	jmp    80b377 <netconn_recv+0xe1>
    return NULL;
  80b3f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3f5:	eb 83                	jmp    80b37a <netconn_recv+0xe4>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b3f7:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
      len = 0;
  80b3fa:	ba 00 00 00 00       	mov    $0x0,%edx
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b3ff:	85 c9                	test   %ecx,%ecx
  80b401:	0f 85 1b ff ff ff    	jne    80b322 <netconn_recv+0x8c>
      memp_free(MEMP_NETBUF, buf);
  80b407:	83 ec 08             	sub    $0x8,%esp
  80b40a:	ff 75 e0             	pushl  -0x20(%ebp)
  80b40d:	6a 06                	push   $0x6
  80b40f:	e8 84 92 ff ff       	call   804698 <memp_free>
      if (conn->err == ERR_OK) {
  80b414:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b417:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b41c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b420:	0f 85 54 ff ff ff    	jne    80b37a <netconn_recv+0xe4>
        conn->err = ERR_CLSD;
  80b426:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b42a:	e9 4b ff ff ff       	jmp    80b37a <netconn_recv+0xe4>

0080b42f <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b42f:	f3 0f 1e fb          	endbr32 
  80b433:	55                   	push   %ebp
  80b434:	89 e5                	mov    %esp,%ebp
  80b436:	53                   	push   %ebx
  80b437:	83 ec 24             	sub    $0x24,%esp
  80b43a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b43d:	85 db                	test   %ebx,%ebx
  80b43f:	74 25                	je     80b466 <netconn_send+0x37>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b441:	c7 45 e4 2e c4 80 00 	movl   $0x80c42e,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b448:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b44b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b44e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b451:	83 ec 0c             	sub    $0xc,%esp
  80b454:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b457:	50                   	push   %eax
  80b458:	e8 9a 70 ff ff       	call   8024f7 <tcpip_apimsg>
  return conn->err;
  80b45d:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b461:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b464:	c9                   	leave  
  80b465:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b466:	83 ec 04             	sub    $0x4,%esp
  80b469:	68 66 31 81 00       	push   $0x813166
  80b46e:	68 b9 01 00 00       	push   $0x1b9
  80b473:	68 1e 30 81 00       	push   $0x81301e
  80b478:	e8 ba 34 00 00       	call   80e937 <_panic>

0080b47d <netconn_sendto>:
{
  80b47d:	f3 0f 1e fb          	endbr32 
  80b481:	55                   	push   %ebp
  80b482:	89 e5                	mov    %esp,%ebp
  80b484:	83 ec 08             	sub    $0x8,%esp
  80b487:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b48a:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b48d:	85 c0                	test   %eax,%eax
  80b48f:	74 1b                	je     80b4ac <netconn_sendto+0x2f>
    buf->addr = addr;
  80b491:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b494:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b497:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b49b:	83 ec 08             	sub    $0x8,%esp
  80b49e:	50                   	push   %eax
  80b49f:	ff 75 08             	pushl  0x8(%ebp)
  80b4a2:	e8 88 ff ff ff       	call   80b42f <netconn_send>
  80b4a7:	83 c4 10             	add    $0x10,%esp
}
  80b4aa:	c9                   	leave  
  80b4ab:	c3                   	ret    
  return ERR_VAL;
  80b4ac:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b4b1:	eb f7                	jmp    80b4aa <netconn_sendto+0x2d>

0080b4b3 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b4b3:	f3 0f 1e fb          	endbr32 
  80b4b7:	55                   	push   %ebp
  80b4b8:	89 e5                	mov    %esp,%ebp
  80b4ba:	53                   	push   %ebx
  80b4bb:	83 ec 24             	sub    $0x24,%esp
  80b4be:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b4c1:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b4c4:	85 db                	test   %ebx,%ebx
  80b4c6:	74 33                	je     80b4fb <netconn_write+0x48>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b4c8:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b4cb:	75 45                	jne    80b512 <netconn_write+0x5f>

  msg.function = do_write;
  80b4cd:	c7 45 e4 22 c5 80 00 	movl   $0x80c522,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b4d4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b4d7:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b4da:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b4dd:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b4e0:	8b 45 10             	mov    0x10(%ebp),%eax
  80b4e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b4e6:	83 ec 0c             	sub    $0xc,%esp
  80b4e9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b4ec:	50                   	push   %eax
  80b4ed:	e8 05 70 ff ff       	call   8024f7 <tcpip_apimsg>
  return conn->err;
  80b4f2:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b4f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4f9:	c9                   	leave  
  80b4fa:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b4fb:	83 ec 04             	sub    $0x4,%esp
  80b4fe:	68 81 31 81 00       	push   $0x813181
  80b503:	68 d3 01 00 00       	push   $0x1d3
  80b508:	68 1e 30 81 00       	push   $0x81301e
  80b50d:	e8 25 34 00 00       	call   80e937 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b512:	83 ec 04             	sub    $0x4,%esp
  80b515:	68 fc 2f 81 00       	push   $0x812ffc
  80b51a:	68 d4 01 00 00       	push   $0x1d4
  80b51f:	68 1e 30 81 00       	push   $0x81301e
  80b524:	e8 0e 34 00 00       	call   80e937 <_panic>

0080b529 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b529:	f3 0f 1e fb          	endbr32 
  80b52d:	55                   	push   %ebp
  80b52e:	89 e5                	mov    %esp,%ebp
  80b530:	53                   	push   %ebx
  80b531:	83 ec 24             	sub    $0x24,%esp
  80b534:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b537:	85 db                	test   %ebx,%ebx
  80b539:	74 1f                	je     80b55a <netconn_close+0x31>

  msg.function = do_close;
  80b53b:	c7 45 e4 41 c6 80 00 	movl   $0x80c641,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b542:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b545:	83 ec 0c             	sub    $0xc,%esp
  80b548:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b54b:	50                   	push   %eax
  80b54c:	e8 a6 6f ff ff       	call   8024f7 <tcpip_apimsg>
  return conn->err;
  80b551:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b555:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b558:	c9                   	leave  
  80b559:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b55a:	83 ec 04             	sub    $0x4,%esp
  80b55d:	68 9d 31 81 00       	push   $0x81319d
  80b562:	68 ed 01 00 00       	push   $0x1ed
  80b567:	68 1e 30 81 00       	push   $0x81301e
  80b56c:	e8 c6 33 00 00       	call   80e937 <_panic>

0080b571 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b571:	f3 0f 1e fb          	endbr32 
  80b575:	55                   	push   %ebp
  80b576:	89 e5                	mov    %esp,%ebp
  80b578:	56                   	push   %esi
  80b579:	53                   	push   %ebx
  80b57a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b57d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b580:	8b 75 10             	mov    0x10(%ebp),%esi
  80b583:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b586:	85 c0                	test   %eax,%eax
  80b588:	74 5a                	je     80b5e4 <recv_tcp+0x73>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b58a:	85 db                	test   %ebx,%ebx
  80b58c:	74 6d                	je     80b5fb <recv_tcp+0x8a>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b58e:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b591:	75 7f                	jne    80b612 <recv_tcp+0xa1>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b593:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b597:	0f 84 8c 00 00 00    	je     80b629 <recv_tcp+0xb8>
    return ERR_VAL;
  }

  conn->err = err;
  80b59d:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b5a0:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b5a5:	85 f6                	test   %esi,%esi
  80b5a7:	74 08                	je     80b5b1 <recv_tcp+0x40>
    len = p->tot_len;
  80b5a9:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b5ad:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b5b1:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b5b4:	85 d2                	test   %edx,%edx
  80b5b6:	74 0f                	je     80b5c7 <recv_tcp+0x56>
  80b5b8:	83 ec 04             	sub    $0x4,%esp
  80b5bb:	0f b7 c0             	movzwl %ax,%eax
  80b5be:	50                   	push   %eax
  80b5bf:	6a 00                	push   $0x0
  80b5c1:	53                   	push   %ebx
  80b5c2:	ff d2                	call   *%edx
  80b5c4:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b5c7:	83 ec 08             	sub    $0x8,%esp
  80b5ca:	56                   	push   %esi
  80b5cb:	ff 73 14             	pushl  0x14(%ebx)
  80b5ce:	e8 22 ef ff ff       	call   80a4f5 <sys_mbox_trypost>
  80b5d3:	83 c4 10             	add    $0x10,%esp
  80b5d6:	84 c0                	test   %al,%al
  80b5d8:	0f 95 c0             	setne  %al
  80b5db:	f7 d8                	neg    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b5dd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b5e0:	5b                   	pop    %ebx
  80b5e1:	5e                   	pop    %esi
  80b5e2:	5d                   	pop    %ebp
  80b5e3:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b5e4:	83 ec 04             	sub    $0x4,%esp
  80b5e7:	68 bc 31 81 00       	push   $0x8131bc
  80b5ec:	68 c1 00 00 00       	push   $0xc1
  80b5f1:	68 06 33 81 00       	push   $0x813306
  80b5f6:	e8 3c 33 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b5fb:	83 ec 04             	sub    $0x4,%esp
  80b5fe:	68 e0 31 81 00       	push   $0x8131e0
  80b603:	68 c2 00 00 00       	push   $0xc2
  80b608:	68 06 33 81 00       	push   $0x813306
  80b60d:	e8 25 33 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b612:	83 ec 04             	sub    $0x4,%esp
  80b615:	68 1d 33 81 00       	push   $0x81331d
  80b61a:	68 c4 00 00 00       	push   $0xc4
  80b61f:	68 06 33 81 00       	push   $0x813306
  80b624:	e8 0e 33 00 00       	call   80e937 <_panic>
    return ERR_VAL;
  80b629:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b62e:	eb ad                	jmp    80b5dd <recv_tcp+0x6c>

0080b630 <recv_udp>:
{
  80b630:	f3 0f 1e fb          	endbr32 
  80b634:	55                   	push   %ebp
  80b635:	89 e5                	mov    %esp,%ebp
  80b637:	57                   	push   %edi
  80b638:	56                   	push   %esi
  80b639:	53                   	push   %ebx
  80b63a:	83 ec 1c             	sub    $0x1c,%esp
  80b63d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b640:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b643:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b646:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b649:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b64c:	85 c0                	test   %eax,%eax
  80b64e:	74 7f                	je     80b6cf <recv_udp+0x9f>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b650:	85 db                	test   %ebx,%ebx
  80b652:	0f 84 8e 00 00 00    	je     80b6e6 <recv_udp+0xb6>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b658:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b65b:	0f 85 9c 00 00 00    	jne    80b6fd <recv_udp+0xcd>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b661:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b665:	0f 84 a9 00 00 00    	je     80b714 <recv_udp+0xe4>
  buf = memp_malloc(MEMP_NETBUF);
  80b66b:	83 ec 0c             	sub    $0xc,%esp
  80b66e:	6a 06                	push   $0x6
  80b670:	e8 c9 8f ff ff       	call   80463e <memp_malloc>
  80b675:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b677:	83 c4 10             	add    $0x10,%esp
  80b67a:	85 c0                	test   %eax,%eax
  80b67c:	0f 84 a0 00 00 00    	je     80b722 <recv_udp+0xf2>
    buf->p = p;
  80b682:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b684:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b687:	8b 45 14             	mov    0x14(%ebp),%eax
  80b68a:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b68d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b691:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b695:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b699:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b69d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b6a0:	85 c0                	test   %eax,%eax
  80b6a2:	74 10                	je     80b6b4 <recv_udp+0x84>
  80b6a4:	83 ec 04             	sub    $0x4,%esp
  80b6a7:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b6ab:	52                   	push   %edx
  80b6ac:	6a 00                	push   $0x0
  80b6ae:	53                   	push   %ebx
  80b6af:	ff d0                	call   *%eax
  80b6b1:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b6b4:	83 ec 08             	sub    $0x8,%esp
  80b6b7:	56                   	push   %esi
  80b6b8:	ff 73 14             	pushl  0x14(%ebx)
  80b6bb:	e8 35 ee ff ff       	call   80a4f5 <sys_mbox_trypost>
  80b6c0:	83 c4 10             	add    $0x10,%esp
  80b6c3:	84 c0                	test   %al,%al
  80b6c5:	75 69                	jne    80b730 <recv_udp+0x100>
}
  80b6c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b6ca:	5b                   	pop    %ebx
  80b6cb:	5e                   	pop    %esi
  80b6cc:	5f                   	pop    %edi
  80b6cd:	5d                   	pop    %ebp
  80b6ce:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b6cf:	83 ec 04             	sub    $0x4,%esp
  80b6d2:	68 00 32 81 00       	push   $0x813200
  80b6d7:	68 8e 00 00 00       	push   $0x8e
  80b6dc:	68 06 33 81 00       	push   $0x813306
  80b6e1:	e8 51 32 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b6e6:	83 ec 04             	sub    $0x4,%esp
  80b6e9:	68 24 32 81 00       	push   $0x813224
  80b6ee:	68 8f 00 00 00       	push   $0x8f
  80b6f3:	68 06 33 81 00       	push   $0x813306
  80b6f8:	e8 3a 32 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b6fd:	83 ec 04             	sub    $0x4,%esp
  80b700:	68 3b 33 81 00       	push   $0x81333b
  80b705:	68 91 00 00 00       	push   $0x91
  80b70a:	68 06 33 81 00       	push   $0x813306
  80b70f:	e8 23 32 00 00       	call   80e937 <_panic>
    pbuf_free(p);
  80b714:	83 ec 0c             	sub    $0xc,%esp
  80b717:	57                   	push   %edi
  80b718:	e8 fe 92 ff ff       	call   804a1b <pbuf_free>
    return;
  80b71d:	83 c4 10             	add    $0x10,%esp
  80b720:	eb a5                	jmp    80b6c7 <recv_udp+0x97>
    pbuf_free(p);
  80b722:	83 ec 0c             	sub    $0xc,%esp
  80b725:	57                   	push   %edi
  80b726:	e8 f0 92 ff ff       	call   804a1b <pbuf_free>
    return;
  80b72b:	83 c4 10             	add    $0x10,%esp
  80b72e:	eb 97                	jmp    80b6c7 <recv_udp+0x97>
    netbuf_delete(buf);
  80b730:	83 ec 0c             	sub    $0xc,%esp
  80b733:	56                   	push   %esi
  80b734:	e8 c2 6e ff ff       	call   8025fb <netbuf_delete>
    return;
  80b739:	83 c4 10             	add    $0x10,%esp
  80b73c:	eb 89                	jmp    80b6c7 <recv_udp+0x97>

0080b73e <recv_raw>:
{
  80b73e:	f3 0f 1e fb          	endbr32 
  80b742:	55                   	push   %ebp
  80b743:	89 e5                	mov    %esp,%ebp
  80b745:	57                   	push   %edi
  80b746:	56                   	push   %esi
  80b747:	53                   	push   %ebx
  80b748:	83 ec 0c             	sub    $0xc,%esp
  80b74b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b74e:	85 db                	test   %ebx,%ebx
  80b750:	74 06                	je     80b758 <recv_raw+0x1a>
  80b752:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b756:	75 0d                	jne    80b765 <recv_raw+0x27>
}
  80b758:	b8 00 00 00 00       	mov    $0x0,%eax
  80b75d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b760:	5b                   	pop    %ebx
  80b761:	5e                   	pop    %esi
  80b762:	5f                   	pop    %edi
  80b763:	5d                   	pop    %ebp
  80b764:	c3                   	ret    
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b765:	83 ec 04             	sub    $0x4,%esp
  80b768:	6a 00                	push   $0x0
  80b76a:	8b 45 10             	mov    0x10(%ebp),%eax
  80b76d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b771:	50                   	push   %eax
  80b772:	6a 03                	push   $0x3
  80b774:	e8 6c 93 ff ff       	call   804ae5 <pbuf_alloc>
  80b779:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b77b:	83 c4 10             	add    $0x10,%esp
  80b77e:	85 c0                	test   %eax,%eax
  80b780:	74 d6                	je     80b758 <recv_raw+0x1a>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b782:	83 ec 08             	sub    $0x8,%esp
  80b785:	ff 75 10             	pushl  0x10(%ebp)
  80b788:	50                   	push   %eax
  80b789:	e8 3e 98 ff ff       	call   804fcc <pbuf_copy>
  80b78e:	83 c4 10             	add    $0x10,%esp
  80b791:	84 c0                	test   %al,%al
  80b793:	75 73                	jne    80b808 <recv_raw+0xca>
      buf = memp_malloc(MEMP_NETBUF);
  80b795:	83 ec 0c             	sub    $0xc,%esp
  80b798:	6a 06                	push   $0x6
  80b79a:	e8 9f 8e ff ff       	call   80463e <memp_malloc>
  80b79f:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b7a1:	83 c4 10             	add    $0x10,%esp
  80b7a4:	85 c0                	test   %eax,%eax
  80b7a6:	74 71                	je     80b819 <recv_raw+0xdb>
      buf->p = q;
  80b7a8:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b7aa:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b7ad:	8b 46 04             	mov    0x4(%esi),%eax
  80b7b0:	83 c0 0c             	add    $0xc,%eax
  80b7b3:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b7b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b7b9:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b7bd:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b7c1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b7c5:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b7c9:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7cc:	85 c0                	test   %eax,%eax
  80b7ce:	74 10                	je     80b7e0 <recv_raw+0xa2>
  80b7d0:	83 ec 04             	sub    $0x4,%esp
  80b7d3:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b7d7:	52                   	push   %edx
  80b7d8:	6a 00                	push   $0x0
  80b7da:	53                   	push   %ebx
  80b7db:	ff d0                	call   *%eax
  80b7dd:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b7e0:	83 ec 08             	sub    $0x8,%esp
  80b7e3:	57                   	push   %edi
  80b7e4:	ff 73 14             	pushl  0x14(%ebx)
  80b7e7:	e8 09 ed ff ff       	call   80a4f5 <sys_mbox_trypost>
  80b7ec:	83 c4 10             	add    $0x10,%esp
  80b7ef:	84 c0                	test   %al,%al
  80b7f1:	0f 84 61 ff ff ff    	je     80b758 <recv_raw+0x1a>
        netbuf_delete(buf);
  80b7f7:	83 ec 0c             	sub    $0xc,%esp
  80b7fa:	57                   	push   %edi
  80b7fb:	e8 fb 6d ff ff       	call   8025fb <netbuf_delete>
  80b800:	83 c4 10             	add    $0x10,%esp
  80b803:	e9 50 ff ff ff       	jmp    80b758 <recv_raw+0x1a>
        pbuf_free(q);
  80b808:	83 ec 0c             	sub    $0xc,%esp
  80b80b:	56                   	push   %esi
  80b80c:	e8 0a 92 ff ff       	call   804a1b <pbuf_free>
  80b811:	83 c4 10             	add    $0x10,%esp
  80b814:	e9 3f ff ff ff       	jmp    80b758 <recv_raw+0x1a>
        pbuf_free(q);
  80b819:	83 ec 0c             	sub    $0xc,%esp
  80b81c:	56                   	push   %esi
  80b81d:	e8 f9 91 ff ff       	call   804a1b <pbuf_free>
        return 0;
  80b822:	83 c4 10             	add    $0x10,%esp
  80b825:	e9 2e ff ff ff       	jmp    80b758 <recv_raw+0x1a>

0080b82a <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b82a:	55                   	push   %ebp
  80b82b:	89 e5                	mov    %esp,%ebp
  80b82d:	53                   	push   %ebx
  80b82e:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b831:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b834:	50                   	push   %eax
  80b835:	53                   	push   %ebx
  80b836:	e8 f9 a1 ff ff       	call   805a34 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b83b:	83 c4 08             	add    $0x8,%esp
  80b83e:	68 71 b5 80 00       	push   $0x80b571
  80b843:	53                   	push   %ebx
  80b844:	e8 fd a1 ff ff       	call   805a46 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b849:	83 c4 08             	add    $0x8,%esp
  80b84c:	68 18 bd 80 00       	push   $0x80bd18
  80b851:	53                   	push   %ebx
  80b852:	e8 04 a2 ff ff       	call   805a5b <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b857:	83 c4 0c             	add    $0xc,%esp
  80b85a:	6a 04                	push   $0x4
  80b85c:	68 ce bc 80 00       	push   $0x80bcce
  80b861:	53                   	push   %ebx
  80b862:	e8 30 a2 ff ff       	call   805a97 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b867:	83 c4 08             	add    $0x8,%esp
  80b86a:	68 cd b8 80 00       	push   $0x80b8cd
  80b86f:	53                   	push   %ebx
  80b870:	e8 fb a1 ff ff       	call   805a70 <tcp_err>
}
  80b875:	83 c4 10             	add    $0x10,%esp
  80b878:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b87b:	c9                   	leave  
  80b87c:	c3                   	ret    

0080b87d <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b87d:	f3 0f 1e fb          	endbr32 
  80b881:	55                   	push   %ebp
  80b882:	89 e5                	mov    %esp,%ebp
  80b884:	53                   	push   %ebx
  80b885:	83 ec 04             	sub    $0x4,%esp
  80b888:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b88b:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b88e:	85 db                	test   %ebx,%ebx
  80b890:	74 34                	je     80b8c6 <do_connected+0x49>
    return ERR_VAL;
  }

  conn->err = err;
  80b892:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b895:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b898:	75 04                	jne    80b89e <do_connected+0x21>
  80b89a:	84 c0                	test   %al,%al
  80b89c:	74 1f                	je     80b8bd <do_connected+0x40>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b89e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b8a5:	83 ec 0c             	sub    $0xc,%esp
  80b8a8:	ff 73 10             	pushl  0x10(%ebx)
  80b8ab:	e8 bd ea ff ff       	call   80a36d <sys_sem_signal>
  return ERR_OK;
  80b8b0:	83 c4 10             	add    $0x10,%esp
  80b8b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b8b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b8bb:	c9                   	leave  
  80b8bc:	c3                   	ret    
    setup_tcp(conn);
  80b8bd:	89 d8                	mov    %ebx,%eax
  80b8bf:	e8 66 ff ff ff       	call   80b82a <setup_tcp>
  80b8c4:	eb d8                	jmp    80b89e <do_connected+0x21>
    return ERR_VAL;
  80b8c6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b8cb:	eb eb                	jmp    80b8b8 <do_connected+0x3b>

0080b8cd <err_tcp>:
{
  80b8cd:	f3 0f 1e fb          	endbr32 
  80b8d1:	55                   	push   %ebp
  80b8d2:	89 e5                	mov    %esp,%ebp
  80b8d4:	53                   	push   %ebx
  80b8d5:	83 ec 04             	sub    $0x4,%esp
  80b8d8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b8db:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b8de:	85 db                	test   %ebx,%ebx
  80b8e0:	74 7e                	je     80b960 <err_tcp+0x93>
  conn->pcb.tcp = NULL;
  80b8e2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b8e9:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b8ec:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b8f0:	74 24                	je     80b916 <err_tcp+0x49>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b8f2:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b8f5:	85 c0                	test   %eax,%eax
  80b8f7:	74 0d                	je     80b906 <err_tcp+0x39>
  80b8f9:	83 ec 04             	sub    $0x4,%esp
  80b8fc:	6a 00                	push   $0x0
  80b8fe:	6a 00                	push   $0x0
  80b900:	53                   	push   %ebx
  80b901:	ff d0                	call   *%eax
  80b903:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b906:	83 ec 08             	sub    $0x8,%esp
  80b909:	6a 00                	push   $0x0
  80b90b:	ff 73 14             	pushl  0x14(%ebx)
  80b90e:	e8 ab ec ff ff       	call   80a5be <sys_mbox_post>
  80b913:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b916:	8b 43 10             	mov    0x10(%ebx),%eax
  80b919:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b91c:	74 06                	je     80b924 <err_tcp+0x57>
  80b91e:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b922:	74 53                	je     80b977 <err_tcp+0xaa>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b924:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b928:	74 24                	je     80b94e <err_tcp+0x81>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b92a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b92d:	85 c0                	test   %eax,%eax
  80b92f:	74 0d                	je     80b93e <err_tcp+0x71>
  80b931:	83 ec 04             	sub    $0x4,%esp
  80b934:	6a 00                	push   $0x0
  80b936:	6a 00                	push   $0x0
  80b938:	53                   	push   %ebx
  80b939:	ff d0                	call   *%eax
  80b93b:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b93e:	83 ec 08             	sub    $0x8,%esp
  80b941:	6a 00                	push   $0x0
  80b943:	ff 73 18             	pushl  0x18(%ebx)
  80b946:	e8 73 ec ff ff       	call   80a5be <sys_mbox_post>
  80b94b:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b94e:	8b 43 04             	mov    0x4(%ebx),%eax
  80b951:	83 f8 01             	cmp    $0x1,%eax
  80b954:	74 36                	je     80b98c <err_tcp+0xbf>
  80b956:	83 f8 04             	cmp    $0x4,%eax
  80b959:	74 31                	je     80b98c <err_tcp+0xbf>
}
  80b95b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b95e:	c9                   	leave  
  80b95f:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b960:	83 ec 04             	sub    $0x4,%esp
  80b963:	68 59 33 81 00       	push   $0x813359
  80b968:	68 22 01 00 00       	push   $0x122
  80b96d:	68 06 33 81 00       	push   $0x813306
  80b972:	e8 c0 2f 00 00       	call   80e937 <_panic>
    conn->state = NETCONN_NONE;
  80b977:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b97e:	83 ec 0c             	sub    $0xc,%esp
  80b981:	50                   	push   %eax
  80b982:	e8 e6 e9 ff ff       	call   80a36d <sys_sem_signal>
  80b987:	83 c4 10             	add    $0x10,%esp
  80b98a:	eb 98                	jmp    80b924 <err_tcp+0x57>
    conn->state = NETCONN_NONE;
  80b98c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b993:	83 ec 0c             	sub    $0xc,%esp
  80b996:	ff 73 10             	pushl  0x10(%ebx)
  80b999:	e8 cf e9 ff ff       	call   80a36d <sys_sem_signal>
  80b99e:	83 c4 10             	add    $0x10,%esp
}
  80b9a1:	eb b8                	jmp    80b95b <err_tcp+0x8e>

0080b9a3 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b9a3:	55                   	push   %ebp
  80b9a4:	89 e5                	mov    %esp,%ebp
  80b9a6:	57                   	push   %edi
  80b9a7:	56                   	push   %esi
  80b9a8:	53                   	push   %ebx
  80b9a9:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b9ac:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b9b0:	0f 85 c9 00 00 00    	jne    80ba7f <do_writemore+0xdc>
  80b9b6:	89 c3                	mov    %eax,%ebx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b9b8:	8b 40 24             	mov    0x24(%eax),%eax
  80b9bb:	8b 7b 28             	mov    0x28(%ebx),%edi
  80b9be:	89 fa                	mov    %edi,%edx
  80b9c0:	03 50 04             	add    0x4(%eax),%edx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b9c3:	8b 70 08             	mov    0x8(%eax),%esi
  80b9c6:	89 f1                	mov    %esi,%ecx
  80b9c8:	29 f9                	sub    %edi,%ecx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b9ca:	29 fe                	sub    %edi,%esi
  80b9cc:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80b9d2:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80b9d7:	0f 4d f1             	cmovge %ecx,%esi
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b9da:	8b 4b 08             	mov    0x8(%ebx),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b9dd:	66 39 71 6e          	cmp    %si,0x6e(%ecx)
  80b9e1:	66 0f 46 71 6e       	cmovbe 0x6e(%ecx),%si
  80b9e6:	0f b7 f6             	movzwl %si,%esi
  80b9e9:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b9ed:	50                   	push   %eax
  80b9ee:	56                   	push   %esi
  80b9ef:	52                   	push   %edx
  80b9f0:	51                   	push   %ecx
  80b9f1:	e8 88 c8 ff ff       	call   80827e <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b9f6:	89 f2                	mov    %esi,%edx
  80b9f8:	03 53 28             	add    0x28(%ebx),%edx
  80b9fb:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80b9fe:	83 c4 10             	add    $0x10,%esp
  80ba01:	3b 51 08             	cmp    0x8(%ecx),%edx
  80ba04:	0f 8f 8c 00 00 00    	jg     80ba96 <do_writemore+0xf3>
  if (err == ERR_OK) {
  80ba0a:	84 c0                	test   %al,%al
  80ba0c:	0f 85 bf 00 00 00    	jne    80bad1 <do_writemore+0x12e>
    conn->write_offset += len;
  80ba12:	89 53 28             	mov    %edx,0x28(%ebx)
  u8_t write_finished = 0;
  80ba15:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80ba1a:	3b 51 08             	cmp    0x8(%ecx),%edx
  80ba1d:	0f 84 8a 00 00 00    	je     80baad <do_writemore+0x10a>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80ba23:	8b 43 08             	mov    0x8(%ebx),%eax
  80ba26:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80ba2a:	74 1a                	je     80ba46 <do_writemore+0xa3>
  80ba2c:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80ba30:	75 14                	jne    80ba46 <do_writemore+0xa3>
  80ba32:	8b 50 74             	mov    0x74(%eax),%edx
  80ba35:	85 d2                	test   %edx,%edx
  80ba37:	0f 84 88 00 00 00    	je     80bac5 <do_writemore+0x122>
  80ba3d:	83 3a 00             	cmpl   $0x0,(%edx)
  80ba40:	0f 84 85 00 00 00    	je     80bacb <do_writemore+0x128>
  80ba46:	83 ec 0c             	sub    $0xc,%esp
  80ba49:	50                   	push   %eax
  80ba4a:	e8 8a c8 ff ff       	call   8082d9 <tcp_output>
    conn->err = err;
  80ba4f:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80ba52:	83 c4 10             	add    $0x10,%esp
  80ba55:	84 c0                	test   %al,%al
  80ba57:	75 1e                	jne    80ba77 <do_writemore+0xd4>
  80ba59:	8b 43 08             	mov    0x8(%ebx),%eax
  80ba5c:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80ba62:	77 13                	ja     80ba77 <do_writemore+0xd4>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80ba64:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ba67:	85 c0                	test   %eax,%eax
  80ba69:	74 0c                	je     80ba77 <do_writemore+0xd4>
  80ba6b:	83 ec 04             	sub    $0x4,%esp
  80ba6e:	56                   	push   %esi
  80ba6f:	6a 03                	push   $0x3
  80ba71:	53                   	push   %ebx
  80ba72:	ff d0                	call   *%eax
  80ba74:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80ba77:	89 f8                	mov    %edi,%eax
  80ba79:	84 c0                	test   %al,%al
  80ba7b:	74 70                	je     80baed <do_writemore+0x14a>
  80ba7d:	eb 59                	jmp    80bad8 <do_writemore+0x135>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80ba7f:	83 ec 04             	sub    $0x4,%esp
  80ba82:	68 66 33 81 00       	push   $0x813366
  80ba87:	68 b8 03 00 00       	push   $0x3b8
  80ba8c:	68 06 33 81 00       	push   $0x813306
  80ba91:	e8 a1 2e 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80ba96:	83 ec 04             	sub    $0x4,%esp
  80ba99:	68 83 33 81 00       	push   $0x813383
  80ba9e:	68 cd 03 00 00       	push   $0x3cd
  80baa3:	68 06 33 81 00       	push   $0x813306
  80baa8:	e8 8a 2e 00 00       	call   80e937 <_panic>
      conn->write_msg = NULL;
  80baad:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80bab4:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
      write_finished = 1;
  80babb:	bf 01 00 00 00       	mov    $0x1,%edi
  80bac0:	e9 5e ff ff ff       	jmp    80ba23 <do_writemore+0x80>
    conn->err = err;
  80bac5:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80bac9:	eb 8e                	jmp    80ba59 <do_writemore+0xb6>
  80bacb:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80bacf:	eb 88                	jmp    80ba59 <do_writemore+0xb6>
  } else if (err == ERR_MEM) {
  80bad1:	3c ff                	cmp    $0xff,%al
  80bad3:	74 25                	je     80bafa <do_writemore+0x157>
    conn->err = err;
  80bad5:	88 43 0c             	mov    %al,0xc(%ebx)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80bad8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80badf:	83 ec 0c             	sub    $0xc,%esp
  80bae2:	ff 73 10             	pushl  0x10(%ebx)
  80bae5:	e8 83 e8 ff ff       	call   80a36d <sys_sem_signal>
  80baea:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80baed:	b8 00 00 00 00       	mov    $0x0,%eax
  80baf2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80baf5:	5b                   	pop    %ebx
  80baf6:	5e                   	pop    %esi
  80baf7:	5f                   	pop    %edi
  80baf8:	5d                   	pop    %ebp
  80baf9:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80bafa:	83 ec 0c             	sub    $0xc,%esp
  80bafd:	ff 73 08             	pushl  0x8(%ebx)
  80bb00:	e8 d4 c7 ff ff       	call   8082d9 <tcp_output>
  80bb05:	83 c4 10             	add    $0x10,%esp
  80bb08:	eb e3                	jmp    80baed <do_writemore+0x14a>

0080bb0a <do_close_internal>:
{
  80bb0a:	55                   	push   %ebp
  80bb0b:	89 e5                	mov    %esp,%ebp
  80bb0d:	53                   	push   %ebx
  80bb0e:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80bb11:	85 c0                	test   %eax,%eax
  80bb13:	0f 84 e2 00 00 00    	je     80bbfb <do_close_internal+0xf1>
  80bb19:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80bb1b:	83 38 10             	cmpl   $0x10,(%eax)
  80bb1e:	0f 85 ee 00 00 00    	jne    80bc12 <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80bb24:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80bb28:	0f 85 fb 00 00 00    	jne    80bc29 <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80bb2e:	8b 40 08             	mov    0x8(%eax),%eax
  80bb31:	85 c0                	test   %eax,%eax
  80bb33:	0f 84 07 01 00 00    	je     80bc40 <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80bb39:	83 ec 08             	sub    $0x8,%esp
  80bb3c:	6a 00                	push   $0x0
  80bb3e:	50                   	push   %eax
  80bb3f:	e8 f0 9e ff ff       	call   805a34 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80bb44:	8b 43 08             	mov    0x8(%ebx),%eax
  80bb47:	83 c4 10             	add    $0x10,%esp
  80bb4a:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bb4e:	0f 84 03 01 00 00    	je     80bc57 <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80bb54:	83 ec 08             	sub    $0x8,%esp
  80bb57:	6a 00                	push   $0x0
  80bb59:	50                   	push   %eax
  80bb5a:	e8 e7 9e ff ff       	call   805a46 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80bb5f:	83 c4 08             	add    $0x8,%esp
  80bb62:	6a 00                	push   $0x0
  80bb64:	ff 73 08             	pushl  0x8(%ebx)
  80bb67:	e8 19 9f ff ff       	call   805a85 <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80bb6c:	83 c4 08             	add    $0x8,%esp
  80bb6f:	6a 00                	push   $0x0
  80bb71:	ff 73 08             	pushl  0x8(%ebx)
  80bb74:	e8 e2 9e ff ff       	call   805a5b <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80bb79:	83 c4 0c             	add    $0xc,%esp
  80bb7c:	6a 04                	push   $0x4
  80bb7e:	6a 00                	push   $0x0
  80bb80:	ff 73 08             	pushl  0x8(%ebx)
  80bb83:	e8 0f 9f ff ff       	call   805a97 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80bb88:	83 c4 08             	add    $0x8,%esp
  80bb8b:	6a 00                	push   $0x0
  80bb8d:	ff 73 08             	pushl  0x8(%ebx)
  80bb90:	e8 db 9e ff ff       	call   805a70 <tcp_err>
  80bb95:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80bb98:	83 ec 0c             	sub    $0xc,%esp
  80bb9b:	ff 73 08             	pushl  0x8(%ebx)
  80bb9e:	e8 a3 a0 ff ff       	call   805c46 <tcp_close>
  if (err == ERR_OK) {
  80bba3:	83 c4 10             	add    $0x10,%esp
  80bba6:	84 c0                	test   %al,%al
  80bba8:	0f 85 bc 00 00 00    	jne    80bc6a <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80bbae:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80bbb5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80bbbc:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bbc0:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bbc3:	85 c0                	test   %eax,%eax
  80bbc5:	74 21                	je     80bbe8 <do_close_internal+0xde>
  80bbc7:	83 ec 04             	sub    $0x4,%esp
  80bbca:	6a 00                	push   $0x0
  80bbcc:	6a 00                	push   $0x0
  80bbce:	53                   	push   %ebx
  80bbcf:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80bbd1:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bbd4:	83 c4 10             	add    $0x10,%esp
  80bbd7:	85 c0                	test   %eax,%eax
  80bbd9:	74 0d                	je     80bbe8 <do_close_internal+0xde>
  80bbdb:	83 ec 04             	sub    $0x4,%esp
  80bbde:	6a 00                	push   $0x0
  80bbe0:	6a 02                	push   $0x2
  80bbe2:	53                   	push   %ebx
  80bbe3:	ff d0                	call   *%eax
  80bbe5:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80bbe8:	83 ec 0c             	sub    $0xc,%esp
  80bbeb:	ff 73 10             	pushl  0x10(%ebx)
  80bbee:	e8 7a e7 ff ff       	call   80a36d <sys_sem_signal>
  80bbf3:	83 c4 10             	add    $0x10,%esp
}
  80bbf6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bbf9:	c9                   	leave  
  80bbfa:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80bbfb:	83 ec 04             	sub    $0x4,%esp
  80bbfe:	68 74 31 81 00       	push   $0x813174
  80bc03:	68 53 02 00 00       	push   $0x253
  80bc08:	68 06 33 81 00       	push   $0x813306
  80bc0d:	e8 25 2d 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80bc12:	83 ec 04             	sub    $0x4,%esp
  80bc15:	68 a1 33 81 00       	push   $0x8133a1
  80bc1a:	68 54 02 00 00       	push   $0x254
  80bc1f:	68 06 33 81 00       	push   $0x813306
  80bc24:	e8 0e 2d 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80bc29:	83 ec 04             	sub    $0x4,%esp
  80bc2c:	68 44 32 81 00       	push   $0x813244
  80bc31:	68 55 02 00 00       	push   $0x255
  80bc36:	68 06 33 81 00       	push   $0x813306
  80bc3b:	e8 f7 2c 00 00       	call   80e937 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80bc40:	83 ec 04             	sub    $0x4,%esp
  80bc43:	68 bf 33 81 00       	push   $0x8133bf
  80bc48:	68 56 02 00 00       	push   $0x256
  80bc4d:	68 06 33 81 00       	push   $0x813306
  80bc52:	e8 e0 2c 00 00       	call   80e937 <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80bc57:	83 ec 08             	sub    $0x8,%esp
  80bc5a:	6a 00                	push   $0x0
  80bc5c:	50                   	push   %eax
  80bc5d:	e8 23 9e ff ff       	call   805a85 <tcp_accept>
  80bc62:	83 c4 10             	add    $0x10,%esp
  80bc65:	e9 2e ff ff ff       	jmp    80bb98 <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bc6a:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc6d:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bc71:	74 44                	je     80bcb7 <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80bc73:	83 ec 08             	sub    $0x8,%esp
  80bc76:	68 18 bd 80 00       	push   $0x80bd18
  80bc7b:	50                   	push   %eax
  80bc7c:	e8 da 9d ff ff       	call   805a5b <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80bc81:	83 c4 0c             	add    $0xc,%esp
  80bc84:	6a 04                	push   $0x4
  80bc86:	68 ce bc 80 00       	push   $0x80bcce
  80bc8b:	ff 73 08             	pushl  0x8(%ebx)
  80bc8e:	e8 04 9e ff ff       	call   805a97 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80bc93:	83 c4 08             	add    $0x8,%esp
  80bc96:	68 cd b8 80 00       	push   $0x80b8cd
  80bc9b:	ff 73 08             	pushl  0x8(%ebx)
  80bc9e:	e8 cd 9d ff ff       	call   805a70 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80bca3:	83 c4 08             	add    $0x8,%esp
  80bca6:	53                   	push   %ebx
  80bca7:	ff 73 08             	pushl  0x8(%ebx)
  80bcaa:	e8 85 9d ff ff       	call   805a34 <tcp_arg>
  80bcaf:	83 c4 10             	add    $0x10,%esp
}
  80bcb2:	e9 3f ff ff ff       	jmp    80bbf6 <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bcb7:	83 ec 04             	sub    $0x4,%esp
  80bcba:	68 68 32 81 00       	push   $0x813268
  80bcbf:	68 75 02 00 00       	push   $0x275
  80bcc4:	68 06 33 81 00       	push   $0x813306
  80bcc9:	e8 69 2c 00 00       	call   80e937 <_panic>

0080bcce <poll_tcp>:
{
  80bcce:	f3 0f 1e fb          	endbr32 
  80bcd2:	55                   	push   %ebp
  80bcd3:	89 e5                	mov    %esp,%ebp
  80bcd5:	83 ec 08             	sub    $0x8,%esp
  80bcd8:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bcdb:	85 c0                	test   %eax,%eax
  80bcdd:	74 14                	je     80bcf3 <poll_tcp+0x25>
  if (conn->state == NETCONN_WRITE) {
  80bcdf:	8b 50 04             	mov    0x4(%eax),%edx
  80bce2:	83 fa 01             	cmp    $0x1,%edx
  80bce5:	74 23                	je     80bd0a <poll_tcp+0x3c>
  } else if (conn->state == NETCONN_CLOSE) {
  80bce7:	83 fa 04             	cmp    $0x4,%edx
  80bcea:	74 25                	je     80bd11 <poll_tcp+0x43>
}
  80bcec:	b8 00 00 00 00       	mov    $0x0,%eax
  80bcf1:	c9                   	leave  
  80bcf2:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bcf3:	83 ec 04             	sub    $0x4,%esp
  80bcf6:	68 59 33 81 00       	push   $0x813359
  80bcfb:	68 eb 00 00 00       	push   $0xeb
  80bd00:	68 06 33 81 00       	push   $0x813306
  80bd05:	e8 2d 2c 00 00       	call   80e937 <_panic>
    do_writemore(conn);
  80bd0a:	e8 94 fc ff ff       	call   80b9a3 <do_writemore>
  80bd0f:	eb db                	jmp    80bcec <poll_tcp+0x1e>
    do_close_internal(conn);
  80bd11:	e8 f4 fd ff ff       	call   80bb0a <do_close_internal>
  80bd16:	eb d4                	jmp    80bcec <poll_tcp+0x1e>

0080bd18 <sent_tcp>:
{
  80bd18:	f3 0f 1e fb          	endbr32 
  80bd1c:	55                   	push   %ebp
  80bd1d:	89 e5                	mov    %esp,%ebp
  80bd1f:	56                   	push   %esi
  80bd20:	53                   	push   %ebx
  80bd21:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bd24:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bd27:	85 db                	test   %ebx,%ebx
  80bd29:	74 3e                	je     80bd69 <sent_tcp+0x51>
  if (conn->state == NETCONN_WRITE) {
  80bd2b:	8b 43 04             	mov    0x4(%ebx),%eax
  80bd2e:	83 f8 01             	cmp    $0x1,%eax
  80bd31:	74 4d                	je     80bd80 <sent_tcp+0x68>
  } else if (conn->state == NETCONN_CLOSE) {
  80bd33:	83 f8 04             	cmp    $0x4,%eax
  80bd36:	74 6e                	je     80bda6 <sent_tcp+0x8e>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80bd38:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd3b:	85 c0                	test   %eax,%eax
  80bd3d:	74 1e                	je     80bd5d <sent_tcp+0x45>
  80bd3f:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80bd45:	76 16                	jbe    80bd5d <sent_tcp+0x45>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80bd47:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bd4a:	85 c0                	test   %eax,%eax
  80bd4c:	74 0f                	je     80bd5d <sent_tcp+0x45>
  80bd4e:	83 ec 04             	sub    $0x4,%esp
  80bd51:	0f b7 f6             	movzwl %si,%esi
  80bd54:	56                   	push   %esi
  80bd55:	6a 02                	push   $0x2
  80bd57:	53                   	push   %ebx
  80bd58:	ff d0                	call   *%eax
  80bd5a:	83 c4 10             	add    $0x10,%esp
}
  80bd5d:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd62:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bd65:	5b                   	pop    %ebx
  80bd66:	5e                   	pop    %esi
  80bd67:	5d                   	pop    %ebp
  80bd68:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bd69:	83 ec 04             	sub    $0x4,%esp
  80bd6c:	68 59 33 81 00       	push   $0x813359
  80bd71:	68 03 01 00 00       	push   $0x103
  80bd76:	68 06 33 81 00       	push   $0x813306
  80bd7b:	e8 b7 2b 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bd80:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bd84:	74 09                	je     80bd8f <sent_tcp+0x77>
    do_writemore(conn);
  80bd86:	89 d8                	mov    %ebx,%eax
  80bd88:	e8 16 fc ff ff       	call   80b9a3 <do_writemore>
  80bd8d:	eb a9                	jmp    80bd38 <sent_tcp+0x20>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bd8f:	83 ec 04             	sub    $0x4,%esp
  80bd92:	68 d2 33 81 00       	push   $0x8133d2
  80bd97:	68 06 01 00 00       	push   $0x106
  80bd9c:	68 06 33 81 00       	push   $0x813306
  80bda1:	e8 91 2b 00 00       	call   80e937 <_panic>
    do_close_internal(conn);
  80bda6:	89 d8                	mov    %ebx,%eax
  80bda8:	e8 5d fd ff ff       	call   80bb0a <do_close_internal>
  80bdad:	eb 89                	jmp    80bd38 <sent_tcp+0x20>

0080bdaf <do_newconn>:
{
  80bdaf:	f3 0f 1e fb          	endbr32 
  80bdb3:	55                   	push   %ebp
  80bdb4:	89 e5                	mov    %esp,%ebp
  80bdb6:	56                   	push   %esi
  80bdb7:	53                   	push   %ebx
  80bdb8:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80bdbb:	8b 03                	mov    (%ebx),%eax
  80bdbd:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bdc1:	74 17                	je     80bdda <do_newconn+0x2b>
   TCPIP_APIMSG_ACK(msg);
  80bdc3:	83 ec 0c             	sub    $0xc,%esp
  80bdc6:	8b 03                	mov    (%ebx),%eax
  80bdc8:	ff 70 10             	pushl  0x10(%eax)
  80bdcb:	e8 9d e5 ff ff       	call   80a36d <sys_sem_signal>
}
  80bdd0:	83 c4 10             	add    $0x10,%esp
  80bdd3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bdd6:	5b                   	pop    %ebx
  80bdd7:	5e                   	pop    %esi
  80bdd8:	5d                   	pop    %ebp
  80bdd9:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80bdda:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bdde:	8b 33                	mov    (%ebx),%esi
  80bde0:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80bde4:	75 20                	jne    80be06 <do_newconn+0x57>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80bde6:	8b 06                	mov    (%esi),%eax
  80bde8:	25 f0 00 00 00       	and    $0xf0,%eax
  80bded:	83 f8 20             	cmp    $0x20,%eax
  80bdf0:	74 67                	je     80be59 <do_newconn+0xaa>
  80bdf2:	83 f8 40             	cmp    $0x40,%eax
  80bdf5:	74 26                	je     80be1d <do_newconn+0x6e>
  80bdf7:	83 f8 10             	cmp    $0x10,%eax
  80bdfa:	0f 84 99 00 00 00    	je     80be99 <do_newconn+0xea>
     msg->conn->err = ERR_VAL;
  80be00:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
     break;
  80be04:	eb bd                	jmp    80bdc3 <do_newconn+0x14>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80be06:	83 ec 04             	sub    $0x4,%esp
  80be09:	68 8c 32 81 00       	push   $0x81328c
  80be0e:	68 8a 01 00 00       	push   $0x18a
  80be13:	68 06 33 81 00       	push   $0x813306
  80be18:	e8 1a 2b 00 00       	call   80e937 <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80be1d:	83 ec 0c             	sub    $0xc,%esp
  80be20:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80be24:	50                   	push   %eax
  80be25:	e8 6a 25 00 00       	call   80e394 <raw_new>
  80be2a:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80be2d:	8b 03                	mov    (%ebx),%eax
  80be2f:	8b 50 08             	mov    0x8(%eax),%edx
  80be32:	83 c4 10             	add    $0x10,%esp
  80be35:	85 d2                	test   %edx,%edx
  80be37:	74 17                	je     80be50 <do_newconn+0xa1>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80be39:	83 ec 04             	sub    $0x4,%esp
  80be3c:	50                   	push   %eax
  80be3d:	68 3e b7 80 00       	push   $0x80b73e
  80be42:	52                   	push   %edx
  80be43:	e8 c0 23 00 00       	call   80e208 <raw_recv>
     break;
  80be48:	83 c4 10             	add    $0x10,%esp
  80be4b:	e9 73 ff ff ff       	jmp    80bdc3 <do_newconn+0x14>
       msg->conn->err = ERR_MEM;
  80be50:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80be54:	e9 6a ff ff ff       	jmp    80bdc3 <do_newconn+0x14>
     msg->conn->pcb.udp = udp_new();
  80be59:	e8 4e d4 ff ff       	call   8092ac <udp_new>
  80be5e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80be61:	8b 03                	mov    (%ebx),%eax
  80be63:	8b 50 08             	mov    0x8(%eax),%edx
  80be66:	85 d2                	test   %edx,%edx
  80be68:	74 20                	je     80be8a <do_newconn+0xdb>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80be6a:	83 38 22             	cmpl   $0x22,(%eax)
  80be6d:	74 24                	je     80be93 <do_newconn+0xe4>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80be6f:	8b 03                	mov    (%ebx),%eax
  80be71:	83 ec 04             	sub    $0x4,%esp
  80be74:	50                   	push   %eax
  80be75:	68 30 b6 80 00       	push   $0x80b630
  80be7a:	ff 70 08             	pushl  0x8(%eax)
  80be7d:	e8 ca d3 ff ff       	call   80924c <udp_recv>
     break;
  80be82:	83 c4 10             	add    $0x10,%esp
  80be85:	e9 39 ff ff ff       	jmp    80bdc3 <do_newconn+0x14>
       msg->conn->err = ERR_MEM;
  80be8a:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80be8e:	e9 30 ff ff ff       	jmp    80bdc3 <do_newconn+0x14>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80be93:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80be97:	eb d6                	jmp    80be6f <do_newconn+0xc0>
     msg->conn->pcb.tcp = tcp_new();
  80be99:	e8 6a a6 ff ff       	call   806508 <tcp_new>
  80be9e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80bea1:	8b 03                	mov    (%ebx),%eax
  80bea3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bea7:	74 0a                	je     80beb3 <do_newconn+0x104>
     setup_tcp(msg->conn);
  80bea9:	e8 7c f9 ff ff       	call   80b82a <setup_tcp>
     break;
  80beae:	e9 10 ff ff ff       	jmp    80bdc3 <do_newconn+0x14>
       msg->conn->err = ERR_MEM;
  80beb3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80beb7:	e9 07 ff ff ff       	jmp    80bdc3 <do_newconn+0x14>

0080bebc <netconn_alloc>:
{
  80bebc:	f3 0f 1e fb          	endbr32 
  80bec0:	55                   	push   %ebp
  80bec1:	89 e5                	mov    %esp,%ebp
  80bec3:	53                   	push   %ebx
  80bec4:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80bec7:	6a 07                	push   $0x7
  80bec9:	e8 70 87 ff ff       	call   80463e <memp_malloc>
  80bece:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bed0:	83 c4 10             	add    $0x10,%esp
  80bed3:	85 c0                	test   %eax,%eax
  80bed5:	74 5b                	je     80bf32 <netconn_alloc+0x76>
  conn->err = ERR_OK;
  80bed7:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80bedb:	8b 45 08             	mov    0x8(%ebp),%eax
  80bede:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80bee0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bee7:	83 ec 0c             	sub    $0xc,%esp
  80beea:	6a 00                	push   $0x0
  80beec:	e8 af e1 ff ff       	call   80a0a0 <sys_sem_new>
  80bef1:	89 43 10             	mov    %eax,0x10(%ebx)
  80bef4:	83 c4 10             	add    $0x10,%esp
  80bef7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80befa:	74 3d                	je     80bf39 <netconn_alloc+0x7d>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80befc:	83 ec 0c             	sub    $0xc,%esp
  80beff:	6a 00                	push   $0x0
  80bf01:	e8 4f e3 ff ff       	call   80a255 <sys_mbox_new>
  80bf06:	89 43 14             	mov    %eax,0x14(%ebx)
  80bf09:	83 c4 10             	add    $0x10,%esp
  80bf0c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bf0f:	74 3d                	je     80bf4e <netconn_alloc+0x92>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80bf11:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bf18:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80bf1f:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80bf26:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bf29:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bf2c:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80bf32:	89 d8                	mov    %ebx,%eax
  80bf34:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bf37:	c9                   	leave  
  80bf38:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80bf39:	83 ec 08             	sub    $0x8,%esp
  80bf3c:	53                   	push   %ebx
  80bf3d:	6a 07                	push   $0x7
  80bf3f:	e8 54 87 ff ff       	call   804698 <memp_free>
    return NULL;
  80bf44:	83 c4 10             	add    $0x10,%esp
  80bf47:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bf4c:	eb e4                	jmp    80bf32 <netconn_alloc+0x76>
    sys_sem_free(conn->op_completed);
  80bf4e:	83 ec 0c             	sub    $0xc,%esp
  80bf51:	ff 73 10             	pushl  0x10(%ebx)
  80bf54:	e8 cc e1 ff ff       	call   80a125 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bf59:	83 c4 08             	add    $0x8,%esp
  80bf5c:	53                   	push   %ebx
  80bf5d:	6a 07                	push   $0x7
  80bf5f:	e8 34 87 ff ff       	call   804698 <memp_free>
    return NULL;
  80bf64:	83 c4 10             	add    $0x10,%esp
  80bf67:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bf6c:	eb c4                	jmp    80bf32 <netconn_alloc+0x76>

0080bf6e <netconn_free>:
{
  80bf6e:	f3 0f 1e fb          	endbr32 
  80bf72:	55                   	push   %ebp
  80bf73:	89 e5                	mov    %esp,%ebp
  80bf75:	56                   	push   %esi
  80bf76:	53                   	push   %ebx
  80bf77:	83 ec 10             	sub    $0x10,%esp
  80bf7a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bf7d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bf81:	75 0b                	jne    80bf8e <netconn_free+0x20>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bf83:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bf86:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bf8a:	75 27                	jne    80bfb3 <netconn_free+0x45>
  80bf8c:	eb 68                	jmp    80bff6 <netconn_free+0x88>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bf8e:	83 ec 04             	sub    $0x4,%esp
  80bf91:	68 ac 32 81 00       	push   $0x8132ac
  80bf96:	68 26 02 00 00       	push   $0x226
  80bf9b:	68 06 33 81 00       	push   $0x813306
  80bfa0:	e8 92 29 00 00       	call   80e937 <_panic>
        netbuf_delete((struct netbuf *)mem);
  80bfa5:	83 ec 0c             	sub    $0xc,%esp
  80bfa8:	ff 75 f4             	pushl  -0xc(%ebp)
  80bfab:	e8 4b 66 ff ff       	call   8025fb <netbuf_delete>
  80bfb0:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bfb3:	83 ec 08             	sub    $0x8,%esp
  80bfb6:	56                   	push   %esi
  80bfb7:	ff 73 14             	pushl  0x14(%ebx)
  80bfba:	e8 25 e7 ff ff       	call   80a6e4 <sys_arch_mbox_tryfetch>
  80bfbf:	83 c4 10             	add    $0x10,%esp
  80bfc2:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bfc5:	74 1a                	je     80bfe1 <netconn_free+0x73>
      if (conn->type == NETCONN_TCP) {
  80bfc7:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bfca:	75 d9                	jne    80bfa5 <netconn_free+0x37>
        if(mem != NULL) {
  80bfcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bfcf:	85 c0                	test   %eax,%eax
  80bfd1:	74 e0                	je     80bfb3 <netconn_free+0x45>
          pbuf_free((struct pbuf *)mem);
  80bfd3:	83 ec 0c             	sub    $0xc,%esp
  80bfd6:	50                   	push   %eax
  80bfd7:	e8 3f 8a ff ff       	call   804a1b <pbuf_free>
  80bfdc:	83 c4 10             	add    $0x10,%esp
  80bfdf:	eb d2                	jmp    80bfb3 <netconn_free+0x45>
    sys_mbox_free(conn->recvmbox);
  80bfe1:	83 ec 0c             	sub    $0xc,%esp
  80bfe4:	ff 73 14             	pushl  0x14(%ebx)
  80bfe7:	e8 c6 e1 ff ff       	call   80a1b2 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bfec:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bff3:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bff6:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bff9:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bffd:	75 10                	jne    80c00f <netconn_free+0xa1>
  80bfff:	eb 37                	jmp    80c038 <netconn_free+0xca>
      netconn_delete((struct netconn *)mem);
  80c001:	83 ec 0c             	sub    $0xc,%esp
  80c004:	ff 75 f4             	pushl  -0xc(%ebp)
  80c007:	e8 da ef ff ff       	call   80afe6 <netconn_delete>
  80c00c:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c00f:	83 ec 08             	sub    $0x8,%esp
  80c012:	56                   	push   %esi
  80c013:	ff 73 18             	pushl  0x18(%ebx)
  80c016:	e8 c9 e6 ff ff       	call   80a6e4 <sys_arch_mbox_tryfetch>
  80c01b:	83 c4 10             	add    $0x10,%esp
  80c01e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c021:	75 de                	jne    80c001 <netconn_free+0x93>
    sys_mbox_free(conn->acceptmbox);
  80c023:	83 ec 0c             	sub    $0xc,%esp
  80c026:	ff 73 18             	pushl  0x18(%ebx)
  80c029:	e8 84 e1 ff ff       	call   80a1b2 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80c02e:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80c035:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80c038:	83 ec 0c             	sub    $0xc,%esp
  80c03b:	ff 73 10             	pushl  0x10(%ebx)
  80c03e:	e8 e2 e0 ff ff       	call   80a125 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80c043:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80c04a:	83 c4 08             	add    $0x8,%esp
  80c04d:	53                   	push   %ebx
  80c04e:	6a 07                	push   $0x7
  80c050:	e8 43 86 ff ff       	call   804698 <memp_free>
}
  80c055:	83 c4 10             	add    $0x10,%esp
  80c058:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c05b:	5b                   	pop    %ebx
  80c05c:	5e                   	pop    %esi
  80c05d:	5d                   	pop    %ebp
  80c05e:	c3                   	ret    

0080c05f <accept_function>:
{
  80c05f:	f3 0f 1e fb          	endbr32 
  80c063:	55                   	push   %ebp
  80c064:	89 e5                	mov    %esp,%ebp
  80c066:	57                   	push   %edi
  80c067:	56                   	push   %esi
  80c068:	53                   	push   %ebx
  80c069:	83 ec 0c             	sub    $0xc,%esp
  80c06c:	8b 75 08             	mov    0x8(%ebp),%esi
  80c06f:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80c072:	83 7e 18 ff          	cmpl   $0xffffffff,0x18(%esi)
  80c076:	74 57                	je     80c0cf <accept_function+0x70>
  newconn = netconn_alloc(conn->type, conn->callback);
  80c078:	83 ec 08             	sub    $0x8,%esp
  80c07b:	ff 76 2c             	pushl  0x2c(%esi)
  80c07e:	ff 36                	pushl  (%esi)
  80c080:	e8 37 fe ff ff       	call   80bebc <netconn_alloc>
  80c085:	89 c3                	mov    %eax,%ebx
  if (newconn == NULL) {
  80c087:	83 c4 10             	add    $0x10,%esp
  80c08a:	85 c0                	test   %eax,%eax
  80c08c:	74 72                	je     80c100 <accept_function+0xa1>
  newconn->pcb.tcp = newpcb;
  80c08e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c091:	89 43 08             	mov    %eax,0x8(%ebx)
  setup_tcp(newconn);
  80c094:	89 d8                	mov    %ebx,%eax
  80c096:	e8 8f f7 ff ff       	call   80b82a <setup_tcp>
  newconn->err = err;
  80c09b:	89 f8                	mov    %edi,%eax
  80c09d:	88 43 0c             	mov    %al,0xc(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c0a0:	8b 46 2c             	mov    0x2c(%esi),%eax
  80c0a3:	85 c0                	test   %eax,%eax
  80c0a5:	74 0d                	je     80c0b4 <accept_function+0x55>
  80c0a7:	83 ec 04             	sub    $0x4,%esp
  80c0aa:	6a 00                	push   $0x0
  80c0ac:	6a 00                	push   $0x0
  80c0ae:	56                   	push   %esi
  80c0af:	ff d0                	call   *%eax
  80c0b1:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80c0b4:	83 ec 08             	sub    $0x8,%esp
  80c0b7:	53                   	push   %ebx
  80c0b8:	ff 76 18             	pushl  0x18(%esi)
  80c0bb:	e8 35 e4 ff ff       	call   80a4f5 <sys_mbox_trypost>
  80c0c0:	83 c4 10             	add    $0x10,%esp
  80c0c3:	84 c0                	test   %al,%al
  80c0c5:	75 1f                	jne    80c0e6 <accept_function+0x87>
}
  80c0c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c0ca:	5b                   	pop    %ebx
  80c0cb:	5e                   	pop    %esi
  80c0cc:	5f                   	pop    %edi
  80c0cd:	5d                   	pop    %ebp
  80c0ce:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80c0cf:	83 ec 04             	sub    $0x4,%esp
  80c0d2:	68 dc 32 81 00       	push   $0x8132dc
  80c0d7:	68 64 01 00 00       	push   $0x164
  80c0dc:	68 06 33 81 00       	push   $0x813306
  80c0e1:	e8 51 28 00 00       	call   80e937 <_panic>
    newconn->pcb.tcp = NULL;
  80c0e6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    netconn_free(newconn);
  80c0ed:	83 ec 0c             	sub    $0xc,%esp
  80c0f0:	53                   	push   %ebx
  80c0f1:	e8 78 fe ff ff       	call   80bf6e <netconn_free>
    return ERR_MEM;
  80c0f6:	83 c4 10             	add    $0x10,%esp
  80c0f9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c0fe:	eb c7                	jmp    80c0c7 <accept_function+0x68>
    return ERR_MEM;
  80c100:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c105:	eb c0                	jmp    80c0c7 <accept_function+0x68>

0080c107 <do_delconn>:
{
  80c107:	f3 0f 1e fb          	endbr32 
  80c10b:	55                   	push   %ebp
  80c10c:	89 e5                	mov    %esp,%ebp
  80c10e:	53                   	push   %ebx
  80c10f:	83 ec 04             	sub    $0x4,%esp
  80c112:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80c115:	8b 13                	mov    (%ebx),%edx
  80c117:	8b 4a 08             	mov    0x8(%edx),%ecx
  80c11a:	85 c9                	test   %ecx,%ecx
  80c11c:	74 16                	je     80c134 <do_delconn+0x2d>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c11e:	8b 02                	mov    (%edx),%eax
  80c120:	25 f0 00 00 00       	and    $0xf0,%eax
  80c125:	83 f8 20             	cmp    $0x20,%eax
  80c128:	74 53                	je     80c17d <do_delconn+0x76>
  80c12a:	83 f8 40             	cmp    $0x40,%eax
  80c12d:	74 40                	je     80c16f <do_delconn+0x68>
  80c12f:	83 f8 10             	cmp    $0x10,%eax
  80c132:	74 62                	je     80c196 <do_delconn+0x8f>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80c134:	8b 13                	mov    (%ebx),%edx
  80c136:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c139:	85 c0                	test   %eax,%eax
  80c13b:	74 23                	je     80c160 <do_delconn+0x59>
  80c13d:	83 ec 04             	sub    $0x4,%esp
  80c140:	6a 00                	push   $0x0
  80c142:	6a 00                	push   $0x0
  80c144:	52                   	push   %edx
  80c145:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80c147:	8b 13                	mov    (%ebx),%edx
  80c149:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c14c:	83 c4 10             	add    $0x10,%esp
  80c14f:	85 c0                	test   %eax,%eax
  80c151:	74 0d                	je     80c160 <do_delconn+0x59>
  80c153:	83 ec 04             	sub    $0x4,%esp
  80c156:	6a 00                	push   $0x0
  80c158:	6a 02                	push   $0x2
  80c15a:	52                   	push   %edx
  80c15b:	ff d0                	call   *%eax
  80c15d:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80c160:	8b 03                	mov    (%ebx),%eax
  80c162:	8b 40 10             	mov    0x10(%eax),%eax
  80c165:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c168:	75 3c                	jne    80c1a6 <do_delconn+0x9f>
}
  80c16a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c16d:	c9                   	leave  
  80c16e:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80c16f:	83 ec 0c             	sub    $0xc,%esp
  80c172:	51                   	push   %ecx
  80c173:	e8 d4 21 00 00       	call   80e34c <raw_remove>
      break;
  80c178:	83 c4 10             	add    $0x10,%esp
  80c17b:	eb b7                	jmp    80c134 <do_delconn+0x2d>
      msg->conn->pcb.udp->recv_arg = NULL;
  80c17d:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80c184:	83 ec 0c             	sub    $0xc,%esp
  80c187:	8b 03                	mov    (%ebx),%eax
  80c189:	ff 70 08             	pushl  0x8(%eax)
  80c18c:	e8 d3 d0 ff ff       	call   809264 <udp_remove>
      break;
  80c191:	83 c4 10             	add    $0x10,%esp
  80c194:	eb 9e                	jmp    80c134 <do_delconn+0x2d>
      msg->conn->state = NETCONN_CLOSE;
  80c196:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80c19d:	8b 03                	mov    (%ebx),%eax
  80c19f:	e8 66 f9 ff ff       	call   80bb0a <do_close_internal>
      return;
  80c1a4:	eb c4                	jmp    80c16a <do_delconn+0x63>
    sys_sem_signal(msg->conn->op_completed);
  80c1a6:	83 ec 0c             	sub    $0xc,%esp
  80c1a9:	50                   	push   %eax
  80c1aa:	e8 be e1 ff ff       	call   80a36d <sys_sem_signal>
  80c1af:	83 c4 10             	add    $0x10,%esp
  80c1b2:	eb b6                	jmp    80c16a <do_delconn+0x63>

0080c1b4 <do_bind>:
{
  80c1b4:	f3 0f 1e fb          	endbr32 
  80c1b8:	55                   	push   %ebp
  80c1b9:	89 e5                	mov    %esp,%ebp
  80c1bb:	56                   	push   %esi
  80c1bc:	53                   	push   %ebx
  80c1bd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c1c0:	8b 33                	mov    (%ebx),%esi
  80c1c2:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c1c6:	7c 1d                	jl     80c1e5 <do_bind+0x31>
    if (msg->conn->pcb.tcp != NULL) {
  80c1c8:	8b 56 08             	mov    0x8(%esi),%edx
  80c1cb:	85 d2                	test   %edx,%edx
  80c1cd:	74 73                	je     80c242 <do_bind+0x8e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c1cf:	8b 06                	mov    (%esi),%eax
  80c1d1:	25 f0 00 00 00       	and    $0xf0,%eax
  80c1d6:	83 f8 20             	cmp    $0x20,%eax
  80c1d9:	74 35                	je     80c210 <do_bind+0x5c>
  80c1db:	83 f8 40             	cmp    $0x40,%eax
  80c1de:	74 1c                	je     80c1fc <do_bind+0x48>
  80c1e0:	83 f8 10             	cmp    $0x10,%eax
  80c1e3:	74 44                	je     80c229 <do_bind+0x75>
  TCPIP_APIMSG_ACK(msg);
  80c1e5:	83 ec 0c             	sub    $0xc,%esp
  80c1e8:	8b 03                	mov    (%ebx),%eax
  80c1ea:	ff 70 10             	pushl  0x10(%eax)
  80c1ed:	e8 7b e1 ff ff       	call   80a36d <sys_sem_signal>
}
  80c1f2:	83 c4 10             	add    $0x10,%esp
  80c1f5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c1f8:	5b                   	pop    %ebx
  80c1f9:	5e                   	pop    %esi
  80c1fa:	5d                   	pop    %ebp
  80c1fb:	c3                   	ret    
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c1fc:	83 ec 08             	sub    $0x8,%esp
  80c1ff:	ff 73 04             	pushl  0x4(%ebx)
  80c202:	52                   	push   %edx
  80c203:	e8 bd 1f 00 00       	call   80e1c5 <raw_bind>
  80c208:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c20b:	83 c4 10             	add    $0x10,%esp
  80c20e:	eb d5                	jmp    80c1e5 <do_bind+0x31>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c210:	83 ec 04             	sub    $0x4,%esp
  80c213:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c217:	50                   	push   %eax
  80c218:	ff 73 04             	pushl  0x4(%ebx)
  80c21b:	52                   	push   %edx
  80c21c:	e8 d7 cc ff ff       	call   808ef8 <udp_bind>
  80c221:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c224:	83 c4 10             	add    $0x10,%esp
  80c227:	eb bc                	jmp    80c1e5 <do_bind+0x31>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c229:	83 ec 04             	sub    $0x4,%esp
  80c22c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c230:	50                   	push   %eax
  80c231:	ff 73 04             	pushl  0x4(%ebx)
  80c234:	52                   	push   %edx
  80c235:	e8 d1 93 ff ff       	call   80560b <tcp_bind>
  80c23a:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c23d:	83 c4 10             	add    $0x10,%esp
  80c240:	eb a3                	jmp    80c1e5 <do_bind+0x31>
      msg->conn->err = ERR_VAL;
  80c242:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80c246:	eb 9d                	jmp    80c1e5 <do_bind+0x31>

0080c248 <do_connect>:
{
  80c248:	f3 0f 1e fb          	endbr32 
  80c24c:	55                   	push   %ebp
  80c24d:	89 e5                	mov    %esp,%ebp
  80c24f:	56                   	push   %esi
  80c250:	53                   	push   %ebx
  80c251:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80c254:	8b 33                	mov    (%ebx),%esi
  80c256:	8b 56 08             	mov    0x8(%esi),%edx
  80c259:	85 d2                	test   %edx,%edx
  80c25b:	74 1d                	je     80c27a <do_connect+0x32>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c25d:	8b 06                	mov    (%esi),%eax
  80c25f:	25 f0 00 00 00       	and    $0xf0,%eax
  80c264:	83 f8 20             	cmp    $0x20,%eax
  80c267:	74 42                	je     80c2ab <do_connect+0x63>
  80c269:	83 f8 40             	cmp    $0x40,%eax
  80c26c:	74 1c                	je     80c28a <do_connect+0x42>
  80c26e:	83 f8 10             	cmp    $0x10,%eax
  80c271:	74 5e                	je     80c2d1 <do_connect+0x89>
}
  80c273:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c276:	5b                   	pop    %ebx
  80c277:	5e                   	pop    %esi
  80c278:	5d                   	pop    %ebp
  80c279:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80c27a:	83 ec 0c             	sub    $0xc,%esp
  80c27d:	ff 76 10             	pushl  0x10(%esi)
  80c280:	e8 e8 e0 ff ff       	call   80a36d <sys_sem_signal>
    return;
  80c285:	83 c4 10             	add    $0x10,%esp
  80c288:	eb e9                	jmp    80c273 <do_connect+0x2b>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c28a:	83 ec 08             	sub    $0x8,%esp
  80c28d:	ff 73 04             	pushl  0x4(%ebx)
  80c290:	52                   	push   %edx
  80c291:	e8 50 1f 00 00       	call   80e1e6 <raw_connect>
  80c296:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c299:	83 c4 04             	add    $0x4,%esp
  80c29c:	8b 03                	mov    (%ebx),%eax
  80c29e:	ff 70 10             	pushl  0x10(%eax)
  80c2a1:	e8 c7 e0 ff ff       	call   80a36d <sys_sem_signal>
    break;
  80c2a6:	83 c4 10             	add    $0x10,%esp
  80c2a9:	eb c8                	jmp    80c273 <do_connect+0x2b>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c2ab:	83 ec 04             	sub    $0x4,%esp
  80c2ae:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c2b2:	50                   	push   %eax
  80c2b3:	ff 73 04             	pushl  0x4(%ebx)
  80c2b6:	52                   	push   %edx
  80c2b7:	e8 fc ce ff ff       	call   8091b8 <udp_connect>
  80c2bc:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c2bf:	83 c4 04             	add    $0x4,%esp
  80c2c2:	8b 03                	mov    (%ebx),%eax
  80c2c4:	ff 70 10             	pushl  0x10(%eax)
  80c2c7:	e8 a1 e0 ff ff       	call   80a36d <sys_sem_signal>
    break;
  80c2cc:	83 c4 10             	add    $0x10,%esp
  80c2cf:	eb a2                	jmp    80c273 <do_connect+0x2b>
    msg->conn->state = NETCONN_CONNECT;
  80c2d1:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80c2d8:	8b 03                	mov    (%ebx),%eax
  80c2da:	e8 4b f5 ff ff       	call   80b82a <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80c2df:	8b 33                	mov    (%ebx),%esi
  80c2e1:	68 7d b8 80 00       	push   $0x80b87d
  80c2e6:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c2ea:	50                   	push   %eax
  80c2eb:	ff 73 04             	pushl  0x4(%ebx)
  80c2ee:	ff 76 08             	pushl  0x8(%esi)
  80c2f1:	e8 60 a2 ff ff       	call   806556 <tcp_connect>
  80c2f6:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80c2f9:	83 c4 10             	add    $0x10,%esp
  80c2fc:	e9 72 ff ff ff       	jmp    80c273 <do_connect+0x2b>

0080c301 <do_disconnect>:
{
  80c301:	f3 0f 1e fb          	endbr32 
  80c305:	55                   	push   %ebp
  80c306:	89 e5                	mov    %esp,%ebp
  80c308:	53                   	push   %ebx
  80c309:	83 ec 04             	sub    $0x4,%esp
  80c30c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80c30f:	8b 13                	mov    (%ebx),%edx
  80c311:	8b 02                	mov    (%edx),%eax
  80c313:	25 f0 00 00 00       	and    $0xf0,%eax
  80c318:	83 f8 20             	cmp    $0x20,%eax
  80c31b:	74 15                	je     80c332 <do_disconnect+0x31>
  TCPIP_APIMSG_ACK(msg);
  80c31d:	83 ec 0c             	sub    $0xc,%esp
  80c320:	8b 03                	mov    (%ebx),%eax
  80c322:	ff 70 10             	pushl  0x10(%eax)
  80c325:	e8 43 e0 ff ff       	call   80a36d <sys_sem_signal>
}
  80c32a:	83 c4 10             	add    $0x10,%esp
  80c32d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c330:	c9                   	leave  
  80c331:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80c332:	83 ec 0c             	sub    $0xc,%esp
  80c335:	ff 72 08             	pushl  0x8(%edx)
  80c338:	e8 f0 ce ff ff       	call   80922d <udp_disconnect>
  80c33d:	83 c4 10             	add    $0x10,%esp
  80c340:	eb db                	jmp    80c31d <do_disconnect+0x1c>

0080c342 <do_listen>:
{
  80c342:	f3 0f 1e fb          	endbr32 
  80c346:	55                   	push   %ebp
  80c347:	89 e5                	mov    %esp,%ebp
  80c349:	57                   	push   %edi
  80c34a:	56                   	push   %esi
  80c34b:	53                   	push   %ebx
  80c34c:	83 ec 0c             	sub    $0xc,%esp
  80c34f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c352:	8b 03                	mov    (%ebx),%eax
  80c354:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c358:	7c 0c                	jl     80c366 <do_listen+0x24>
    if (msg->conn->pcb.tcp != NULL) {
  80c35a:	8b 50 08             	mov    0x8(%eax),%edx
  80c35d:	85 d2                	test   %edx,%edx
  80c35f:	74 05                	je     80c366 <do_listen+0x24>
      if (msg->conn->type == NETCONN_TCP) {
  80c361:	83 38 10             	cmpl   $0x10,(%eax)
  80c364:	74 18                	je     80c37e <do_listen+0x3c>
  TCPIP_APIMSG_ACK(msg);
  80c366:	83 ec 0c             	sub    $0xc,%esp
  80c369:	8b 03                	mov    (%ebx),%eax
  80c36b:	ff 70 10             	pushl  0x10(%eax)
  80c36e:	e8 fa df ff ff       	call   80a36d <sys_sem_signal>
}
  80c373:	83 c4 10             	add    $0x10,%esp
  80c376:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c379:	5b                   	pop    %ebx
  80c37a:	5e                   	pop    %esi
  80c37b:	5f                   	pop    %edi
  80c37c:	5d                   	pop    %ebp
  80c37d:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c37e:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c382:	74 06                	je     80c38a <do_listen+0x48>
          msg->conn->err = ERR_CONN;
  80c384:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80c388:	eb dc                	jmp    80c366 <do_listen+0x24>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c38a:	83 ec 08             	sub    $0x8,%esp
  80c38d:	68 ff 00 00 00       	push   $0xff
  80c392:	52                   	push   %edx
  80c393:	e8 c2 93 ff ff       	call   80575a <tcp_listen_with_backlog>
  80c398:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80c39a:	83 c4 10             	add    $0x10,%esp
  80c39d:	85 c0                	test   %eax,%eax
  80c39f:	74 4e                	je     80c3ef <do_listen+0xad>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c3a1:	8b 03                	mov    (%ebx),%eax
  80c3a3:	8b 40 14             	mov    0x14(%eax),%eax
  80c3a6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c3a9:	75 4f                	jne    80c3fa <do_listen+0xb8>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c3ab:	8b 3b                	mov    (%ebx),%edi
  80c3ad:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80c3b1:	74 5e                	je     80c411 <do_listen+0xcf>
            if (msg->conn->err == ERR_OK) {
  80c3b3:	8b 03                	mov    (%ebx),%eax
  80c3b5:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c3b9:	75 ab                	jne    80c366 <do_listen+0x24>
              msg->conn->state = NETCONN_LISTEN;
  80c3bb:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c3c2:	8b 03                	mov    (%ebx),%eax
  80c3c4:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c3c7:	8b 03                	mov    (%ebx),%eax
  80c3c9:	83 ec 08             	sub    $0x8,%esp
  80c3cc:	50                   	push   %eax
  80c3cd:	ff 70 08             	pushl  0x8(%eax)
  80c3d0:	e8 5f 96 ff ff       	call   805a34 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c3d5:	83 c4 08             	add    $0x8,%esp
  80c3d8:	68 5f c0 80 00       	push   $0x80c05f
  80c3dd:	8b 03                	mov    (%ebx),%eax
  80c3df:	ff 70 08             	pushl  0x8(%eax)
  80c3e2:	e8 9e 96 ff ff       	call   805a85 <tcp_accept>
  80c3e7:	83 c4 10             	add    $0x10,%esp
  80c3ea:	e9 77 ff ff ff       	jmp    80c366 <do_listen+0x24>
            msg->conn->err = ERR_MEM;
  80c3ef:	8b 03                	mov    (%ebx),%eax
  80c3f1:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c3f5:	e9 6c ff ff ff       	jmp    80c366 <do_listen+0x24>
              sys_mbox_free(msg->conn->recvmbox);
  80c3fa:	83 ec 0c             	sub    $0xc,%esp
  80c3fd:	50                   	push   %eax
  80c3fe:	e8 af dd ff ff       	call   80a1b2 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c403:	8b 03                	mov    (%ebx),%eax
  80c405:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c40c:	83 c4 10             	add    $0x10,%esp
  80c40f:	eb 9a                	jmp    80c3ab <do_listen+0x69>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c411:	83 ec 0c             	sub    $0xc,%esp
  80c414:	6a 00                	push   $0x0
  80c416:	e8 3a de ff ff       	call   80a255 <sys_mbox_new>
  80c41b:	89 47 18             	mov    %eax,0x18(%edi)
  80c41e:	83 c4 10             	add    $0x10,%esp
  80c421:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c424:	75 8d                	jne    80c3b3 <do_listen+0x71>
                msg->conn->err = ERR_MEM;
  80c426:	8b 03                	mov    (%ebx),%eax
  80c428:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c42c:	eb 85                	jmp    80c3b3 <do_listen+0x71>

0080c42e <do_send>:
{
  80c42e:	f3 0f 1e fb          	endbr32 
  80c432:	55                   	push   %ebp
  80c433:	89 e5                	mov    %esp,%ebp
  80c435:	57                   	push   %edi
  80c436:	56                   	push   %esi
  80c437:	53                   	push   %ebx
  80c438:	83 ec 0c             	sub    $0xc,%esp
  80c43b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c43e:	8b 33                	mov    (%ebx),%esi
  80c440:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c444:	7c 34                	jl     80c47a <do_send+0x4c>
    if (msg->conn->pcb.tcp != NULL) {
  80c446:	8b 56 08             	mov    0x8(%esi),%edx
  80c449:	85 d2                	test   %edx,%edx
  80c44b:	74 2d                	je     80c47a <do_send+0x4c>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c44d:	8b 06                	mov    (%esi),%eax
  80c44f:	25 f0 00 00 00       	and    $0xf0,%eax
  80c454:	83 f8 20             	cmp    $0x20,%eax
  80c457:	74 4c                	je     80c4a5 <do_send+0x77>
  80c459:	83 f8 40             	cmp    $0x40,%eax
  80c45c:	75 1c                	jne    80c47a <do_send+0x4c>
        if (msg->msg.b->addr == NULL) {
  80c45e:	8b 43 04             	mov    0x4(%ebx),%eax
  80c461:	8b 48 08             	mov    0x8(%eax),%ecx
  80c464:	85 c9                	test   %ecx,%ecx
  80c466:	74 2a                	je     80c492 <do_send+0x64>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c468:	83 ec 04             	sub    $0x4,%esp
  80c46b:	51                   	push   %ecx
  80c46c:	ff 30                	pushl  (%eax)
  80c46e:	52                   	push   %edx
  80c46f:	e8 ac 1d 00 00       	call   80e220 <raw_sendto>
  80c474:	88 46 0c             	mov    %al,0xc(%esi)
  80c477:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c47a:	83 ec 0c             	sub    $0xc,%esp
  80c47d:	8b 03                	mov    (%ebx),%eax
  80c47f:	ff 70 10             	pushl  0x10(%eax)
  80c482:	e8 e6 de ff ff       	call   80a36d <sys_sem_signal>
}
  80c487:	83 c4 10             	add    $0x10,%esp
  80c48a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c48d:	5b                   	pop    %ebx
  80c48e:	5e                   	pop    %esi
  80c48f:	5f                   	pop    %edi
  80c490:	5d                   	pop    %ebp
  80c491:	c3                   	ret    
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c492:	83 ec 08             	sub    $0x8,%esp
  80c495:	ff 30                	pushl  (%eax)
  80c497:	52                   	push   %edx
  80c498:	e8 93 1e 00 00       	call   80e330 <raw_send>
  80c49d:	88 46 0c             	mov    %al,0xc(%esi)
  80c4a0:	83 c4 10             	add    $0x10,%esp
  80c4a3:	eb d5                	jmp    80c47a <do_send+0x4c>
        if (msg->msg.b->addr == NULL) {
  80c4a5:	8b 43 04             	mov    0x4(%ebx),%eax
  80c4a8:	8b 48 08             	mov    0x8(%eax),%ecx
  80c4ab:	85 c9                	test   %ecx,%ecx
  80c4ad:	74 16                	je     80c4c5 <do_send+0x97>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c4af:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c4b3:	57                   	push   %edi
  80c4b4:	51                   	push   %ecx
  80c4b5:	ff 30                	pushl  (%eax)
  80c4b7:	52                   	push   %edx
  80c4b8:	e8 96 cc ff ff       	call   809153 <udp_sendto>
  80c4bd:	88 46 0c             	mov    %al,0xc(%esi)
  80c4c0:	83 c4 10             	add    $0x10,%esp
  80c4c3:	eb b5                	jmp    80c47a <do_send+0x4c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c4c5:	83 ec 08             	sub    $0x8,%esp
  80c4c8:	ff 30                	pushl  (%eax)
  80c4ca:	52                   	push   %edx
  80c4cb:	e8 c7 cc ff ff       	call   809197 <udp_send>
  80c4d0:	88 46 0c             	mov    %al,0xc(%esi)
  80c4d3:	83 c4 10             	add    $0x10,%esp
  80c4d6:	eb a2                	jmp    80c47a <do_send+0x4c>

0080c4d8 <do_recv>:
{
  80c4d8:	f3 0f 1e fb          	endbr32 
  80c4dc:	55                   	push   %ebp
  80c4dd:	89 e5                	mov    %esp,%ebp
  80c4df:	53                   	push   %ebx
  80c4e0:	83 ec 04             	sub    $0x4,%esp
  80c4e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c4e6:	8b 03                	mov    (%ebx),%eax
  80c4e8:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c4ec:	7c 0c                	jl     80c4fa <do_recv+0x22>
    if (msg->conn->pcb.tcp != NULL) {
  80c4ee:	8b 50 08             	mov    0x8(%eax),%edx
  80c4f1:	85 d2                	test   %edx,%edx
  80c4f3:	74 05                	je     80c4fa <do_recv+0x22>
      if (msg->conn->type == NETCONN_TCP) {
  80c4f5:	83 38 10             	cmpl   $0x10,(%eax)
  80c4f8:	74 15                	je     80c50f <do_recv+0x37>
  TCPIP_APIMSG_ACK(msg);
  80c4fa:	83 ec 0c             	sub    $0xc,%esp
  80c4fd:	8b 03                	mov    (%ebx),%eax
  80c4ff:	ff 70 10             	pushl  0x10(%eax)
  80c502:	e8 66 de ff ff       	call   80a36d <sys_sem_signal>
}
  80c507:	83 c4 10             	add    $0x10,%esp
  80c50a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c50d:	c9                   	leave  
  80c50e:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c50f:	83 ec 08             	sub    $0x8,%esp
  80c512:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c516:	50                   	push   %eax
  80c517:	52                   	push   %edx
  80c518:	e8 45 93 ff ff       	call   805862 <tcp_recved>
  80c51d:	83 c4 10             	add    $0x10,%esp
  80c520:	eb d8                	jmp    80c4fa <do_recv+0x22>

0080c522 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c522:	f3 0f 1e fb          	endbr32 
  80c526:	55                   	push   %ebp
  80c527:	89 e5                	mov    %esp,%ebp
  80c529:	83 ec 08             	sub    $0x8,%esp
  80c52c:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c52f:	8b 02                	mov    (%edx),%eax
  80c531:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c535:	7c 0f                	jl     80c546 <do_write+0x24>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c537:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c53b:	74 05                	je     80c542 <do_write+0x20>
  80c53d:	83 38 10             	cmpl   $0x10,(%eax)
  80c540:	74 16                	je     80c558 <do_write+0x36>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c542:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c546:	83 ec 0c             	sub    $0xc,%esp
  80c549:	8b 02                	mov    (%edx),%eax
  80c54b:	ff 70 10             	pushl  0x10(%eax)
  80c54e:	e8 1a de ff ff       	call   80a36d <sys_sem_signal>
  80c553:	83 c4 10             	add    $0x10,%esp
}
  80c556:	c9                   	leave  
  80c557:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c558:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c55f:	8b 02                	mov    (%edx),%eax
  80c561:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c564:	8b 02                	mov    (%edx),%eax
  80c566:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c56d:	8b 02                	mov    (%edx),%eax
  80c56f:	e8 2f f4 ff ff       	call   80b9a3 <do_writemore>
      return;
  80c574:	eb e0                	jmp    80c556 <do_write+0x34>

0080c576 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c576:	f3 0f 1e fb          	endbr32 
  80c57a:	55                   	push   %ebp
  80c57b:	89 e5                	mov    %esp,%ebp
  80c57d:	83 ec 08             	sub    $0x8,%esp
  80c580:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c583:	8b 08                	mov    (%eax),%ecx
  80c585:	8b 51 08             	mov    0x8(%ecx),%edx
  80c588:	85 d2                	test   %edx,%edx
  80c58a:	0f 84 a8 00 00 00    	je     80c638 <do_getaddr+0xc2>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c590:	8b 48 04             	mov    0x4(%eax),%ecx
  80c593:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c597:	74 2f                	je     80c5c8 <do_getaddr+0x52>
  80c599:	8b 12                	mov    (%edx),%edx
  80c59b:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c59d:	8b 08                	mov    (%eax),%ecx
  80c59f:	8b 11                	mov    (%ecx),%edx
  80c5a1:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c5a7:	83 fa 20             	cmp    $0x20,%edx
  80c5aa:	74 3e                	je     80c5ea <do_getaddr+0x74>
  80c5ac:	83 fa 40             	cmp    $0x40,%edx
  80c5af:	74 1e                	je     80c5cf <do_getaddr+0x59>
  80c5b1:	83 fa 10             	cmp    $0x10,%edx
  80c5b4:	74 64                	je     80c61a <do_getaddr+0xa4>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
  80c5b6:	83 ec 0c             	sub    $0xc,%esp
  80c5b9:	8b 00                	mov    (%eax),%eax
  80c5bb:	ff 70 10             	pushl  0x10(%eax)
  80c5be:	e8 aa dd ff ff       	call   80a36d <sys_sem_signal>
}
  80c5c3:	83 c4 10             	add    $0x10,%esp
  80c5c6:	c9                   	leave  
  80c5c7:	c3                   	ret    
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c5c8:	8b 52 04             	mov    0x4(%edx),%edx
  80c5cb:	89 11                	mov    %edx,(%ecx)
  80c5cd:	eb ce                	jmp    80c59d <do_getaddr+0x27>
      if (msg->msg.ad.local) {
  80c5cf:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c5d3:	74 0f                	je     80c5e4 <do_getaddr+0x6e>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c5d5:	8b 50 08             	mov    0x8(%eax),%edx
  80c5d8:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c5db:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c5df:	66 89 0a             	mov    %cx,(%edx)
  80c5e2:	eb d2                	jmp    80c5b6 <do_getaddr+0x40>
        msg->conn->err = ERR_CONN;
  80c5e4:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c5e8:	eb cc                	jmp    80c5b6 <do_getaddr+0x40>
      if (msg->msg.ad.local) {
  80c5ea:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c5ee:	74 0f                	je     80c5ff <do_getaddr+0x89>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c5f0:	8b 50 08             	mov    0x8(%eax),%edx
  80c5f3:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c5f6:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c5fa:	66 89 0a             	mov    %cx,(%edx)
  80c5fd:	eb b7                	jmp    80c5b6 <do_getaddr+0x40>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c5ff:	8b 51 08             	mov    0x8(%ecx),%edx
  80c602:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c606:	75 06                	jne    80c60e <do_getaddr+0x98>
          msg->conn->err = ERR_CONN;
  80c608:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c60c:	eb a8                	jmp    80c5b6 <do_getaddr+0x40>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c60e:	8b 48 08             	mov    0x8(%eax),%ecx
  80c611:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c615:	66 89 11             	mov    %dx,(%ecx)
  80c618:	eb 9c                	jmp    80c5b6 <do_getaddr+0x40>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c61a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c61e:	74 0f                	je     80c62f <do_getaddr+0xb9>
  80c620:	8b 51 08             	mov    0x8(%ecx),%edx
  80c623:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c627:	8b 50 08             	mov    0x8(%eax),%edx
  80c62a:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c62d:	eb 87                	jmp    80c5b6 <do_getaddr+0x40>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c62f:	8b 51 08             	mov    0x8(%ecx),%edx
  80c632:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c636:	eb ef                	jmp    80c627 <do_getaddr+0xb1>
    msg->conn->err = ERR_CONN;
  80c638:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c63c:	e9 75 ff ff ff       	jmp    80c5b6 <do_getaddr+0x40>

0080c641 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c641:	f3 0f 1e fb          	endbr32 
  80c645:	55                   	push   %ebp
  80c646:	89 e5                	mov    %esp,%ebp
  80c648:	83 ec 08             	sub    $0x8,%esp
  80c64b:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c64e:	8b 02                	mov    (%edx),%eax
  80c650:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c654:	74 05                	je     80c65b <do_close+0x1a>
  80c656:	83 38 10             	cmpl   $0x10,(%eax)
  80c659:	74 16                	je     80c671 <do_close+0x30>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c65b:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c65f:	83 ec 0c             	sub    $0xc,%esp
  80c662:	8b 02                	mov    (%edx),%eax
  80c664:	ff 70 10             	pushl  0x10(%eax)
  80c667:	e8 01 dd ff ff       	call   80a36d <sys_sem_signal>
  80c66c:	83 c4 10             	add    $0x10,%esp
  }
}
  80c66f:	c9                   	leave  
  80c670:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c671:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c678:	8b 02                	mov    (%edx),%eax
  80c67a:	e8 8b f4 ff ff       	call   80bb0a <do_close_internal>
  80c67f:	eb ee                	jmp    80c66f <do_close+0x2e>

0080c681 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c681:	55                   	push   %ebp
  80c682:	89 e5                	mov    %esp,%ebp
  80c684:	57                   	push   %edi
  80c685:	56                   	push   %esi
  80c686:	53                   	push   %ebx
  80c687:	83 ec 18             	sub    $0x18,%esp
  80c68a:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c68c:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c692:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c696:	50                   	push   %eax
  80c697:	e8 c8 b2 ff ff       	call   807964 <ntohs>
  80c69c:	83 c4 10             	add    $0x10,%esp
  80c69f:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c6a3:	0f 86 84 00 00 00    	jbe    80c72d <tcp_parseopt+0xac>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c6a9:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c6ac:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c6b1:	eb 10                	jmp    80c6c3 <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c6b3:	83 c3 01             	add    $0x1,%ebx
  80c6b6:	eb 0b                	jmp    80c6c3 <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c6b8:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c6bd:	84 c0                	test   %al,%al
  80c6bf:	74 6c                	je     80c72d <tcp_parseopt+0xac>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c6c1:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c6c3:	83 ec 0c             	sub    $0xc,%esp
  80c6c6:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c6cb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c6cf:	50                   	push   %eax
  80c6d0:	e8 8f b2 ff ff       	call   807964 <ntohs>
  80c6d5:	0f b6 d3             	movzbl %bl,%edx
  80c6d8:	66 c1 e8 0c          	shr    $0xc,%ax
  80c6dc:	0f b7 c0             	movzwl %ax,%eax
  80c6df:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c6e6:	83 c4 10             	add    $0x10,%esp
  80c6e9:	39 c2                	cmp    %eax,%edx
  80c6eb:	7d 40                	jge    80c72d <tcp_parseopt+0xac>
      opt = opts[c];
  80c6ed:	0f b6 d3             	movzbl %bl,%edx
  80c6f0:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c6f4:	84 c0                	test   %al,%al
  80c6f6:	74 35                	je     80c72d <tcp_parseopt+0xac>
      } else if (opt == 0x01) {
  80c6f8:	3c 01                	cmp    $0x1,%al
  80c6fa:	74 b7                	je     80c6b3 <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c6fc:	3c 02                	cmp    $0x2,%al
  80c6fe:	75 b8                	jne    80c6b8 <tcp_parseopt+0x37>
  80c700:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c705:	75 b1                	jne    80c6b8 <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c707:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
  80c70c:	c1 e1 08             	shl    $0x8,%ecx
  80c70f:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c714:	89 d0                	mov    %edx,%eax
  80c716:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c718:	83 e8 01             	sub    $0x1,%eax
  80c71b:	09 d1                	or     %edx,%ecx
  80c71d:	66 3d b4 05          	cmp    $0x5b4,%ax
  80c721:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80c726:	0f 42 c1             	cmovb  %ecx,%eax
  80c729:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c72d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c730:	5b                   	pop    %ebx
  80c731:	5e                   	pop    %esi
  80c732:	5f                   	pop    %edi
  80c733:	5d                   	pop    %ebp
  80c734:	c3                   	ret    

0080c735 <tcp_receive>:
{
  80c735:	55                   	push   %ebp
  80c736:	89 e5                	mov    %esp,%ebp
  80c738:	57                   	push   %edi
  80c739:	56                   	push   %esi
  80c73a:	53                   	push   %ebx
  80c73b:	83 ec 1c             	sub    $0x1c,%esp
  80c73e:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c740:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c747:	0f 84 24 04 00 00    	je     80cb71 <tcp_receive+0x43c>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c74d:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c751:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c754:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80c759:	39 c2                	cmp    %eax,%edx
  80c75b:	78 53                	js     80c7b0 <tcp_receive+0x7b>
  80c75d:	39 c2                	cmp    %eax,%edx
  80c75f:	74 36                	je     80c797 <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c761:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c767:	39 77 64             	cmp    %esi,0x64(%edi)
  80c76a:	74 38                	je     80c7a4 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c76c:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c76f:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c774:	39 c3                	cmp    %eax,%ebx
  80c776:	74 68                	je     80c7e0 <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c778:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c77b:	39 da                	cmp    %ebx,%edx
  80c77d:	78 0d                	js     80c78c <tcp_receive+0x57>
  80c77f:	89 c2                	mov    %eax,%edx
  80c781:	2b 57 58             	sub    0x58(%edi),%edx
  80c784:	85 d2                	test   %edx,%edx
  80c786:	0f 8e fa 00 00 00    	jle    80c886 <tcp_receive+0x151>
      pcb->acked = 0;
  80c78c:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c792:	e9 c3 02 00 00       	jmp    80ca5a <tcp_receive+0x325>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c797:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c79d:	39 77 64             	cmp    %esi,0x64(%edi)
  80c7a0:	79 bf                	jns    80c761 <tcp_receive+0x2c>
  80c7a2:	eb 0c                	jmp    80c7b0 <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c7a4:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c7aa:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c7ae:	73 bc                	jae    80c76c <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c7b0:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c7b6:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c7ba:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c7be:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c7c1:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c7c6:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c7c9:	66 85 db             	test   %bx,%bx
  80c7cc:	74 9e                	je     80c76c <tcp_receive+0x37>
  80c7ce:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c7d5:	74 95                	je     80c76c <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c7d7:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c7de:	eb 8c                	jmp    80c76c <tcp_receive+0x37>
      pcb->acked = 0;
  80c7e0:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c7e6:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c7ea:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c7ed:	0f b7 c9             	movzwl %cx,%ecx
  80c7f0:	01 ca                	add    %ecx,%edx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c7f2:	39 d0                	cmp    %edx,%eax
  80c7f4:	0f 85 60 02 00 00    	jne    80ca5a <tcp_receive+0x325>
        ++pcb->dupacks;
  80c7fa:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c7fe:	83 c0 01             	add    $0x1,%eax
  80c801:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c804:	3c 02                	cmp    $0x2,%al
  80c806:	0f 86 4e 02 00 00    	jbe    80ca5a <tcp_receive+0x325>
  80c80c:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c810:	0f 84 44 02 00 00    	je     80ca5a <tcp_receive+0x325>
          if (!(pcb->flags & TF_INFR)) {
  80c816:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c81a:	74 1c                	je     80c838 <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c81c:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c820:	89 d0                	mov    %edx,%eax
  80c822:	66 03 47 34          	add    0x34(%edi),%ax
  80c826:	66 39 c2             	cmp    %ax,%dx
  80c829:	0f 83 2b 02 00 00    	jae    80ca5a <tcp_receive+0x325>
              pcb->cwnd += pcb->mss;
  80c82f:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c833:	e9 22 02 00 00       	jmp    80ca5a <tcp_receive+0x325>
            tcp_rexmit(pcb);
  80c838:	83 ec 0c             	sub    $0xc,%esp
  80c83b:	57                   	push   %edi
  80c83c:	e8 c6 c0 ff ff       	call   808907 <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c841:	0f b7 5f 4e          	movzwl 0x4e(%edi),%ebx
  80c845:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c849:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c84c:	89 c2                	mov    %eax,%edx
  80c84e:	66 d1 ea             	shr    %dx
  80c851:	89 d9                	mov    %ebx,%ecx
  80c853:	66 d1 e9             	shr    %cx
  80c856:	66 39 c3             	cmp    %ax,%bx
  80c859:	0f 47 ca             	cmova  %edx,%ecx
            if (pcb->ssthresh < 2*pcb->mss) {
  80c85c:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c860:	0f b7 f1             	movzwl %cx,%esi
  80c863:	0f b7 d8             	movzwl %ax,%ebx
  80c866:	01 db                	add    %ebx,%ebx
              pcb->ssthresh = 2*pcb->mss;
  80c868:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c86b:	39 de                	cmp    %ebx,%esi
  80c86d:	0f 4d d1             	cmovge %ecx,%edx
  80c870:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c874:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c877:	01 d0                	add    %edx,%eax
  80c879:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c87d:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c881:	e9 d4 01 00 00       	jmp    80ca5a <tcp_receive+0x325>
      if (pcb->flags & TF_INFR) {
  80c886:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c88a:	f6 c2 04             	test   $0x4,%dl
  80c88d:	74 0e                	je     80c89d <tcp_receive+0x168>
        pcb->flags &= ~TF_INFR;
  80c88f:	83 e2 fb             	and    $0xfffffffb,%edx
  80c892:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c895:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c899:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c89d:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c8a1:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c8a5:	66 c1 fa 03          	sar    $0x3,%dx
  80c8a9:	66 03 57 42          	add    0x42(%edi),%dx
  80c8ad:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c8b1:	89 c2                	mov    %eax,%edx
  80c8b3:	29 da                	sub    %ebx,%edx
  80c8b5:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c8b9:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c8bd:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c8c1:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c8c4:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c8c8:	76 1d                	jbe    80c8e7 <tcp_receive+0x1b2>
        if (pcb->cwnd < pcb->ssthresh) {
  80c8ca:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c8ce:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c8d2:	0f 83 da 00 00 00    	jae    80c9b2 <tcp_receive+0x27d>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c8d8:	89 c8                	mov    %ecx,%eax
  80c8da:	66 03 47 34          	add    0x34(%edi),%ax
  80c8de:	66 39 c1             	cmp    %ax,%cx
  80c8e1:	73 04                	jae    80c8e7 <tcp_receive+0x1b2>
            pcb->cwnd += pcb->mss;
  80c8e3:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c8e7:	8b 47 78             	mov    0x78(%edi),%eax
  80c8ea:	85 c0                	test   %eax,%eax
  80c8ec:	0f 84 19 01 00 00    	je     80ca0b <tcp_receive+0x2d6>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c8f2:	83 ec 0c             	sub    $0xc,%esp
  80c8f5:	8b 40 10             	mov    0x10(%eax),%eax
  80c8f8:	ff 70 04             	pushl  0x4(%eax)
  80c8fb:	e8 a2 b2 ff ff       	call   807ba2 <ntohl>
  80c900:	89 c3                	mov    %eax,%ebx
  80c902:	8b 47 78             	mov    0x78(%edi),%eax
  80c905:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c909:	8b 40 10             	mov    0x10(%eax),%eax
  80c90c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c910:	89 04 24             	mov    %eax,(%esp)
  80c913:	e8 4c b0 ff ff       	call   807964 <ntohs>
  80c918:	89 c2                	mov    %eax,%edx
  80c91a:	83 c4 10             	add    $0x10,%esp
  80c91d:	b8 01 00 00 00       	mov    $0x1,%eax
  80c922:	f6 c2 01             	test   $0x1,%dl
  80c925:	0f 84 bf 00 00 00    	je     80c9ea <tcp_receive+0x2b5>
  80c92b:	2b 1d a4 b1 b3 00    	sub    0xb3b1a4,%ebx
  80c931:	01 c6                	add    %eax,%esi
  80c933:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c935:	85 db                	test   %ebx,%ebx
  80c937:	0f 8f ce 00 00 00    	jg     80ca0b <tcp_receive+0x2d6>
        next = pcb->unacked;
  80c93d:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c940:	8b 03                	mov    (%ebx),%eax
  80c942:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c945:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c949:	83 ec 0c             	sub    $0xc,%esp
  80c94c:	ff 73 04             	pushl  0x4(%ebx)
  80c94f:	e8 06 85 ff ff       	call   804e5a <pbuf_clen>
  80c954:	0f b6 c0             	movzbl %al,%eax
  80c957:	83 c4 10             	add    $0x10,%esp
  80c95a:	66 39 c6             	cmp    %ax,%si
  80c95d:	72 74                	jb     80c9d3 <tcp_receive+0x29e>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c95f:	83 ec 0c             	sub    $0xc,%esp
  80c962:	ff 73 04             	pushl  0x4(%ebx)
  80c965:	e8 f0 84 ff ff       	call   804e5a <pbuf_clen>
  80c96a:	0f b6 c0             	movzbl %al,%eax
  80c96d:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c971:	89 1c 24             	mov    %ebx,(%esp)
  80c974:	e8 f8 8f ff ff       	call   805971 <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c979:	83 c4 10             	add    $0x10,%esp
  80c97c:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c981:	0f 84 60 ff ff ff    	je     80c8e7 <tcp_receive+0x1b2>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c987:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c98b:	0f 85 56 ff ff ff    	jne    80c8e7 <tcp_receive+0x1b2>
  80c991:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c995:	0f 85 4c ff ff ff    	jne    80c8e7 <tcp_receive+0x1b2>
  80c99b:	83 ec 04             	sub    $0x4,%esp
  80c99e:	68 10 34 81 00       	push   $0x813410
  80c9a3:	68 5b 03 00 00       	push   $0x35b
  80c9a8:	68 54 35 81 00       	push   $0x813554
  80c9ad:	e8 85 1f 00 00       	call   80e937 <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c9b2:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c9b6:	0f af c0             	imul   %eax,%eax
  80c9b9:	0f b7 d9             	movzwl %cx,%ebx
  80c9bc:	99                   	cltd   
  80c9bd:	f7 fb                	idiv   %ebx
  80c9bf:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c9c1:	66 39 c1             	cmp    %ax,%cx
  80c9c4:	0f 83 1d ff ff ff    	jae    80c8e7 <tcp_receive+0x1b2>
            pcb->cwnd = new_cwnd;
  80c9ca:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c9ce:	e9 14 ff ff ff       	jmp    80c8e7 <tcp_receive+0x1b2>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c9d3:	83 ec 04             	sub    $0x4,%esp
  80c9d6:	68 e8 33 81 00       	push   $0x8133e8
  80c9db:	68 55 03 00 00       	push   $0x355
  80c9e0:	68 54 35 81 00       	push   $0x813554
  80c9e5:	e8 4d 1f 00 00       	call   80e937 <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c9ea:	83 ec 0c             	sub    $0xc,%esp
  80c9ed:	8b 47 78             	mov    0x78(%edi),%eax
  80c9f0:	8b 40 10             	mov    0x10(%eax),%eax
  80c9f3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9f7:	50                   	push   %eax
  80c9f8:	e8 67 af ff ff       	call   807964 <ntohs>
  80c9fd:	66 d1 e8             	shr    %ax
  80ca00:	83 e0 01             	and    $0x1,%eax
  80ca03:	83 c4 10             	add    $0x10,%esp
  80ca06:	e9 20 ff ff ff       	jmp    80c92b <tcp_receive+0x1f6>
      if(pcb->unacked == NULL)
  80ca0b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80ca0f:	0f 94 c0             	sete   %al
  80ca12:	0f b6 c0             	movzbl %al,%eax
  80ca15:	f7 d8                	neg    %eax
  80ca17:	66 89 47 32          	mov    %ax,0x32(%edi)
      pcb->polltmr = 0;
  80ca1b:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80ca1f:	eb 39                	jmp    80ca5a <tcp_receive+0x325>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80ca21:	83 ec 04             	sub    $0x4,%esp
  80ca24:	68 e8 33 81 00       	push   $0x8133e8
  80ca29:	68 7f 03 00 00       	push   $0x37f
  80ca2e:	68 54 35 81 00       	push   $0x813554
  80ca33:	e8 ff 1e 00 00       	call   80e937 <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80ca38:	83 ec 04             	sub    $0x4,%esp
  80ca3b:	68 10 34 81 00       	push   $0x813410
  80ca40:	68 84 03 00 00       	push   $0x384
  80ca45:	68 54 35 81 00       	push   $0x813554
  80ca4a:	e8 e8 1e 00 00       	call   80e937 <_panic>
      if (pcb->unsent != NULL) {
  80ca4f:	8b 47 74             	mov    0x74(%edi),%eax
  80ca52:	85 c0                	test   %eax,%eax
  80ca54:	0f 85 cb 00 00 00    	jne    80cb25 <tcp_receive+0x3f0>
    while (pcb->unsent != NULL &&
  80ca5a:	8b 47 74             	mov    0x74(%edi),%eax
  80ca5d:	85 c0                	test   %eax,%eax
  80ca5f:	0f 84 fa 00 00 00    	je     80cb5f <tcp_receive+0x42a>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80ca65:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80ca6b:	83 ec 0c             	sub    $0xc,%esp
  80ca6e:	8b 40 10             	mov    0x10(%eax),%eax
  80ca71:	ff 70 04             	pushl  0x4(%eax)
  80ca74:	e8 29 b1 ff ff       	call   807ba2 <ntohl>
  80ca79:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ca7c:	8b 47 74             	mov    0x74(%edi),%eax
  80ca7f:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80ca83:	8b 40 10             	mov    0x10(%eax),%eax
  80ca86:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca8a:	89 04 24             	mov    %eax,(%esp)
  80ca8d:	e8 d2 ae ff ff       	call   807964 <ntohs>
  80ca92:	89 c2                	mov    %eax,%edx
  80ca94:	83 c4 10             	add    $0x10,%esp
  80ca97:	b8 01 00 00 00       	mov    $0x1,%eax
  80ca9c:	f6 c2 01             	test   $0x1,%dl
  80ca9f:	0f 84 99 00 00 00    	je     80cb3e <tcp_receive+0x409>
  80caa5:	2b 75 e4             	sub    -0x1c(%ebp),%esi
  80caa8:	01 c3                	add    %eax,%ebx
    while (pcb->unsent != NULL &&
  80caaa:	39 de                	cmp    %ebx,%esi
  80caac:	0f 88 ad 00 00 00    	js     80cb5f <tcp_receive+0x42a>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80cab2:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80cab7:	2b 47 58             	sub    0x58(%edi),%eax
  80caba:	85 c0                	test   %eax,%eax
  80cabc:	0f 8f 9d 00 00 00    	jg     80cb5f <tcp_receive+0x42a>
      next = pcb->unsent;
  80cac2:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80cac5:	8b 03                	mov    (%ebx),%eax
  80cac7:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80caca:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80cace:	83 ec 0c             	sub    $0xc,%esp
  80cad1:	ff 73 04             	pushl  0x4(%ebx)
  80cad4:	e8 81 83 ff ff       	call   804e5a <pbuf_clen>
  80cad9:	0f b6 c0             	movzbl %al,%eax
  80cadc:	83 c4 10             	add    $0x10,%esp
  80cadf:	66 39 c6             	cmp    %ax,%si
  80cae2:	0f 82 39 ff ff ff    	jb     80ca21 <tcp_receive+0x2ec>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80cae8:	83 ec 0c             	sub    $0xc,%esp
  80caeb:	ff 73 04             	pushl  0x4(%ebx)
  80caee:	e8 67 83 ff ff       	call   804e5a <pbuf_clen>
  80caf3:	0f b6 c0             	movzbl %al,%eax
  80caf6:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80cafa:	89 1c 24             	mov    %ebx,(%esp)
  80cafd:	e8 6f 8e ff ff       	call   805971 <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80cb02:	83 c4 10             	add    $0x10,%esp
  80cb05:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80cb0a:	0f 84 3f ff ff ff    	je     80ca4f <tcp_receive+0x31a>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80cb10:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80cb14:	0f 85 35 ff ff ff    	jne    80ca4f <tcp_receive+0x31a>
  80cb1a:	8b 47 74             	mov    0x74(%edi),%eax
  80cb1d:	85 c0                	test   %eax,%eax
  80cb1f:	0f 84 13 ff ff ff    	je     80ca38 <tcp_receive+0x303>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80cb25:	83 ec 0c             	sub    $0xc,%esp
  80cb28:	8b 40 10             	mov    0x10(%eax),%eax
  80cb2b:	ff 70 04             	pushl  0x4(%eax)
  80cb2e:	e8 42 ae ff ff       	call   807975 <htonl>
  80cb33:	89 47 54             	mov    %eax,0x54(%edi)
  80cb36:	83 c4 10             	add    $0x10,%esp
  80cb39:	e9 1c ff ff ff       	jmp    80ca5a <tcp_receive+0x325>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80cb3e:	83 ec 0c             	sub    $0xc,%esp
  80cb41:	8b 47 74             	mov    0x74(%edi),%eax
  80cb44:	8b 40 10             	mov    0x10(%eax),%eax
  80cb47:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb4b:	50                   	push   %eax
  80cb4c:	e8 13 ae ff ff       	call   807964 <ntohs>
  80cb51:	66 d1 e8             	shr    %ax
  80cb54:	83 e0 01             	and    $0x1,%eax
  80cb57:	83 c4 10             	add    $0x10,%esp
  80cb5a:	e9 46 ff ff ff       	jmp    80caa5 <tcp_receive+0x370>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80cb5f:	8b 47 38             	mov    0x38(%edi),%eax
  80cb62:	85 c0                	test   %eax,%eax
  80cb64:	74 0b                	je     80cb71 <tcp_receive+0x43c>
  80cb66:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80cb6c:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80cb6f:	78 70                	js     80cbe1 <tcp_receive+0x4ac>
  if (tcplen > 0) {
  80cb71:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80cb78:	66 85 c0             	test   %ax,%ax
  80cb7b:	0f 84 57 08 00 00    	je     80d3d8 <tcp_receive+0xca3>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80cb81:	8b 5f 24             	mov    0x24(%edi),%ebx
  80cb84:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cb8a:	89 d9                	mov    %ebx,%ecx
  80cb8c:	29 d1                	sub    %edx,%ecx
  80cb8e:	89 ce                	mov    %ecx,%esi
  80cb90:	83 ee 01             	sub    $0x1,%esi
  80cb93:	78 16                	js     80cbab <tcp_receive+0x476>
  80cb95:	be 01 00 00 00       	mov    $0x1,%esi
  80cb9a:	29 d6                	sub    %edx,%esi
  80cb9c:	0f b7 c0             	movzwl %ax,%eax
  80cb9f:	29 c6                	sub    %eax,%esi
  80cba1:	01 de                	add    %ebx,%esi
  80cba3:	85 f6                	test   %esi,%esi
  80cba5:	0f 8e 84 00 00 00    	jle    80cc2f <tcp_receive+0x4fa>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80cbab:	39 da                	cmp    %ebx,%edx
  80cbad:	0f 88 bd 01 00 00    	js     80cd70 <tcp_receive+0x63b>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80cbb3:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80cbb7:	89 d1                	mov    %edx,%ecx
  80cbb9:	29 c1                	sub    %eax,%ecx
  80cbbb:	8d 41 01             	lea    0x1(%ecx),%eax
  80cbbe:	29 d8                	sub    %ebx,%eax
  80cbc0:	85 c0                	test   %eax,%eax
  80cbc2:	0f 8e bd 01 00 00    	jle    80cd85 <tcp_receive+0x650>
      tcp_ack_now(pcb);
  80cbc8:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cbcc:	83 ec 0c             	sub    $0xc,%esp
  80cbcf:	57                   	push   %edi
  80cbd0:	e8 04 b7 ff ff       	call   8082d9 <tcp_output>
  80cbd5:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cbd8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cbdc:	e9 2a 08 00 00       	jmp    80d40b <tcp_receive+0xcd6>
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80cbe1:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
      m = m - (pcb->sa >> 3);
  80cbe7:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80cbeb:	89 d3                	mov    %edx,%ebx
  80cbed:	66 c1 fb 03          	sar    $0x3,%bx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80cbf1:	89 f1                	mov    %esi,%ecx
  80cbf3:	29 c1                	sub    %eax,%ecx
      m = m - (pcb->sa >> 3);
  80cbf5:	29 d9                	sub    %ebx,%ecx
      pcb->sa += m;
  80cbf7:	01 ca                	add    %ecx,%edx
  80cbf9:	66 89 57 40          	mov    %dx,0x40(%edi)
        m = -m;
  80cbfd:	29 f0                	sub    %esi,%eax
  80cbff:	01 d8                	add    %ebx,%eax
  80cc01:	66 85 c9             	test   %cx,%cx
  80cc04:	0f 49 c1             	cmovns %ecx,%eax
      m = m - (pcb->sv >> 2);
  80cc07:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80cc0b:	89 cb                	mov    %ecx,%ebx
  80cc0d:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80cc11:	29 d9                	sub    %ebx,%ecx
  80cc13:	01 c8                	add    %ecx,%eax
  80cc15:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80cc19:	66 c1 fa 03          	sar    $0x3,%dx
  80cc1d:	01 d0                	add    %edx,%eax
  80cc1f:	66 89 47 44          	mov    %ax,0x44(%edi)
      pcb->rttest = 0;
  80cc23:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80cc2a:	e9 42 ff ff ff       	jmp    80cb71 <tcp_receive+0x43c>
      off = pcb->rcv_nxt - seqno;
  80cc2f:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80cc31:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80cc37:	85 db                	test   %ebx,%ebx
  80cc39:	0f 84 a4 00 00 00    	je     80cce3 <tcp_receive+0x5ae>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80cc3f:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80cc45:	0f 8f af 00 00 00    	jg     80ccfa <tcp_receive+0x5c5>
      if (inseg.p->len < off) {
  80cc4b:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80cc4f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80cc52:	39 ca                	cmp    %ecx,%edx
  80cc54:	0f 8d e5 00 00 00    	jge    80cd3f <tcp_receive+0x60a>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80cc5a:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80cc5e:	0f b7 d6             	movzwl %si,%edx
  80cc61:	39 ca                	cmp    %ecx,%edx
  80cc63:	0f 8c a8 00 00 00    	jl     80cd11 <tcp_receive+0x5dc>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80cc69:	29 ce                	sub    %ecx,%esi
  80cc6b:	89 f1                	mov    %esi,%ecx
  80cc6d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
          off -= p->len;
  80cc70:	29 d0                	sub    %edx,%eax
          p->tot_len = new_tot_len;
  80cc72:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80cc76:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80cc7c:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80cc7e:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80cc82:	39 c2                	cmp    %eax,%edx
  80cc84:	7c ea                	jl     80cc70 <tcp_receive+0x53b>
        if(pbuf_header(p, (s16_t)-off)) {
  80cc86:	83 ec 08             	sub    $0x8,%esp
  80cc89:	f7 d8                	neg    %eax
  80cc8b:	98                   	cwtl   
  80cc8c:	50                   	push   %eax
  80cc8d:	53                   	push   %ebx
  80cc8e:	e8 b5 7c ff ff       	call   804948 <pbuf_header>
  80cc93:	83 c4 10             	add    $0x10,%esp
  80cc96:	84 c0                	test   %al,%al
  80cc98:	0f 85 8a 00 00 00    	jne    80cd28 <tcp_receive+0x5f3>
      inseg.dataptr = p->payload;
  80cc9e:	8b 43 04             	mov    0x4(%ebx),%eax
  80cca1:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80cca6:	8b 57 24             	mov    0x24(%edi),%edx
  80cca9:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80ccb0:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80ccb7:	29 d0                	sub    %edx,%eax
  80ccb9:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80ccbf:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80ccc5:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ccca:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80cccd:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80ccd3:	8b 5f 24             	mov    0x24(%edi),%ebx
  80ccd6:	39 da                	cmp    %ebx,%edx
  80ccd8:	0f 88 ea fe ff ff    	js     80cbc8 <tcp_receive+0x493>
  80ccde:	e9 d0 fe ff ff       	jmp    80cbb3 <tcp_receive+0x47e>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80cce3:	83 ec 04             	sub    $0x4,%esp
  80cce6:	68 6b 35 81 00       	push   $0x81356b
  80cceb:	68 e5 03 00 00       	push   $0x3e5
  80ccf0:	68 54 35 81 00       	push   $0x813554
  80ccf5:	e8 3d 1c 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80ccfa:	83 ec 04             	sub    $0x4,%esp
  80ccfd:	68 7b 35 81 00       	push   $0x81357b
  80cd02:	68 e6 03 00 00       	push   $0x3e6
  80cd07:	68 54 35 81 00       	push   $0x813554
  80cd0c:	e8 26 1c 00 00       	call   80e937 <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80cd11:	83 ec 04             	sub    $0x4,%esp
  80cd14:	68 8a 35 81 00       	push   $0x81358a
  80cd19:	68 e8 03 00 00       	push   $0x3e8
  80cd1e:	68 54 35 81 00       	push   $0x813554
  80cd23:	e8 0f 1c 00 00       	call   80e937 <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80cd28:	83 ec 04             	sub    $0x4,%esp
  80cd2b:	68 9a 35 81 00       	push   $0x81359a
  80cd30:	68 f5 03 00 00       	push   $0x3f5
  80cd35:	68 54 35 81 00       	push   $0x813554
  80cd3a:	e8 f8 1b 00 00       	call   80e937 <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80cd3f:	83 ec 08             	sub    $0x8,%esp
  80cd42:	f7 d9                	neg    %ecx
  80cd44:	0f bf c1             	movswl %cx,%eax
  80cd47:	50                   	push   %eax
  80cd48:	53                   	push   %ebx
  80cd49:	e8 fa 7b ff ff       	call   804948 <pbuf_header>
  80cd4e:	83 c4 10             	add    $0x10,%esp
  80cd51:	84 c0                	test   %al,%al
  80cd53:	0f 84 45 ff ff ff    	je     80cc9e <tcp_receive+0x569>
          LWIP_ASSERT("pbuf_header failed", 0);
  80cd59:	83 ec 04             	sub    $0x4,%esp
  80cd5c:	68 9a 35 81 00       	push   $0x81359a
  80cd61:	68 fa 03 00 00       	push   $0x3fa
  80cd66:	68 54 35 81 00       	push   $0x813554
  80cd6b:	e8 c7 1b 00 00       	call   80e937 <_panic>
        tcp_ack_now(pcb);
  80cd70:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cd74:	83 ec 0c             	sub    $0xc,%esp
  80cd77:	57                   	push   %edi
  80cd78:	e8 5c b5 ff ff       	call   8082d9 <tcp_output>
  80cd7d:	83 c4 10             	add    $0x10,%esp
  80cd80:	e9 48 ff ff ff       	jmp    80cccd <tcp_receive+0x598>
      if (pcb->rcv_nxt == seqno) {
  80cd85:	39 da                	cmp    %ebx,%edx
  80cd87:	0f 85 d7 03 00 00    	jne    80d164 <tcp_receive+0xa2f>
        if (pcb->ooseq != NULL &&
  80cd8d:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cd90:	85 c0                	test   %eax,%eax
  80cd92:	74 1d                	je     80cdb1 <tcp_receive+0x67c>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80cd94:	8b 48 10             	mov    0x10(%eax),%ecx
  80cd97:	8b 59 04             	mov    0x4(%ecx),%ebx
  80cd9a:	0f b7 0d c0 b1 b3 00 	movzwl 0xb3b1c0,%ecx
  80cda1:	89 de                	mov    %ebx,%esi
  80cda3:	29 ce                	sub    %ecx,%esi
  80cda5:	89 f1                	mov    %esi,%ecx
  80cda7:	29 d1                	sub    %edx,%ecx
        if (pcb->ooseq != NULL &&
  80cda9:	85 c9                	test   %ecx,%ecx
  80cdab:	0f 8e b2 00 00 00    	jle    80ce63 <tcp_receive+0x72e>
        tcplen = TCP_TCPLEN(&inseg);
  80cdb1:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80cdb8:	83 ec 0c             	sub    $0xc,%esp
  80cdbb:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cdc0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cdc4:	50                   	push   %eax
  80cdc5:	e8 9a ab ff ff       	call   807964 <ntohs>
  80cdca:	89 c2                	mov    %eax,%edx
  80cdcc:	83 c4 10             	add    $0x10,%esp
  80cdcf:	b8 01 00 00 00       	mov    $0x1,%eax
  80cdd4:	f6 c2 01             	test   $0x1,%dl
  80cdd7:	0f 84 ff 00 00 00    	je     80cedc <tcp_receive+0x7a7>
  80cddd:	01 d8                	add    %ebx,%eax
  80cddf:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
        if (pcb->state != CLOSE_WAIT) {
  80cde5:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80cde9:	74 06                	je     80cdf1 <tcp_receive+0x6bc>
          pcb->rcv_nxt += tcplen;
  80cdeb:	0f b7 d0             	movzwl %ax,%edx
  80cdee:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80cdf1:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
          pcb->rcv_wnd -= tcplen;
  80cdf5:	89 ca                	mov    %ecx,%edx
  80cdf7:	29 c2                	sub    %eax,%edx
  80cdf9:	66 39 c8             	cmp    %cx,%ax
  80cdfc:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ce01:	0f 47 d1             	cmova  %ecx,%edx
  80ce04:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80ce08:	0f b7 4f 2a          	movzwl 0x2a(%edi),%ecx
          pcb->rcv_ann_wnd -= tcplen;
  80ce0c:	89 ca                	mov    %ecx,%edx
  80ce0e:	29 c2                	sub    %eax,%edx
  80ce10:	66 39 c8             	cmp    %cx,%ax
  80ce13:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce18:	0f 46 c2             	cmovbe %edx,%eax
  80ce1b:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80ce1f:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80ce24:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ce29:	74 0f                	je     80ce3a <tcp_receive+0x705>
          recv_data = inseg.p;
  80ce2b:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          inseg.p = NULL;
  80ce30:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80ce37:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80ce3a:	83 ec 0c             	sub    $0xc,%esp
  80ce3d:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ce42:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce46:	50                   	push   %eax
  80ce47:	e8 18 ab ff ff       	call   807964 <ntohs>
  80ce4c:	83 c4 10             	add    $0x10,%esp
  80ce4f:	a8 01                	test   $0x1,%al
  80ce51:	0f 84 d6 01 00 00    	je     80d02d <tcp_receive+0x8f8>
          recv_flags = TF_GOT_FIN;
  80ce57:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80ce5e:	e9 ca 01 00 00       	jmp    80d02d <tcp_receive+0x8f8>
          if (pcb->ooseq->len > 0) {
  80ce63:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80ce68:	74 23                	je     80ce8d <tcp_receive+0x758>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80ce6a:	29 d3                	sub    %edx,%ebx
  80ce6c:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80ce73:	83 ec 08             	sub    $0x8,%esp
  80ce76:	0f b7 db             	movzwl %bx,%ebx
  80ce79:	53                   	push   %ebx
  80ce7a:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80ce80:	e8 bf 7e ff ff       	call   804d44 <pbuf_realloc>
  80ce85:	83 c4 10             	add    $0x10,%esp
  80ce88:	e9 24 ff ff ff       	jmp    80cdb1 <tcp_receive+0x67c>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80ce8d:	83 ec 0c             	sub    $0xc,%esp
  80ce90:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ce95:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce99:	50                   	push   %eax
  80ce9a:	e8 c5 aa ff ff       	call   807964 <ntohs>
  80ce9f:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80cea1:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cea4:	8b 40 10             	mov    0x10(%eax),%eax
  80cea7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ceab:	89 04 24             	mov    %eax,(%esp)
  80ceae:	e8 b1 aa ff ff       	call   807964 <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80ceb3:	31 c3                	xor    %eax,%ebx
  80ceb5:	83 c4 10             	add    $0x10,%esp
  80ceb8:	f6 c3 03             	test   $0x3,%bl
  80cebb:	0f 85 f0 fe ff ff    	jne    80cdb1 <tcp_receive+0x67c>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80cec1:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80cec4:	8b 10                	mov    (%eax),%edx
  80cec6:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80cec9:	83 ec 08             	sub    $0x8,%esp
  80cecc:	50                   	push   %eax
  80cecd:	6a 04                	push   $0x4
  80cecf:	e8 c4 77 ff ff       	call   804698 <memp_free>
  80ced4:	83 c4 10             	add    $0x10,%esp
  80ced7:	e9 d5 fe ff ff       	jmp    80cdb1 <tcp_receive+0x67c>
        tcplen = TCP_TCPLEN(&inseg);
  80cedc:	83 ec 0c             	sub    $0xc,%esp
  80cedf:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cee4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cee8:	50                   	push   %eax
  80cee9:	e8 76 aa ff ff       	call   807964 <ntohs>
  80ceee:	66 d1 e8             	shr    %ax
  80cef1:	83 e0 01             	and    $0x1,%eax
  80cef4:	83 c4 10             	add    $0x10,%esp
  80cef7:	e9 e1 fe ff ff       	jmp    80cddd <tcp_receive+0x6a8>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cefc:	83 ec 0c             	sub    $0xc,%esp
  80ceff:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf02:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf06:	50                   	push   %eax
  80cf07:	e8 58 aa ff ff       	call   807964 <ntohs>
  80cf0c:	66 d1 e8             	shr    %ax
  80cf0f:	83 e0 01             	and    $0x1,%eax
  80cf12:	83 c4 10             	add    $0x10,%esp
  80cf15:	e9 56 01 00 00       	jmp    80d070 <tcp_receive+0x93b>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cf1a:	83 ec 0c             	sub    $0xc,%esp
  80cf1d:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf20:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf24:	50                   	push   %eax
  80cf25:	e8 3a aa ff ff       	call   807964 <ntohs>
  80cf2a:	66 d1 e8             	shr    %ax
  80cf2d:	83 e0 01             	and    $0x1,%eax
  80cf30:	83 c4 10             	add    $0x10,%esp
  80cf33:	e9 6b 01 00 00       	jmp    80d0a3 <tcp_receive+0x96e>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80cf38:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cf3c:	83 ec 0c             	sub    $0xc,%esp
  80cf3f:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf42:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf46:	50                   	push   %eax
  80cf47:	e8 18 aa ff ff       	call   807964 <ntohs>
  80cf4c:	89 c2                	mov    %eax,%edx
  80cf4e:	83 c4 10             	add    $0x10,%esp
  80cf51:	b8 01 00 00 00       	mov    $0x1,%eax
  80cf56:	f6 c2 01             	test   $0x1,%dl
  80cf59:	74 0b                	je     80cf66 <tcp_receive+0x831>
  80cf5b:	01 c6                	add    %eax,%esi
  80cf5d:	66 29 77 28          	sub    %si,0x28(%edi)
  80cf61:	e9 4e 01 00 00       	jmp    80d0b4 <tcp_receive+0x97f>
  80cf66:	83 ec 0c             	sub    $0xc,%esp
  80cf69:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf6c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf70:	50                   	push   %eax
  80cf71:	e8 ee a9 ff ff       	call   807964 <ntohs>
  80cf76:	66 d1 e8             	shr    %ax
  80cf79:	83 e0 01             	and    $0x1,%eax
  80cf7c:	83 c4 10             	add    $0x10,%esp
  80cf7f:	eb da                	jmp    80cf5b <tcp_receive+0x826>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cf81:	83 ec 0c             	sub    $0xc,%esp
  80cf84:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf87:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf8b:	50                   	push   %eax
  80cf8c:	e8 d3 a9 ff ff       	call   807964 <ntohs>
  80cf91:	66 d1 e8             	shr    %ax
  80cf94:	83 e0 01             	and    $0x1,%eax
  80cf97:	83 c4 10             	add    $0x10,%esp
  80cf9a:	e9 43 01 00 00       	jmp    80d0e2 <tcp_receive+0x9ad>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cf9f:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cfa3:	83 ec 0c             	sub    $0xc,%esp
  80cfa6:	8b 43 10             	mov    0x10(%ebx),%eax
  80cfa9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cfad:	50                   	push   %eax
  80cfae:	e8 b1 a9 ff ff       	call   807964 <ntohs>
  80cfb3:	89 c2                	mov    %eax,%edx
  80cfb5:	83 c4 10             	add    $0x10,%esp
  80cfb8:	b8 01 00 00 00       	mov    $0x1,%eax
  80cfbd:	f6 c2 01             	test   $0x1,%dl
  80cfc0:	74 0b                	je     80cfcd <tcp_receive+0x898>
  80cfc2:	01 c6                	add    %eax,%esi
  80cfc4:	66 29 77 2a          	sub    %si,0x2a(%edi)
  80cfc8:	e9 26 01 00 00       	jmp    80d0f3 <tcp_receive+0x9be>
  80cfcd:	83 ec 0c             	sub    $0xc,%esp
  80cfd0:	8b 43 10             	mov    0x10(%ebx),%eax
  80cfd3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cfd7:	50                   	push   %eax
  80cfd8:	e8 87 a9 ff ff       	call   807964 <ntohs>
  80cfdd:	66 d1 e8             	shr    %ax
  80cfe0:	83 e0 01             	and    $0x1,%eax
  80cfe3:	83 c4 10             	add    $0x10,%esp
  80cfe6:	eb da                	jmp    80cfc2 <tcp_receive+0x88d>
              recv_data = cseg->p;
  80cfe8:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
            cseg->p = NULL;
  80cfed:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cff4:	83 ec 0c             	sub    $0xc,%esp
  80cff7:	8b 43 10             	mov    0x10(%ebx),%eax
  80cffa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cffe:	50                   	push   %eax
  80cfff:	e8 60 a9 ff ff       	call   807964 <ntohs>
  80d004:	83 c4 10             	add    $0x10,%esp
  80d007:	a8 01                	test   $0x1,%al
  80d009:	74 11                	je     80d01c <tcp_receive+0x8e7>
            recv_flags = TF_GOT_FIN;
  80d00b:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80d012:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80d016:	0f 84 05 01 00 00    	je     80d121 <tcp_receive+0x9ec>
          pcb->ooseq = cseg->next;
  80d01c:	8b 03                	mov    (%ebx),%eax
  80d01e:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80d021:	83 ec 0c             	sub    $0xc,%esp
  80d024:	53                   	push   %ebx
  80d025:	e8 47 89 ff ff       	call   805971 <tcp_seg_free>
  80d02a:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80d02d:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d030:	85 db                	test   %ebx,%ebx
  80d032:	0f 84 f5 00 00 00    	je     80d12d <tcp_receive+0x9f8>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80d038:	8b 53 10             	mov    0x10(%ebx),%edx
  80d03b:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80d03e:	3b 47 24             	cmp    0x24(%edi),%eax
  80d041:	0f 85 e6 00 00 00    	jne    80d12d <tcp_receive+0x9f8>
          seqno = pcb->ooseq->tcphdr->seqno;
  80d047:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80d04c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d050:	83 ec 0c             	sub    $0xc,%esp
  80d053:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80d057:	50                   	push   %eax
  80d058:	e8 07 a9 ff ff       	call   807964 <ntohs>
  80d05d:	89 c2                	mov    %eax,%edx
  80d05f:	83 c4 10             	add    $0x10,%esp
  80d062:	b8 01 00 00 00       	mov    $0x1,%eax
  80d067:	f6 c2 01             	test   $0x1,%dl
  80d06a:	0f 84 8c fe ff ff    	je     80cefc <tcp_receive+0x7c7>
  80d070:	01 c6                	add    %eax,%esi
  80d072:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80d075:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80d079:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d07c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d080:	83 ec 0c             	sub    $0xc,%esp
  80d083:	8b 43 10             	mov    0x10(%ebx),%eax
  80d086:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d08a:	50                   	push   %eax
  80d08b:	e8 d4 a8 ff ff       	call   807964 <ntohs>
  80d090:	89 c2                	mov    %eax,%edx
  80d092:	83 c4 10             	add    $0x10,%esp
  80d095:	b8 01 00 00 00       	mov    $0x1,%eax
  80d09a:	f6 c2 01             	test   $0x1,%dl
  80d09d:	0f 84 77 fe ff ff    	je     80cf1a <tcp_receive+0x7e5>
  80d0a3:	01 c6                	add    %eax,%esi
  80d0a5:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d0a8:	0f 8d 8a fe ff ff    	jge    80cf38 <tcp_receive+0x803>
            pcb->rcv_wnd = 0;
  80d0ae:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80d0b4:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80d0b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d0bb:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d0bf:	83 ec 0c             	sub    $0xc,%esp
  80d0c2:	8b 43 10             	mov    0x10(%ebx),%eax
  80d0c5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d0c9:	50                   	push   %eax
  80d0ca:	e8 95 a8 ff ff       	call   807964 <ntohs>
  80d0cf:	89 c2                	mov    %eax,%edx
  80d0d1:	83 c4 10             	add    $0x10,%esp
  80d0d4:	b8 01 00 00 00       	mov    $0x1,%eax
  80d0d9:	f6 c2 01             	test   $0x1,%dl
  80d0dc:	0f 84 9f fe ff ff    	je     80cf81 <tcp_receive+0x84c>
  80d0e2:	01 c6                	add    %eax,%esi
  80d0e4:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d0e7:	0f 8d b2 fe ff ff    	jge    80cf9f <tcp_receive+0x86a>
            pcb->rcv_ann_wnd = 0;
  80d0ed:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80d0f3:	8b 43 04             	mov    0x4(%ebx),%eax
  80d0f6:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d0fb:	0f 84 f3 fe ff ff    	je     80cff4 <tcp_receive+0x8bf>
            if (recv_data) {
  80d101:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80d107:	85 d2                	test   %edx,%edx
  80d109:	0f 84 d9 fe ff ff    	je     80cfe8 <tcp_receive+0x8b3>
              pbuf_cat(recv_data, cseg->p);
  80d10f:	83 ec 08             	sub    $0x8,%esp
  80d112:	50                   	push   %eax
  80d113:	52                   	push   %edx
  80d114:	e8 74 7d ff ff       	call   804e8d <pbuf_cat>
  80d119:	83 c4 10             	add    $0x10,%esp
  80d11c:	e9 cc fe ff ff       	jmp    80cfed <tcp_receive+0x8b8>
              pcb->state = CLOSE_WAIT;
  80d121:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80d128:	e9 ef fe ff ff       	jmp    80d01c <tcp_receive+0x8e7>
        tcp_ack(pcb);
  80d12d:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80d131:	89 c1                	mov    %eax,%ecx
  80d133:	83 e1 01             	and    $0x1,%ecx
  80d136:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  80d139:	75 0f                	jne    80d14a <tcp_receive+0xa15>
  80d13b:	83 c8 01             	or     $0x1,%eax
  80d13e:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80d141:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  80d145:	e9 c1 02 00 00       	jmp    80d40b <tcp_receive+0xcd6>
        tcp_ack(pcb);
  80d14a:	83 e0 fe             	and    $0xfffffffe,%eax
  80d14d:	83 c8 02             	or     $0x2,%eax
  80d150:	88 47 20             	mov    %al,0x20(%edi)
  80d153:	83 ec 0c             	sub    $0xc,%esp
  80d156:	57                   	push   %edi
  80d157:	e8 7d b1 ff ff       	call   8082d9 <tcp_output>
  80d15c:	83 c4 10             	add    $0x10,%esp
  80d15f:	e9 a7 02 00 00       	jmp    80d40b <tcp_receive+0xcd6>
        tcp_ack_now(pcb);
  80d164:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d168:	83 ec 0c             	sub    $0xc,%esp
  80d16b:	57                   	push   %edi
  80d16c:	e8 68 b1 ff ff       	call   8082d9 <tcp_output>
        if (pcb->ooseq == NULL) {
  80d171:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d174:	83 c4 10             	add    $0x10,%esp
  80d177:	85 db                	test   %ebx,%ebx
  80d179:	74 1e                	je     80d199 <tcp_receive+0xa64>
            if (seqno == next->tcphdr->seqno) {
  80d17b:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80d181:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80d184:	8d 51 01             	lea    0x1(%ecx),%edx
  80d187:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80d18a:	be 00 00 00 00       	mov    $0x0,%esi
  80d18f:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80d192:	89 c7                	mov    %eax,%edi
  80d194:	e9 d7 00 00 00       	jmp    80d270 <tcp_receive+0xb3b>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80d199:	83 ec 0c             	sub    $0xc,%esp
  80d19c:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d1a1:	e8 50 88 ff ff       	call   8059f6 <tcp_seg_copy>
  80d1a6:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d1a9:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d1ac:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d1b0:	e9 56 02 00 00       	jmp    80d40b <tcp_receive+0xcd6>
  80d1b5:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80d1b8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (inseg.len > next->len) {
  80d1bc:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d1c0:	66 39 05 c0 b1 b3 00 	cmp    %ax,0xb3b1c0
  80d1c7:	0f 86 3e 02 00 00    	jbe    80d40b <tcp_receive+0xcd6>
                cseg = tcp_seg_copy(&inseg);
  80d1cd:	83 ec 0c             	sub    $0xc,%esp
  80d1d0:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d1d5:	e8 1c 88 ff ff       	call   8059f6 <tcp_seg_copy>
  80d1da:	89 c1                	mov    %eax,%ecx
  80d1dc:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (cseg != NULL) {
  80d1df:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d1e2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80d1e6:	85 c0                	test   %eax,%eax
  80d1e8:	0f 84 1d 02 00 00    	je     80d40b <tcp_receive+0xcd6>
                  cseg->next = next->next;
  80d1ee:	8b 03                	mov    (%ebx),%eax
  80d1f0:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80d1f2:	85 f6                	test   %esi,%esi
  80d1f4:	74 5c                	je     80d252 <tcp_receive+0xb1d>
                    prev->next = cseg;
  80d1f6:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80d1f8:	83 ec 0c             	sub    $0xc,%esp
  80d1fb:	53                   	push   %ebx
  80d1fc:	e8 70 87 ff ff       	call   805971 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d201:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80d204:	8b 06                	mov    (%esi),%eax
  80d206:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d209:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg->next != NULL) {
  80d20d:	85 c0                	test   %eax,%eax
  80d20f:	0f 84 f6 01 00 00    	je     80d40b <tcp_receive+0xcd6>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d215:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80d21b:	8b 40 10             	mov    0x10(%eax),%eax
  80d21e:	8b 40 04             	mov    0x4(%eax),%eax
  80d221:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80d225:	01 ca                	add    %ecx,%edx
  80d227:	29 c2                	sub    %eax,%edx
  80d229:	85 d2                	test   %edx,%edx
  80d22b:	0f 8e da 01 00 00    	jle    80d40b <tcp_receive+0xcd6>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d231:	29 c8                	sub    %ecx,%eax
  80d233:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80d237:	83 ec 08             	sub    $0x8,%esp
  80d23a:	0f b7 c0             	movzwl %ax,%eax
  80d23d:	50                   	push   %eax
  80d23e:	ff 76 04             	pushl  0x4(%esi)
  80d241:	e8 fe 7a ff ff       	call   804d44 <pbuf_realloc>
  80d246:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d249:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d24d:	e9 b9 01 00 00       	jmp    80d40b <tcp_receive+0xcd6>
                    pcb->ooseq = cseg;
  80d252:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d255:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d258:	eb 9e                	jmp    80d1f8 <tcp_receive+0xac3>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d25a:	39 c1                	cmp    %eax,%ecx
  80d25c:	0f 88 a0 00 00 00    	js     80d302 <tcp_receive+0xbcd>
              if (next->next == NULL &&
  80d262:	8b 13                	mov    (%ebx),%edx
  80d264:	89 de                	mov    %ebx,%esi
  80d266:	85 d2                	test   %edx,%edx
  80d268:	0f 84 0d 01 00 00    	je     80d37b <tcp_receive+0xc46>
  80d26e:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80d270:	8b 43 10             	mov    0x10(%ebx),%eax
  80d273:	8b 40 04             	mov    0x4(%eax),%eax
  80d276:	39 c8                	cmp    %ecx,%eax
  80d278:	0f 84 37 ff ff ff    	je     80d1b5 <tcp_receive+0xa80>
              if (prev == NULL) {
  80d27e:	85 f6                	test   %esi,%esi
  80d280:	74 d8                	je     80d25a <tcp_receive+0xb25>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d282:	8b 56 10             	mov    0x10(%esi),%edx
  80d285:	3b 7a 04             	cmp    0x4(%edx),%edi
  80d288:	78 d8                	js     80d262 <tcp_receive+0xb2d>
  80d28a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d28d:	29 c2                	sub    %eax,%edx
  80d28f:	85 d2                	test   %edx,%edx
  80d291:	7f cf                	jg     80d262 <tcp_receive+0xb2d>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d293:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80d29a:	01 ca                	add    %ecx,%edx
  80d29c:	29 c2                	sub    %eax,%edx
  80d29e:	85 d2                	test   %edx,%edx
  80d2a0:	0f 8f b3 00 00 00    	jg     80d359 <tcp_receive+0xc24>
                cseg = tcp_seg_copy(&inseg);
  80d2a6:	83 ec 0c             	sub    $0xc,%esp
  80d2a9:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d2ae:	e8 43 87 ff ff       	call   8059f6 <tcp_seg_copy>
                if (cseg != NULL) {
  80d2b3:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d2b6:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80d2ba:	85 c0                	test   %eax,%eax
  80d2bc:	0f 84 49 01 00 00    	je     80d40b <tcp_receive+0xcd6>
                  cseg->next = next;
  80d2c2:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80d2c4:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d2c6:	8b 46 10             	mov    0x10(%esi),%eax
  80d2c9:	8b 48 04             	mov    0x4(%eax),%ecx
  80d2cc:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d2d1:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80d2d5:	01 ca                	add    %ecx,%edx
  80d2d7:	29 c2                	sub    %eax,%edx
  80d2d9:	85 d2                	test   %edx,%edx
  80d2db:	0f 8e 2a 01 00 00    	jle    80d40b <tcp_receive+0xcd6>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d2e1:	29 c8                	sub    %ecx,%eax
  80d2e3:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80d2e7:	83 ec 08             	sub    $0x8,%esp
  80d2ea:	0f b7 c0             	movzwl %ax,%eax
  80d2ed:	50                   	push   %eax
  80d2ee:	ff 76 04             	pushl  0x4(%esi)
  80d2f1:	e8 4e 7a ff ff       	call   804d44 <pbuf_realloc>
  80d2f6:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d2f9:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d2fd:	e9 09 01 00 00       	jmp    80d40b <tcp_receive+0xcd6>
  80d302:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d305:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80d30c:	01 ca                	add    %ecx,%edx
  80d30e:	29 c2                	sub    %eax,%edx
  80d310:	85 d2                	test   %edx,%edx
  80d312:	7f 26                	jg     80d33a <tcp_receive+0xc05>
                  cseg = tcp_seg_copy(&inseg);
  80d314:	83 ec 0c             	sub    $0xc,%esp
  80d317:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d31c:	e8 d5 86 ff ff       	call   8059f6 <tcp_seg_copy>
                  if (cseg != NULL) {
  80d321:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d324:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg != NULL) {
  80d328:	85 c0                	test   %eax,%eax
  80d32a:	0f 84 db 00 00 00    	je     80d40b <tcp_receive+0xcd6>
                    cseg->next = next;
  80d330:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80d332:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d335:	e9 d1 00 00 00       	jmp    80d40b <tcp_receive+0xcd6>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d33a:	29 c8                	sub    %ecx,%eax
  80d33c:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80d342:	83 ec 08             	sub    $0x8,%esp
  80d345:	0f b7 c0             	movzwl %ax,%eax
  80d348:	50                   	push   %eax
  80d349:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80d34f:	e8 f0 79 ff ff       	call   804d44 <pbuf_realloc>
  80d354:	83 c4 10             	add    $0x10,%esp
  80d357:	eb bb                	jmp    80d314 <tcp_receive+0xbdf>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d359:	29 c8                	sub    %ecx,%eax
  80d35b:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80d361:	83 ec 08             	sub    $0x8,%esp
  80d364:	0f b7 c0             	movzwl %ax,%eax
  80d367:	50                   	push   %eax
  80d368:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80d36e:	e8 d1 79 ff ff       	call   804d44 <pbuf_realloc>
  80d373:	83 c4 10             	add    $0x10,%esp
  80d376:	e9 2b ff ff ff       	jmp    80d2a6 <tcp_receive+0xb71>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d37b:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80d37d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (next->next == NULL &&
  80d381:	85 c9                	test   %ecx,%ecx
  80d383:	0f 8e 82 00 00 00    	jle    80d40b <tcp_receive+0xcd6>
                next->next = tcp_seg_copy(&inseg);
  80d389:	83 ec 0c             	sub    $0xc,%esp
  80d38c:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d391:	e8 60 86 ff ff       	call   8059f6 <tcp_seg_copy>
  80d396:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d398:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d39b:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (next->next != NULL) {
  80d39f:	85 c0                	test   %eax,%eax
  80d3a1:	74 68                	je     80d40b <tcp_receive+0xcd6>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d3a3:	8b 43 10             	mov    0x10(%ebx),%eax
  80d3a6:	8b 48 04             	mov    0x4(%eax),%ecx
  80d3a9:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d3ae:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d3b2:	01 ca                	add    %ecx,%edx
  80d3b4:	29 c2                	sub    %eax,%edx
  80d3b6:	85 d2                	test   %edx,%edx
  80d3b8:	7e 51                	jle    80d40b <tcp_receive+0xcd6>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d3ba:	29 c8                	sub    %ecx,%eax
  80d3bc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d3c0:	83 ec 08             	sub    $0x8,%esp
  80d3c3:	0f b7 c0             	movzwl %ax,%eax
  80d3c6:	50                   	push   %eax
  80d3c7:	ff 73 04             	pushl  0x4(%ebx)
  80d3ca:	e8 75 79 ff ff       	call   804d44 <pbuf_realloc>
  80d3cf:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d3d2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d3d6:	eb 33                	jmp    80d40b <tcp_receive+0xcd6>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d3d8:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d3dd:	8b 57 24             	mov    0x24(%edi),%edx
  80d3e0:	39 d0                	cmp    %edx,%eax
  80d3e2:	78 13                	js     80d3f7 <tcp_receive+0xcc2>
  80d3e4:	83 c0 01             	add    $0x1,%eax
  80d3e7:	29 d0                	sub    %edx,%eax
  80d3e9:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80d3ed:	29 d0                	sub    %edx,%eax
  u8_t accepted_inseq = 0;
  80d3ef:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d3f3:	85 c0                	test   %eax,%eax
  80d3f5:	7e 14                	jle    80d40b <tcp_receive+0xcd6>
      tcp_ack_now(pcb);
  80d3f7:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d3fb:	83 ec 0c             	sub    $0xc,%esp
  80d3fe:	57                   	push   %edi
  80d3ff:	e8 d5 ae ff ff       	call   8082d9 <tcp_output>
  80d404:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d407:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
}
  80d40b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80d40f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d412:	5b                   	pop    %ebx
  80d413:	5e                   	pop    %esi
  80d414:	5f                   	pop    %edi
  80d415:	5d                   	pop    %ebp
  80d416:	c3                   	ret    

0080d417 <tcp_input>:
{
  80d417:	f3 0f 1e fb          	endbr32 
  80d41b:	55                   	push   %ebp
  80d41c:	89 e5                	mov    %esp,%ebp
  80d41e:	57                   	push   %edi
  80d41f:	56                   	push   %esi
  80d420:	53                   	push   %ebx
  80d421:	83 ec 38             	sub    $0x38,%esp
  80d424:	8b 75 08             	mov    0x8(%ebp),%esi
  iphdr = p->payload;
  80d427:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d42a:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d430:	0f b7 03             	movzwl (%ebx),%eax
  80d433:	50                   	push   %eax
  80d434:	e8 2b a5 ff ff       	call   807964 <ntohs>
  80d439:	66 c1 e8 08          	shr    $0x8,%ax
  80d43d:	83 e0 0f             	and    $0xf,%eax
  80d440:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80d443:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d448:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d44d:	0f b7 00             	movzwl (%eax),%eax
  80d450:	89 04 24             	mov    %eax,(%esp)
  80d453:	e8 0c a5 ff ff       	call   807964 <ntohs>
  80d458:	83 c4 08             	add    $0x8,%esp
  80d45b:	66 c1 e8 06          	shr    $0x6,%ax
  80d45f:	83 e0 3c             	and    $0x3c,%eax
  80d462:	f7 d8                	neg    %eax
  80d464:	98                   	cwtl   
  80d465:	50                   	push   %eax
  80d466:	56                   	push   %esi
  80d467:	e8 dc 74 ff ff       	call   804948 <pbuf_header>
  80d46c:	83 c4 10             	add    $0x10,%esp
  80d46f:	84 c0                	test   %al,%al
  80d471:	75 07                	jne    80d47a <tcp_input+0x63>
  80d473:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d478:	77 14                	ja     80d48e <tcp_input+0x77>
    pbuf_free(p);
  80d47a:	83 ec 0c             	sub    $0xc,%esp
  80d47d:	56                   	push   %esi
  80d47e:	e8 98 75 ff ff       	call   804a1b <pbuf_free>
    return;
  80d483:	83 c4 10             	add    $0x10,%esp
}
  80d486:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d489:	5b                   	pop    %ebx
  80d48a:	5e                   	pop    %esi
  80d48b:	5f                   	pop    %edi
  80d48c:	5d                   	pop    %ebp
  80d48d:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d48e:	83 ec 08             	sub    $0x8,%esp
  80d491:	ff 75 0c             	pushl  0xc(%ebp)
  80d494:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d499:	83 c0 10             	add    $0x10,%eax
  80d49c:	50                   	push   %eax
  80d49d:	e8 35 92 ff ff       	call   8066d7 <ip_addr_isbroadcast>
  80d4a2:	83 c4 10             	add    $0x10,%esp
  80d4a5:	84 c0                	test   %al,%al
  80d4a7:	0f 85 54 01 00 00    	jne    80d601 <tcp_input+0x1ea>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d4ad:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d4b2:	8b 58 10             	mov    0x10(%eax),%ebx
  80d4b5:	83 ec 0c             	sub    $0xc,%esp
  80d4b8:	68 00 00 00 f0       	push   $0xf0000000
  80d4bd:	e8 e0 a6 ff ff       	call   807ba2 <ntohl>
  80d4c2:	21 c3                	and    %eax,%ebx
  80d4c4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d4cb:	e8 d2 a6 ff ff       	call   807ba2 <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d4d0:	83 c4 10             	add    $0x10,%esp
  80d4d3:	39 c3                	cmp    %eax,%ebx
  80d4d5:	0f 84 26 01 00 00    	je     80d601 <tcp_input+0x1ea>
      (struct ip_addr *)&(iphdr->dest),
  80d4db:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d4e0:	83 ec 0c             	sub    $0xc,%esp
  80d4e3:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d4e7:	52                   	push   %edx
  80d4e8:	6a 06                	push   $0x6
  80d4ea:	8d 50 10             	lea    0x10(%eax),%edx
  80d4ed:	52                   	push   %edx
  80d4ee:	83 c0 0c             	add    $0xc,%eax
  80d4f1:	50                   	push   %eax
  80d4f2:	56                   	push   %esi
  80d4f3:	e8 23 a1 ff ff       	call   80761b <inet_chksum_pseudo>
  80d4f8:	83 c4 20             	add    $0x20,%esp
  80d4fb:	66 85 c0             	test   %ax,%ax
  80d4fe:	0f 85 0e 01 00 00    	jne    80d612 <tcp_input+0x1fb>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d504:	83 ec 0c             	sub    $0xc,%esp
  80d507:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d50c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d510:	50                   	push   %eax
  80d511:	e8 4e a4 ff ff       	call   807964 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d516:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d519:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d51d:	f7 d8                	neg    %eax
  80d51f:	c1 e0 02             	shl    $0x2,%eax
  80d522:	98                   	cwtl   
  80d523:	50                   	push   %eax
  80d524:	56                   	push   %esi
  80d525:	e8 1e 74 ff ff       	call   804948 <pbuf_header>
  80d52a:	83 c4 10             	add    $0x10,%esp
  80d52d:	84 c0                	test   %al,%al
  80d52f:	0f 85 ee 00 00 00    	jne    80d623 <tcp_input+0x20c>
  tcphdr->src = ntohs(tcphdr->src);
  80d535:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d53b:	83 ec 0c             	sub    $0xc,%esp
  80d53e:	0f b7 03             	movzwl (%ebx),%eax
  80d541:	50                   	push   %eax
  80d542:	e8 1d a4 ff ff       	call   807964 <ntohs>
  80d547:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d54a:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d550:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d554:	89 04 24             	mov    %eax,(%esp)
  80d557:	e8 08 a4 ff ff       	call   807964 <ntohs>
  80d55c:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d560:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d566:	83 c4 04             	add    $0x4,%esp
  80d569:	ff 73 04             	pushl  0x4(%ebx)
  80d56c:	e8 31 a6 ff ff       	call   807ba2 <ntohl>
  80d571:	89 43 04             	mov    %eax,0x4(%ebx)
  80d574:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d579:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d57f:	83 c4 04             	add    $0x4,%esp
  80d582:	ff 73 08             	pushl  0x8(%ebx)
  80d585:	e8 18 a6 ff ff       	call   807ba2 <ntohl>
  80d58a:	89 43 08             	mov    %eax,0x8(%ebx)
  80d58d:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d592:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d598:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d59c:	89 04 24             	mov    %eax,(%esp)
  80d59f:	e8 c0 a3 ff ff       	call   807964 <ntohs>
  80d5a4:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d5a8:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d5ad:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5b1:	89 04 24             	mov    %eax,(%esp)
  80d5b4:	e8 ab a3 ff ff       	call   807964 <ntohs>
  80d5b9:	89 c1                	mov    %eax,%ecx
  80d5bb:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d5bf:	83 e0 3f             	and    $0x3f,%eax
  80d5c2:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d5c7:	83 c4 10             	add    $0x10,%esp
  80d5ca:	f6 c1 03             	test   $0x3,%cl
  80d5cd:	0f 95 c0             	setne  %al
  80d5d0:	0f b6 c0             	movzbl %al,%eax
  80d5d3:	66 03 46 08          	add    0x8(%esi),%ax
  80d5d7:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d5db:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d5e1:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d5e6:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d5e9:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d5ef:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d5f5:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  80d5f7:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d5fc:	e9 ab 00 00 00       	jmp    80d6ac <tcp_input+0x295>
    pbuf_free(p);
  80d601:	83 ec 0c             	sub    $0xc,%esp
  80d604:	56                   	push   %esi
  80d605:	e8 11 74 ff ff       	call   804a1b <pbuf_free>
    return;
  80d60a:	83 c4 10             	add    $0x10,%esp
  80d60d:	e9 74 fe ff ff       	jmp    80d486 <tcp_input+0x6f>
    pbuf_free(p);
  80d612:	83 ec 0c             	sub    $0xc,%esp
  80d615:	56                   	push   %esi
  80d616:	e8 00 74 ff ff       	call   804a1b <pbuf_free>
    return;
  80d61b:	83 c4 10             	add    $0x10,%esp
  80d61e:	e9 63 fe ff ff       	jmp    80d486 <tcp_input+0x6f>
    pbuf_free(p);
  80d623:	83 ec 0c             	sub    $0xc,%esp
  80d626:	56                   	push   %esi
  80d627:	e8 ef 73 ff ff       	call   804a1b <pbuf_free>
    return;
  80d62c:	83 c4 10             	add    $0x10,%esp
  80d62f:	e9 52 fe ff ff       	jmp    80d486 <tcp_input+0x6f>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d634:	83 ec 04             	sub    $0x4,%esp
  80d637:	68 30 34 81 00       	push   $0x813430
  80d63c:	68 b5 00 00 00       	push   $0xb5
  80d641:	68 54 35 81 00       	push   $0x813554
  80d646:	e8 ec 12 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d64b:	83 ec 04             	sub    $0x4,%esp
  80d64e:	68 58 34 81 00       	push   $0x813458
  80d653:	68 b6 00 00 00       	push   $0xb6
  80d658:	68 54 35 81 00       	push   $0x813554
  80d65d:	e8 d5 12 00 00       	call   80e937 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d662:	83 ec 04             	sub    $0x4,%esp
  80d665:	68 84 34 81 00       	push   $0x813484
  80d66a:	68 b7 00 00 00       	push   $0xb7
  80d66f:	68 54 35 81 00       	push   $0x813554
  80d674:	e8 be 12 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d679:	83 ec 04             	sub    $0x4,%esp
  80d67c:	68 ac 34 81 00       	push   $0x8134ac
  80d681:	68 c0 00 00 00       	push   $0xc0
  80d686:	68 54 35 81 00       	push   $0x813554
  80d68b:	e8 a7 12 00 00       	call   80e937 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d690:	83 ec 04             	sub    $0x4,%esp
  80d693:	68 d8 34 81 00       	push   $0x8134d8
  80d698:	68 c6 00 00 00       	push   $0xc6
  80d69d:	68 54 35 81 00       	push   $0x813554
  80d6a2:	e8 90 12 00 00       	call   80e937 <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d6a7:	89 df                	mov    %ebx,%edi
  80d6a9:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d6ac:	85 db                	test   %ebx,%ebx
  80d6ae:	0f 84 5b 0a 00 00    	je     80e10f <tcp_input+0xcf8>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d6b4:	8b 43 10             	mov    0x10(%ebx),%eax
  80d6b7:	85 c0                	test   %eax,%eax
  80d6b9:	0f 84 75 ff ff ff    	je     80d634 <tcp_input+0x21d>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d6bf:	83 f8 0a             	cmp    $0xa,%eax
  80d6c2:	74 87                	je     80d64b <tcp_input+0x234>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d6c4:	83 f8 01             	cmp    $0x1,%eax
  80d6c7:	74 99                	je     80d662 <tcp_input+0x24b>
    if (pcb->remote_port == tcphdr->src &&
  80d6c9:	0f b7 02             	movzwl (%edx),%eax
  80d6cc:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d6d0:	75 d5                	jne    80d6a7 <tcp_input+0x290>
  80d6d2:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d6d6:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d6da:	75 cb                	jne    80d6a7 <tcp_input+0x290>
       pcb->local_port == tcphdr->dest &&
  80d6dc:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d6df:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d6e2:	75 c3                	jne    80d6a7 <tcp_input+0x290>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d6e4:	8b 41 10             	mov    0x10(%ecx),%eax
  80d6e7:	39 03                	cmp    %eax,(%ebx)
  80d6e9:	75 bc                	jne    80d6a7 <tcp_input+0x290>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d6eb:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d6ee:	39 c3                	cmp    %eax,%ebx
  80d6f0:	74 87                	je     80d679 <tcp_input+0x262>
      if (prev != NULL) {
  80d6f2:	85 ff                	test   %edi,%edi
  80d6f4:	74 13                	je     80d709 <tcp_input+0x2f2>
        prev->next = pcb->next;
  80d6f6:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d6f9:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d6fc:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d6ff:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d705:	39 c3                	cmp    %eax,%ebx
  80d707:	74 87                	je     80d690 <tcp_input+0x279>
    inseg.next = NULL;
  80d709:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d710:	00 00 00 
    inseg.len = p->tot_len;
  80d713:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d717:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d71d:	8b 46 04             	mov    0x4(%esi),%eax
  80d720:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d725:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d72b:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4
    recv_data = NULL;
  80d731:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d738:	00 00 00 
    recv_flags = 0;
  80d73b:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c
    if (pcb->refused_data != NULL) {
  80d742:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d748:	85 c0                	test   %eax,%eax
  80d74a:	74 2c                	je     80d778 <tcp_input+0x361>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d74c:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d752:	85 d2                	test   %edx,%edx
  80d754:	0f 84 dd 02 00 00    	je     80da37 <tcp_input+0x620>
  80d75a:	6a 00                	push   $0x0
  80d75c:	50                   	push   %eax
  80d75d:	53                   	push   %ebx
  80d75e:	ff 73 18             	pushl  0x18(%ebx)
  80d761:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d763:	83 c4 10             	add    $0x10,%esp
  80d766:	84 c0                	test   %al,%al
  80d768:	0f 85 da 02 00 00    	jne    80da48 <tcp_input+0x631>
        pcb->refused_data = NULL;
  80d76e:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d775:	00 00 00 
    tcp_input_pcb = pcb;
  80d778:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  if (flags & TCP_RST) {
  80d77e:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d785:	a8 04                	test   $0x4,%al
  80d787:	0f 84 f6 02 00 00    	je     80da83 <tcp_input+0x66c>
    if (pcb->state == SYN_SENT) {
  80d78d:	8b 53 10             	mov    0x10(%ebx),%edx
  80d790:	83 fa 02             	cmp    $0x2,%edx
  80d793:	0f 84 c0 02 00 00    	je     80da59 <tcp_input+0x642>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d799:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d79e:	2b 43 24             	sub    0x24(%ebx),%eax
  80d7a1:	78 1d                	js     80d7c0 <tcp_input+0x3a9>
  80d7a3:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d7a7:	29 c8                	sub    %ecx,%eax
  80d7a9:	85 c0                	test   %eax,%eax
  80d7ab:	7f 13                	jg     80d7c0 <tcp_input+0x3a9>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d7ad:	85 d2                	test   %edx,%edx
  80d7af:	0f 84 b7 02 00 00    	je     80da6c <tcp_input+0x655>
      recv_flags = TF_RESET;
  80d7b5:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d7bc:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
    tcp_input_pcb = NULL;
  80d7c0:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d7c7:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d7ca:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80d7d1:	a8 08                	test   $0x8,%al
  80d7d3:	0f 84 df 07 00 00    	je     80dfb8 <tcp_input+0xba1>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d7d9:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d7df:	85 c0                	test   %eax,%eax
  80d7e1:	74 0d                	je     80d7f0 <tcp_input+0x3d9>
  80d7e3:	83 ec 08             	sub    $0x8,%esp
  80d7e6:	6a fa                	push   $0xfffffffa
  80d7e8:	ff 73 18             	pushl  0x18(%ebx)
  80d7eb:	ff d0                	call   *%eax
  80d7ed:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d7f0:	83 ec 08             	sub    $0x8,%esp
  80d7f3:	53                   	push   %ebx
  80d7f4:	68 3c b2 b3 00       	push   $0xb3b23c
  80d7f9:	e8 35 83 ff ff       	call   805b33 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d7fe:	83 c4 08             	add    $0x8,%esp
  80d801:	53                   	push   %ebx
  80d802:	6a 02                	push   $0x2
  80d804:	e8 8f 6e ff ff       	call   804698 <memp_free>
  80d809:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d80c:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d811:	85 c0                	test   %eax,%eax
  80d813:	0f 84 6d fc ff ff    	je     80d486 <tcp_input+0x6f>
      pbuf_free(inseg.p);
  80d819:	83 ec 0c             	sub    $0xc,%esp
  80d81c:	50                   	push   %eax
  80d81d:	e8 f9 71 ff ff       	call   804a1b <pbuf_free>
      inseg.p = NULL;
  80d822:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80d829:	00 00 00 
  80d82c:	83 c4 10             	add    $0x10,%esp
  80d82f:	e9 52 fc ff ff       	jmp    80d486 <tcp_input+0x6f>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d834:	83 ec 04             	sub    $0x4,%esp
  80d837:	68 04 35 81 00       	push   $0x813504
  80d83c:	68 d0 00 00 00       	push   $0xd0
  80d841:	68 54 35 81 00       	push   $0x813554
  80d846:	e8 ec 10 00 00       	call   80e937 <_panic>
    tcp_ack_now(pcb);
  80d84b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d84f:	83 ec 0c             	sub    $0xc,%esp
  80d852:	53                   	push   %ebx
  80d853:	e8 81 aa ff ff       	call   8082d9 <tcp_output>
  80d858:	83 c4 10             	add    $0x10,%esp
  80d85b:	eb 4c                	jmp    80d8a9 <tcp_input+0x492>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d85d:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d860:	85 db                	test   %ebx,%ebx
  80d862:	74 5e                	je     80d8c2 <tcp_input+0x4ab>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d864:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d868:	75 ca                	jne    80d834 <tcp_input+0x41d>
      if (pcb->remote_port == tcphdr->src &&
  80d86a:	0f b7 02             	movzwl (%edx),%eax
  80d86d:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d871:	75 ea                	jne    80d85d <tcp_input+0x446>
  80d873:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d877:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d87b:	75 e0                	jne    80d85d <tcp_input+0x446>
         pcb->local_port == tcphdr->dest &&
  80d87d:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d880:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d883:	75 d8                	jne    80d85d <tcp_input+0x446>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d885:	8b 41 10             	mov    0x10(%ecx),%eax
  80d888:	39 03                	cmp    %eax,(%ebx)
  80d88a:	75 d1                	jne    80d85d <tcp_input+0x446>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d88c:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d890:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d896:	89 c2                	mov    %eax,%edx
  80d898:	2b 53 24             	sub    0x24(%ebx),%edx
  80d89b:	85 d2                	test   %edx,%edx
  80d89d:	7e 03                	jle    80d8a2 <tcp_input+0x48b>
    pcb->rcv_nxt = seqno + tcplen;
  80d89f:	89 43 24             	mov    %eax,0x24(%ebx)
  if (tcplen > 0) {
  80d8a2:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d8a7:	75 a2                	jne    80d84b <tcp_input+0x434>
  return tcp_output(pcb);
  80d8a9:	83 ec 0c             	sub    $0xc,%esp
  80d8ac:	53                   	push   %ebx
  80d8ad:	e8 27 aa ff ff       	call   8082d9 <tcp_output>
        pbuf_free(p);
  80d8b2:	89 34 24             	mov    %esi,(%esp)
  80d8b5:	e8 61 71 ff ff       	call   804a1b <pbuf_free>
        return;
  80d8ba:	83 c4 10             	add    $0x10,%esp
  80d8bd:	e9 c4 fb ff ff       	jmp    80d486 <tcp_input+0x6f>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d8c2:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d8c7:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d8ca:	89 c7                	mov    %eax,%edi
  80d8cc:	eb 0f                	jmp    80d8dd <tcp_input+0x4c6>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d8ce:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d8d2:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d8d6:	74 1a                	je     80d8f2 <tcp_input+0x4db>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d8d8:	89 fb                	mov    %edi,%ebx
  80d8da:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d8dd:	85 ff                	test   %edi,%edi
  80d8df:	0f 84 05 08 00 00    	je     80e0ea <tcp_input+0xcd3>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d8e5:	8b 07                	mov    (%edi),%eax
  80d8e7:	85 c0                	test   %eax,%eax
  80d8e9:	74 e3                	je     80d8ce <tcp_input+0x4b7>
  80d8eb:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d8ee:	75 e8                	jne    80d8d8 <tcp_input+0x4c1>
  80d8f0:	eb dc                	jmp    80d8ce <tcp_input+0x4b7>
        if (prev != NULL) {
  80d8f2:	85 db                	test   %ebx,%ebx
  80d8f4:	74 12                	je     80d908 <tcp_input+0x4f1>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d8f6:	8b 47 0c             	mov    0xc(%edi),%eax
  80d8f9:	89 43 0c             	mov    %eax,0xc(%ebx)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d8fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d8ff:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d902:	89 3d 44 b2 b3 00    	mov    %edi,0xb3b244
  if (flags & TCP_ACK) {
  80d908:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d90c:	75 17                	jne    80d925 <tcp_input+0x50e>
  } else if (flags & TCP_SYN) {
  80d90e:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d912:	75 43                	jne    80d957 <tcp_input+0x540>
        pbuf_free(p);
  80d914:	83 ec 0c             	sub    $0xc,%esp
  80d917:	56                   	push   %esi
  80d918:	e8 fe 70 ff ff       	call   804a1b <pbuf_free>
        return;
  80d91d:	83 c4 10             	add    $0x10,%esp
  80d920:	e9 61 fb ff ff       	jmp    80d486 <tcp_input+0x6f>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d925:	83 ec 08             	sub    $0x8,%esp
  80d928:	0f b7 02             	movzwl (%edx),%eax
  80d92b:	50                   	push   %eax
  80d92c:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d930:	50                   	push   %eax
  80d931:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d934:	50                   	push   %eax
  80d935:	83 c1 10             	add    $0x10,%ecx
  80d938:	51                   	push   %ecx
  80d939:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d93d:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d943:	50                   	push   %eax
  80d944:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d949:	83 c0 01             	add    $0x1,%eax
  80d94c:	50                   	push   %eax
  80d94d:	e8 2d ae ff ff       	call   80877f <tcp_rst>
  80d952:	83 c4 20             	add    $0x20,%esp
  80d955:	eb bd                	jmp    80d914 <tcp_input+0x4fd>
    npcb = tcp_alloc(pcb->prio);
  80d957:	83 ec 0c             	sub    $0xc,%esp
  80d95a:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d95e:	50                   	push   %eax
  80d95f:	e8 11 8a ff ff       	call   806375 <tcp_alloc>
  80d964:	89 c3                	mov    %eax,%ebx
    if (npcb == NULL) {
  80d966:	83 c4 10             	add    $0x10,%esp
  80d969:	85 c0                	test   %eax,%eax
  80d96b:	74 a7                	je     80d914 <tcp_input+0x4fd>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d96d:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d972:	8b 50 10             	mov    0x10(%eax),%edx
  80d975:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  80d977:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d97b:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d97f:	8b 40 0c             	mov    0xc(%eax),%eax
  80d982:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80d985:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d98b:	0f b7 02             	movzwl (%edx),%eax
  80d98e:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80d992:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80d999:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d99e:	8d 48 01             	lea    0x1(%eax),%ecx
  80d9a1:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80d9a4:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d9a8:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80d9ac:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d9b0:	83 e8 01             	sub    $0x1,%eax
  80d9b3:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80d9b6:	8b 47 18             	mov    0x18(%edi),%eax
  80d9b9:	89 43 18             	mov    %eax,0x18(%ebx)
    npcb->accept = pcb->accept;
  80d9bc:	8b 47 20             	mov    0x20(%edi),%eax
  80d9bf:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d9c5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d9c9:	66 25 99 01          	and    $0x199,%ax
  80d9cd:	66 89 43 08          	mov    %ax,0x8(%ebx)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d9d1:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d9d6:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d9d9:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  80d9df:	e8 62 49 ff ff       	call   802346 <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d9e4:	89 d8                	mov    %ebx,%eax
  80d9e6:	e8 96 ec ff ff       	call   80c681 <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d9eb:	83 ec 08             	sub    $0x8,%esp
  80d9ee:	8d 43 04             	lea    0x4(%ebx),%eax
  80d9f1:	50                   	push   %eax
  80d9f2:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d9f6:	50                   	push   %eax
  80d9f7:	e8 1f 8b ff ff       	call   80651b <tcp_eff_send_mss>
  80d9fc:	66 89 43 34          	mov    %ax,0x34(%ebx)
    optdata = TCP_BUILD_MSS_OPTION();
  80da00:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80da07:	e8 69 9f ff ff       	call   807975 <htonl>
  80da0c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80da0f:	83 c4 0c             	add    $0xc,%esp
  80da12:	6a 04                	push   $0x4
  80da14:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80da17:	50                   	push   %eax
  80da18:	6a 00                	push   $0x0
  80da1a:	6a 12                	push   $0x12
  80da1c:	6a 00                	push   $0x0
  80da1e:	6a 00                	push   $0x0
  80da20:	53                   	push   %ebx
  80da21:	e8 93 a1 ff ff       	call   807bb9 <tcp_enqueue>
    return tcp_output(npcb);
  80da26:	83 c4 14             	add    $0x14,%esp
  80da29:	53                   	push   %ebx
  80da2a:	e8 aa a8 ff ff       	call   8082d9 <tcp_output>
  80da2f:	83 c4 10             	add    $0x10,%esp
  80da32:	e9 dd fe ff ff       	jmp    80d914 <tcp_input+0x4fd>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80da37:	83 ec 0c             	sub    $0xc,%esp
  80da3a:	50                   	push   %eax
  80da3b:	e8 db 6f ff ff       	call   804a1b <pbuf_free>
  80da40:	83 c4 10             	add    $0x10,%esp
  80da43:	e9 26 fd ff ff       	jmp    80d76e <tcp_input+0x357>
        pbuf_free(p);
  80da48:	83 ec 0c             	sub    $0xc,%esp
  80da4b:	56                   	push   %esi
  80da4c:	e8 ca 6f ff ff       	call   804a1b <pbuf_free>
        return;
  80da51:	83 c4 10             	add    $0x10,%esp
  80da54:	e9 2d fa ff ff       	jmp    80d486 <tcp_input+0x6f>
      if (ackno == pcb->snd_nxt) {
  80da59:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80da5e:	39 43 54             	cmp    %eax,0x54(%ebx)
  80da61:	0f 84 4e fd ff ff    	je     80d7b5 <tcp_input+0x39e>
  80da67:	e9 54 fd ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80da6c:	83 ec 04             	sub    $0x4,%esp
  80da6f:	68 34 35 81 00       	push   $0x813534
  80da74:	68 09 02 00 00       	push   $0x209
  80da79:	68 54 35 81 00       	push   $0x813554
  80da7e:	e8 b4 0e 00 00       	call   80e937 <_panic>
  pcb->tmr = tcp_ticks;
  80da83:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80da89:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80da8c:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  80da93:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80da97:	0f 87 0c 05 00 00    	ja     80dfa9 <tcp_input+0xb92>
  80da9d:	8b 53 10             	mov    0x10(%ebx),%edx
  80daa0:	3e ff 24 95 d8 35 81 	notrack jmp *0x8135d8(,%edx,4)
  80daa7:	00 
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80daa8:	83 e0 12             	and    $0x12,%eax
  80daab:	3c 12                	cmp    $0x12,%al
  80daad:	74 4d                	je     80dafc <tcp_input+0x6e5>
    else if (flags & TCP_ACK) {
  80daaf:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80dab6:	0f 84 04 fd ff ff    	je     80d7c0 <tcp_input+0x3a9>
        tcphdr->dest, tcphdr->src);
  80dabc:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80dac2:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80dac7:	83 ec 08             	sub    $0x8,%esp
  80daca:	0f b7 0a             	movzwl (%edx),%ecx
  80dacd:	51                   	push   %ecx
  80dace:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80dad2:	52                   	push   %edx
  80dad3:	8d 50 0c             	lea    0xc(%eax),%edx
  80dad6:	52                   	push   %edx
  80dad7:	83 c0 10             	add    $0x10,%eax
  80dada:	50                   	push   %eax
  80dadb:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80dae2:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80dae8:	50                   	push   %eax
  80dae9:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80daef:	e8 8b ac ff ff       	call   80877f <tcp_rst>
  80daf4:	83 c4 20             	add    $0x20,%esp
  80daf7:	e9 c4 fc ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80dafc:	83 ec 0c             	sub    $0xc,%esp
  80daff:	8b 43 78             	mov    0x78(%ebx),%eax
  80db02:	8b 40 10             	mov    0x10(%eax),%eax
  80db05:	ff 70 04             	pushl  0x4(%eax)
  80db08:	e8 95 a0 ff ff       	call   807ba2 <ntohl>
  80db0d:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80db13:	83 c0 01             	add    $0x1,%eax
  80db16:	83 c4 10             	add    $0x10,%esp
  80db19:	39 d0                	cmp    %edx,%eax
  80db1b:	75 92                	jne    80daaf <tcp_input+0x698>
      pcb->snd_buf++;
  80db1d:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80db22:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80db27:	8d 48 01             	lea    0x1(%eax),%ecx
  80db2a:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80db2d:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80db30:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80db36:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80db3a:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80db3e:	83 e8 01             	sub    $0x1,%eax
  80db41:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80db44:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
      tcp_parseopt(pcb);
  80db4b:	89 d8                	mov    %ebx,%eax
  80db4d:	e8 2f eb ff ff       	call   80c681 <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80db52:	83 ec 08             	sub    $0x8,%esp
  80db55:	8d 43 04             	lea    0x4(%ebx),%eax
  80db58:	50                   	push   %eax
  80db59:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80db5d:	50                   	push   %eax
  80db5e:	e8 b8 89 ff ff       	call   80651b <tcp_eff_send_mss>
  80db63:	66 89 43 34          	mov    %ax,0x34(%ebx)
      pcb->ssthresh = pcb->mss * 10;
  80db67:	6b d0 0a             	imul   $0xa,%eax,%edx
  80db6a:	66 89 53 50          	mov    %dx,0x50(%ebx)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80db6e:	83 c4 10             	add    $0x10,%esp
  80db71:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80db76:	74 63                	je     80dbdb <tcp_input+0x7c4>
  80db78:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80db7c:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80db80:	66 85 c0             	test   %ax,%ax
  80db83:	74 5a                	je     80dbdf <tcp_input+0x7c8>
      --pcb->snd_queuelen;
  80db85:	83 e8 01             	sub    $0x1,%eax
  80db88:	66 89 43 70          	mov    %ax,0x70(%ebx)
      rseg = pcb->unacked;
  80db8c:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80db8f:	8b 10                	mov    (%eax),%edx
  80db91:	89 53 78             	mov    %edx,0x78(%ebx)
      if(pcb->unacked == NULL)
  80db94:	85 d2                	test   %edx,%edx
  80db96:	74 5e                	je     80dbf6 <tcp_input+0x7df>
        pcb->rtime = 0;
  80db98:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80db9e:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      tcp_seg_free(rseg);
  80dba2:	83 ec 0c             	sub    $0xc,%esp
  80dba5:	50                   	push   %eax
  80dba6:	e8 c6 7d ff ff       	call   805971 <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80dbab:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80dbb1:	83 c4 10             	add    $0x10,%esp
  80dbb4:	85 c0                	test   %eax,%eax
  80dbb6:	74 0e                	je     80dbc6 <tcp_input+0x7af>
  80dbb8:	83 ec 04             	sub    $0x4,%esp
  80dbbb:	6a 00                	push   $0x0
  80dbbd:	53                   	push   %ebx
  80dbbe:	ff 73 18             	pushl  0x18(%ebx)
  80dbc1:	ff d0                	call   *%eax
  80dbc3:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80dbc6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dbca:	83 ec 0c             	sub    $0xc,%esp
  80dbcd:	53                   	push   %ebx
  80dbce:	e8 06 a7 ff ff       	call   8082d9 <tcp_output>
  80dbd3:	83 c4 10             	add    $0x10,%esp
  80dbd6:	e9 e5 fb ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dbdb:	01 c0                	add    %eax,%eax
  80dbdd:	eb 99                	jmp    80db78 <tcp_input+0x761>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80dbdf:	83 ec 04             	sub    $0x4,%esp
  80dbe2:	68 ad 35 81 00       	push   $0x8135ad
  80dbe7:	68 35 02 00 00       	push   $0x235
  80dbec:	68 54 35 81 00       	push   $0x813554
  80dbf1:	e8 41 0d 00 00       	call   80e937 <_panic>
        pcb->rtime = -1;
  80dbf6:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80dbfc:	eb a4                	jmp    80dba2 <tcp_input+0x78b>
    if (flags & TCP_ACK &&
  80dbfe:	83 e0 14             	and    $0x14,%eax
  80dc01:	3c 10                	cmp    $0x10,%al
  80dc03:	0f 85 b7 fb ff ff    	jne    80d7c0 <tcp_input+0x3a9>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80dc09:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80dc0f:	8d 42 ff             	lea    -0x1(%edx),%eax
  80dc12:	3b 43 48             	cmp    0x48(%ebx),%eax
  80dc15:	78 09                	js     80dc20 <tcp_input+0x809>
  80dc17:	89 d0                	mov    %edx,%eax
  80dc19:	2b 43 54             	sub    0x54(%ebx),%eax
  80dc1c:	85 c0                	test   %eax,%eax
  80dc1e:	7e 3b                	jle    80dc5b <tcp_input+0x844>
                tcphdr->dest, tcphdr->src);
  80dc20:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80dc26:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80dc2b:	83 ec 08             	sub    $0x8,%esp
  80dc2e:	0f b7 31             	movzwl (%ecx),%esi
  80dc31:	56                   	push   %esi
  80dc32:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80dc36:	51                   	push   %ecx
  80dc37:	8d 48 0c             	lea    0xc(%eax),%ecx
  80dc3a:	51                   	push   %ecx
  80dc3b:	83 c0 10             	add    $0x10,%eax
  80dc3e:	50                   	push   %eax
  80dc3f:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80dc46:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80dc4c:	50                   	push   %eax
  80dc4d:	52                   	push   %edx
  80dc4e:	e8 2c ab ff ff       	call   80877f <tcp_rst>
  80dc53:	83 c4 20             	add    $0x20,%esp
  80dc56:	e9 65 fb ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
        pcb->state = ESTABLISHED;
  80dc5b:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80dc62:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80dc68:	85 c0                	test   %eax,%eax
  80dc6a:	74 5e                	je     80dcca <tcp_input+0x8b3>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80dc6c:	83 ec 04             	sub    $0x4,%esp
  80dc6f:	6a 00                	push   $0x0
  80dc71:	53                   	push   %ebx
  80dc72:	ff 73 18             	pushl  0x18(%ebx)
  80dc75:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80dc77:	83 c4 10             	add    $0x10,%esp
  80dc7a:	84 c0                	test   %al,%al
  80dc7c:	75 63                	jne    80dce1 <tcp_input+0x8ca>
        old_cwnd = pcb->cwnd;
  80dc7e:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        accepted_inseq = tcp_receive(pcb);
  80dc82:	89 d8                	mov    %ebx,%eax
  80dc84:	e8 ac ea ff ff       	call   80c735 <tcp_receive>
  80dc89:	89 c2                	mov    %eax,%edx
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dc8b:	66 83 fe 01          	cmp    $0x1,%si
  80dc8f:	74 6b                	je     80dcfc <tcp_input+0x8e5>
  80dc91:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80dc95:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80dc99:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80dca0:	0f 84 1a fb ff ff    	je     80d7c0 <tcp_input+0x3a9>
  80dca6:	84 d2                	test   %dl,%dl
  80dca8:	0f 84 12 fb ff ff    	je     80d7c0 <tcp_input+0x3a9>
          tcp_ack_now(pcb);
  80dcae:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dcb2:	83 ec 0c             	sub    $0xc,%esp
  80dcb5:	53                   	push   %ebx
  80dcb6:	e8 1e a6 ff ff       	call   8082d9 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80dcbb:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80dcc2:	83 c4 10             	add    $0x10,%esp
  80dcc5:	e9 f6 fa ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80dcca:	83 ec 04             	sub    $0x4,%esp
  80dccd:	68 c3 35 81 00       	push   $0x8135c3
  80dcd2:	68 5b 02 00 00       	push   $0x25b
  80dcd7:	68 54 35 81 00       	push   $0x813554
  80dcdc:	e8 56 0c 00 00       	call   80e937 <_panic>
          tcp_abort(pcb);
  80dce1:	83 ec 0c             	sub    $0xc,%esp
  80dce4:	53                   	push   %ebx
  80dce5:	e8 e9 80 ff ff       	call   805dd3 <tcp_abort>
    tcp_input_pcb = NULL;
  80dcea:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dcf1:	00 00 00 
  80dcf4:	83 c4 10             	add    $0x10,%esp
  80dcf7:	e9 10 fb ff ff       	jmp    80d80c <tcp_input+0x3f5>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dcfc:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80dd00:	01 c0                	add    %eax,%eax
  80dd02:	eb 91                	jmp    80dc95 <tcp_input+0x87e>
    accepted_inseq = tcp_receive(pcb);
  80dd04:	89 d8                	mov    %ebx,%eax
  80dd06:	e8 2a ea ff ff       	call   80c735 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80dd0b:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80dd12:	0f 84 a8 fa ff ff    	je     80d7c0 <tcp_input+0x3a9>
  80dd18:	84 c0                	test   %al,%al
  80dd1a:	0f 84 a0 fa ff ff    	je     80d7c0 <tcp_input+0x3a9>
      tcp_ack_now(pcb);
  80dd20:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dd24:	83 ec 0c             	sub    $0xc,%esp
  80dd27:	53                   	push   %ebx
  80dd28:	e8 ac a5 ff ff       	call   8082d9 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80dd2d:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80dd34:	83 c4 10             	add    $0x10,%esp
  80dd37:	e9 84 fa ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
    tcp_receive(pcb);
  80dd3c:	89 d8                	mov    %ebx,%eax
  80dd3e:	e8 f2 e9 ff ff       	call   80c735 <tcp_receive>
    if (flags & TCP_FIN) {
  80dd43:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80dd4a:	a8 01                	test   $0x1,%al
  80dd4c:	0f 84 b7 00 00 00    	je     80de09 <tcp_input+0x9f2>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dd52:	a8 10                	test   $0x10,%al
  80dd54:	74 0a                	je     80dd60 <tcp_input+0x949>
  80dd56:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dd5b:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dd5e:	74 1c                	je     80dd7c <tcp_input+0x965>
        tcp_ack_now(pcb);
  80dd60:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dd64:	83 ec 0c             	sub    $0xc,%esp
  80dd67:	53                   	push   %ebx
  80dd68:	e8 6c a5 ff ff       	call   8082d9 <tcp_output>
        pcb->state = CLOSING;
  80dd6d:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80dd74:	83 c4 10             	add    $0x10,%esp
  80dd77:	e9 44 fa ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
        tcp_ack_now(pcb);
  80dd7c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dd80:	83 ec 0c             	sub    $0xc,%esp
  80dd83:	53                   	push   %ebx
  80dd84:	e8 50 a5 ff ff       	call   8082d9 <tcp_output>
        tcp_pcb_purge(pcb);
  80dd89:	89 1c 24             	mov    %ebx,(%esp)
  80dd8c:	e8 21 7d ff ff       	call   805ab2 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80dd91:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80dd96:	83 c4 10             	add    $0x10,%esp
  80dd99:	39 c3                	cmp    %eax,%ebx
  80dd9b:	74 11                	je     80ddae <tcp_input+0x997>
  80dd9d:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dda2:	ba 00 00 00 00       	mov    $0x0,%edx
  80dda7:	be 01 00 00 00       	mov    $0x1,%esi
  80ddac:	eb 2b                	jmp    80ddd9 <tcp_input+0x9c2>
  80ddae:	8b 40 0c             	mov    0xc(%eax),%eax
  80ddb1:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
        pcb->state = TIME_WAIT;
  80ddb6:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80ddbd:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80ddc2:	89 43 0c             	mov    %eax,0xc(%ebx)
  80ddc5:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80ddcb:	e8 76 45 ff ff       	call   802346 <tcp_timer_needed>
  80ddd0:	e9 eb f9 ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
  80ddd5:	89 f2                	mov    %esi,%edx
        TCP_RMV(&tcp_active_pcbs, pcb);
  80ddd7:	89 c8                	mov    %ecx,%eax
  80ddd9:	85 c0                	test   %eax,%eax
  80dddb:	74 1c                	je     80ddf9 <tcp_input+0x9e2>
  80dddd:	8b 48 0c             	mov    0xc(%eax),%ecx
  80dde0:	39 cb                	cmp    %ecx,%ebx
  80dde2:	75 f1                	jne    80ddd5 <tcp_input+0x9be>
  80dde4:	85 c9                	test   %ecx,%ecx
  80dde6:	74 ed                	je     80ddd5 <tcp_input+0x9be>
  80dde8:	84 d2                	test   %dl,%dl
  80ddea:	74 05                	je     80ddf1 <tcp_input+0x9da>
  80ddec:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80ddf1:	8b 53 0c             	mov    0xc(%ebx),%edx
  80ddf4:	89 50 0c             	mov    %edx,0xc(%eax)
  80ddf7:	eb bd                	jmp    80ddb6 <tcp_input+0x99f>
  80ddf9:	84 d2                	test   %dl,%dl
  80ddfb:	74 b9                	je     80ddb6 <tcp_input+0x99f>
  80ddfd:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80de04:	00 00 00 
  80de07:	eb ad                	jmp    80ddb6 <tcp_input+0x99f>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80de09:	a8 10                	test   $0x10,%al
  80de0b:	0f 84 af f9 ff ff    	je     80d7c0 <tcp_input+0x3a9>
  80de11:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80de16:	39 43 54             	cmp    %eax,0x54(%ebx)
  80de19:	0f 85 a1 f9 ff ff    	jne    80d7c0 <tcp_input+0x3a9>
      pcb->state = FIN_WAIT_2;
  80de1f:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80de26:	e9 95 f9 ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
    tcp_receive(pcb);
  80de2b:	89 d8                	mov    %ebx,%eax
  80de2d:	e8 03 e9 ff ff       	call   80c735 <tcp_receive>
    if (flags & TCP_FIN) {
  80de32:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80de39:	0f 84 81 f9 ff ff    	je     80d7c0 <tcp_input+0x3a9>
      tcp_ack_now(pcb);
  80de3f:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80de43:	83 ec 0c             	sub    $0xc,%esp
  80de46:	53                   	push   %ebx
  80de47:	e8 8d a4 ff ff       	call   8082d9 <tcp_output>
      tcp_pcb_purge(pcb);
  80de4c:	89 1c 24             	mov    %ebx,(%esp)
  80de4f:	e8 5e 7c ff ff       	call   805ab2 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80de54:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80de59:	83 c4 10             	add    $0x10,%esp
  80de5c:	39 c3                	cmp    %eax,%ebx
  80de5e:	74 11                	je     80de71 <tcp_input+0xa5a>
  80de60:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80de65:	b9 00 00 00 00       	mov    $0x0,%ecx
  80de6a:	be 01 00 00 00       	mov    $0x1,%esi
  80de6f:	eb 2b                	jmp    80de9c <tcp_input+0xa85>
  80de71:	8b 40 0c             	mov    0xc(%eax),%eax
  80de74:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80de79:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80de80:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80de85:	89 43 0c             	mov    %eax,0xc(%ebx)
  80de88:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80de8e:	e8 b3 44 ff ff       	call   802346 <tcp_timer_needed>
  80de93:	e9 28 f9 ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
  80de98:	89 f1                	mov    %esi,%ecx
      TCP_RMV(&tcp_active_pcbs, pcb);
  80de9a:	89 d0                	mov    %edx,%eax
  80de9c:	85 c0                	test   %eax,%eax
  80de9e:	74 1c                	je     80debc <tcp_input+0xaa5>
  80dea0:	8b 50 0c             	mov    0xc(%eax),%edx
  80dea3:	39 d3                	cmp    %edx,%ebx
  80dea5:	75 f1                	jne    80de98 <tcp_input+0xa81>
  80dea7:	85 d2                	test   %edx,%edx
  80dea9:	74 ed                	je     80de98 <tcp_input+0xa81>
  80deab:	84 c9                	test   %cl,%cl
  80dead:	74 05                	je     80deb4 <tcp_input+0xa9d>
  80deaf:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80deb4:	8b 53 0c             	mov    0xc(%ebx),%edx
  80deb7:	89 50 0c             	mov    %edx,0xc(%eax)
  80deba:	eb bd                	jmp    80de79 <tcp_input+0xa62>
  80debc:	84 c9                	test   %cl,%cl
  80debe:	74 b9                	je     80de79 <tcp_input+0xa62>
  80dec0:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80dec7:	00 00 00 
  80deca:	eb ad                	jmp    80de79 <tcp_input+0xa62>
    tcp_receive(pcb);
  80decc:	89 d8                	mov    %ebx,%eax
  80dece:	e8 62 e8 ff ff       	call   80c735 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80ded3:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80deda:	0f 84 e0 f8 ff ff    	je     80d7c0 <tcp_input+0x3a9>
  80dee0:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dee5:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dee8:	0f 85 d2 f8 ff ff    	jne    80d7c0 <tcp_input+0x3a9>
      tcp_ack_now(pcb);
  80deee:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80def2:	83 ec 0c             	sub    $0xc,%esp
  80def5:	53                   	push   %ebx
  80def6:	e8 de a3 ff ff       	call   8082d9 <tcp_output>
      tcp_pcb_purge(pcb);
  80defb:	89 1c 24             	mov    %ebx,(%esp)
  80defe:	e8 af 7b ff ff       	call   805ab2 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80df03:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80df08:	83 c4 10             	add    $0x10,%esp
  80df0b:	39 c3                	cmp    %eax,%ebx
  80df0d:	74 11                	je     80df20 <tcp_input+0xb09>
  80df0f:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80df14:	ba 00 00 00 00       	mov    $0x0,%edx
  80df19:	be 01 00 00 00       	mov    $0x1,%esi
  80df1e:	eb 2b                	jmp    80df4b <tcp_input+0xb34>
  80df20:	8b 40 0c             	mov    0xc(%eax),%eax
  80df23:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80df28:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80df2f:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80df34:	89 43 0c             	mov    %eax,0xc(%ebx)
  80df37:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80df3d:	e8 04 44 ff ff       	call   802346 <tcp_timer_needed>
  80df42:	e9 79 f8 ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
  80df47:	89 f2                	mov    %esi,%edx
      TCP_RMV(&tcp_active_pcbs, pcb);
  80df49:	89 c8                	mov    %ecx,%eax
  80df4b:	85 c0                	test   %eax,%eax
  80df4d:	74 1c                	je     80df6b <tcp_input+0xb54>
  80df4f:	8b 48 0c             	mov    0xc(%eax),%ecx
  80df52:	39 cb                	cmp    %ecx,%ebx
  80df54:	75 f1                	jne    80df47 <tcp_input+0xb30>
  80df56:	85 c9                	test   %ecx,%ecx
  80df58:	74 ed                	je     80df47 <tcp_input+0xb30>
  80df5a:	84 d2                	test   %dl,%dl
  80df5c:	74 05                	je     80df63 <tcp_input+0xb4c>
  80df5e:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80df63:	8b 53 0c             	mov    0xc(%ebx),%edx
  80df66:	89 50 0c             	mov    %edx,0xc(%eax)
  80df69:	eb bd                	jmp    80df28 <tcp_input+0xb11>
  80df6b:	84 d2                	test   %dl,%dl
  80df6d:	74 b9                	je     80df28 <tcp_input+0xb11>
  80df6f:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80df76:	00 00 00 
  80df79:	eb ad                	jmp    80df28 <tcp_input+0xb11>
    tcp_receive(pcb);
  80df7b:	89 d8                	mov    %ebx,%eax
  80df7d:	e8 b3 e7 ff ff       	call   80c735 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80df82:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80df89:	0f 84 31 f8 ff ff    	je     80d7c0 <tcp_input+0x3a9>
  80df8f:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80df94:	39 43 54             	cmp    %eax,0x54(%ebx)
  80df97:	0f 85 23 f8 ff ff    	jne    80d7c0 <tcp_input+0x3a9>
      recv_flags = TF_CLOSED;
  80df9d:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80dfa4:	e9 17 f8 ff ff       	jmp    80d7c0 <tcp_input+0x3a9>
    tcp_input_pcb = NULL;
  80dfa9:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dfb0:	00 00 00 
  80dfb3:	e9 12 f8 ff ff       	jmp    80d7ca <tcp_input+0x3b3>
      } else if (recv_flags & TF_CLOSED) {
  80dfb8:	a8 10                	test   $0x10,%al
  80dfba:	0f 85 96 00 00 00    	jne    80e056 <tcp_input+0xc3f>
        if (pcb->acked > 0) {
  80dfc0:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        err = ERR_OK;
  80dfc4:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80dfc9:	66 85 d2             	test   %dx,%dx
  80dfcc:	74 1a                	je     80dfe8 <tcp_input+0xbd1>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80dfce:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80dfd4:	85 c9                	test   %ecx,%ecx
  80dfd6:	74 10                	je     80dfe8 <tcp_input+0xbd1>
  80dfd8:	83 ec 04             	sub    $0x4,%esp
  80dfdb:	0f b7 d2             	movzwl %dx,%edx
  80dfde:	52                   	push   %edx
  80dfdf:	53                   	push   %ebx
  80dfe0:	ff 73 18             	pushl  0x18(%ebx)
  80dfe3:	ff d1                	call   *%ecx
  80dfe5:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80dfe8:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80dfee:	85 d2                	test   %edx,%edx
  80dff0:	0f 84 a9 00 00 00    	je     80e09f <tcp_input+0xc88>
          if(flags & TCP_PSH) {
  80dff6:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80dffd:	74 04                	je     80e003 <tcp_input+0xbec>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80dfff:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e003:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e009:	85 c0                	test   %eax,%eax
  80e00b:	74 6a                	je     80e077 <tcp_input+0xc60>
  80e00d:	6a 00                	push   $0x0
  80e00f:	52                   	push   %edx
  80e010:	53                   	push   %ebx
  80e011:	ff 73 18             	pushl  0x18(%ebx)
  80e014:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80e016:	83 c4 10             	add    $0x10,%esp
  80e019:	84 c0                	test   %al,%al
  80e01b:	75 68                	jne    80e085 <tcp_input+0xc6e>
        if (recv_flags & TF_GOT_FIN) {
  80e01d:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80e024:	74 1f                	je     80e045 <tcp_input+0xc2e>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80e026:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e02c:	85 c0                	test   %eax,%eax
  80e02e:	74 15                	je     80e045 <tcp_input+0xc2e>
  80e030:	6a 00                	push   $0x0
  80e032:	6a 00                	push   $0x0
  80e034:	53                   	push   %ebx
  80e035:	ff 73 18             	pushl  0x18(%ebx)
  80e038:	ff d0                	call   *%eax
  80e03a:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80e03d:	84 c0                	test   %al,%al
  80e03f:	0f 85 c7 f7 ff ff    	jne    80d80c <tcp_input+0x3f5>
          tcp_output(pcb);
  80e045:	83 ec 0c             	sub    $0xc,%esp
  80e048:	53                   	push   %ebx
  80e049:	e8 8b a2 ff ff       	call   8082d9 <tcp_output>
  80e04e:	83 c4 10             	add    $0x10,%esp
  80e051:	e9 b6 f7 ff ff       	jmp    80d80c <tcp_input+0x3f5>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e056:	83 ec 08             	sub    $0x8,%esp
  80e059:	53                   	push   %ebx
  80e05a:	68 3c b2 b3 00       	push   $0xb3b23c
  80e05f:	e8 cf 7a ff ff       	call   805b33 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e064:	83 c4 08             	add    $0x8,%esp
  80e067:	53                   	push   %ebx
  80e068:	6a 02                	push   $0x2
  80e06a:	e8 29 66 ff ff       	call   804698 <memp_free>
  80e06f:	83 c4 10             	add    $0x10,%esp
  80e072:	e9 95 f7 ff ff       	jmp    80d80c <tcp_input+0x3f5>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e077:	83 ec 0c             	sub    $0xc,%esp
  80e07a:	52                   	push   %edx
  80e07b:	e8 9b 69 ff ff       	call   804a1b <pbuf_free>
  80e080:	83 c4 10             	add    $0x10,%esp
  80e083:	eb 98                	jmp    80e01d <tcp_input+0xc06>
            pcb->refused_data = recv_data;
  80e085:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80e08a:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
        if (recv_flags & TF_GOT_FIN) {
  80e090:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80e097:	0f 84 6f f7 ff ff    	je     80d80c <tcp_input+0x3f5>
  80e09d:	eb 87                	jmp    80e026 <tcp_input+0xc0f>
  80e09f:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80e0a6:	74 95                	je     80e03d <tcp_input+0xc26>
  80e0a8:	e9 79 ff ff ff       	jmp    80e026 <tcp_input+0xc0f>
        tcphdr->dest, tcphdr->src);
  80e0ad:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
        &(iphdr->dest), &(iphdr->src),
  80e0b3:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
      tcp_rst(ackno, seqno + tcplen,
  80e0b8:	83 ec 08             	sub    $0x8,%esp
  80e0bb:	0f b7 0a             	movzwl (%edx),%ecx
  80e0be:	51                   	push   %ecx
  80e0bf:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e0c3:	52                   	push   %edx
  80e0c4:	8d 50 0c             	lea    0xc(%eax),%edx
  80e0c7:	52                   	push   %edx
  80e0c8:	83 c0 10             	add    $0x10,%eax
  80e0cb:	50                   	push   %eax
  80e0cc:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80e0d3:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80e0d9:	50                   	push   %eax
  80e0da:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80e0e0:	e8 9a a6 ff ff       	call   80877f <tcp_rst>
  80e0e5:	83 c4 20             	add    $0x20,%esp
  80e0e8:	eb 14                	jmp    80e0fe <tcp_input+0xce7>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80e0ea:	83 ec 0c             	sub    $0xc,%esp
  80e0ed:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80e0f1:	50                   	push   %eax
  80e0f2:	e8 6d 98 ff ff       	call   807964 <ntohs>
  80e0f7:	83 c4 10             	add    $0x10,%esp
  80e0fa:	a8 04                	test   $0x4,%al
  80e0fc:	74 af                	je     80e0ad <tcp_input+0xc96>
    pbuf_free(p);
  80e0fe:	83 ec 0c             	sub    $0xc,%esp
  80e101:	56                   	push   %esi
  80e102:	e8 14 69 ff ff       	call   804a1b <pbuf_free>
  80e107:	83 c4 10             	add    $0x10,%esp
  80e10a:	e9 77 f3 ff ff       	jmp    80d486 <tcp_input+0x6f>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80e10f:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80e115:	e9 46 f7 ff ff       	jmp    80d860 <tcp_input+0x449>

0080e11a <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80e11a:	f3 0f 1e fb          	endbr32 
  80e11e:	55                   	push   %ebp
  80e11f:	89 e5                	mov    %esp,%ebp
  80e121:	57                   	push   %edi
  80e122:	56                   	push   %esi
  80e123:	53                   	push   %ebx
  80e124:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80e127:	8b 45 08             	mov    0x8(%ebp),%eax
  80e12a:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80e12d:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e131:	50                   	push   %eax
  80e132:	e8 2d 98 ff ff       	call   807964 <ntohs>
  80e137:	89 c2                	mov    %eax,%edx

  prev = NULL;
  pcb = raw_pcbs;
  80e139:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e13f:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80e142:	b8 00 00 00 00       	mov    $0x0,%eax
  prev = NULL;
  80e147:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (pcb->protocol == proto) {
  80e14e:	0f b6 f2             	movzbl %dl,%esi
  while ((eaten == 0) && (pcb != NULL)) {
  80e151:	eb 11                	jmp    80e164 <raw_input+0x4a>
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80e153:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e156:	89 45 08             	mov    %eax,0x8(%ebp)
          eaten = 1;
  80e159:	b8 01 00 00 00       	mov    $0x1,%eax
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80e15e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80e161:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80e164:	84 c0                	test   %al,%al
  80e166:	75 55                	jne    80e1bd <raw_input+0xa3>
  80e168:	85 db                	test   %ebx,%ebx
  80e16a:	74 51                	je     80e1bd <raw_input+0xa3>
    if (pcb->protocol == proto) {
  80e16c:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  80e170:	b8 00 00 00 00       	mov    $0x0,%eax
  80e175:	39 f2                	cmp    %esi,%edx
  80e177:	75 e5                	jne    80e15e <raw_input+0x44>
      if (pcb->recv != NULL) {
  80e179:	8b 53 14             	mov    0x14(%ebx),%edx
  80e17c:	85 d2                	test   %edx,%edx
  80e17e:	74 de                	je     80e15e <raw_input+0x44>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e180:	8d 47 0c             	lea    0xc(%edi),%eax
  80e183:	50                   	push   %eax
  80e184:	ff 75 08             	pushl  0x8(%ebp)
  80e187:	53                   	push   %ebx
  80e188:	ff 73 18             	pushl  0x18(%ebx)
  80e18b:	ff d2                	call   *%edx
  80e18d:	83 c4 10             	add    $0x10,%esp
  80e190:	84 c0                	test   %al,%al
  80e192:	74 ca                	je     80e15e <raw_input+0x44>
          if (prev != NULL) {
  80e194:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e197:	85 c9                	test   %ecx,%ecx
  80e199:	74 b8                	je     80e153 <raw_input+0x39>
            prev->next = pcb->next;
  80e19b:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e19e:	89 41 0c             	mov    %eax,0xc(%ecx)
            pcb->next = raw_pcbs;
  80e1a1:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e1a6:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80e1a9:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
          eaten = 1;
  80e1af:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80e1b4:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80e1bb:	eb a1                	jmp    80e15e <raw_input+0x44>
  }
  return eaten;
}
  80e1bd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e1c0:	5b                   	pop    %ebx
  80e1c1:	5e                   	pop    %esi
  80e1c2:	5f                   	pop    %edi
  80e1c3:	5d                   	pop    %ebp
  80e1c4:	c3                   	ret    

0080e1c5 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e1c5:	f3 0f 1e fb          	endbr32 
  80e1c9:	55                   	push   %ebp
  80e1ca:	89 e5                	mov    %esp,%ebp
  80e1cc:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e1cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1d4:	85 d2                	test   %edx,%edx
  80e1d6:	74 02                	je     80e1da <raw_bind+0x15>
  80e1d8:	8b 02                	mov    (%edx),%eax
  80e1da:	8b 55 08             	mov    0x8(%ebp),%edx
  80e1dd:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80e1df:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1e4:	5d                   	pop    %ebp
  80e1e5:	c3                   	ret    

0080e1e6 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e1e6:	f3 0f 1e fb          	endbr32 
  80e1ea:	55                   	push   %ebp
  80e1eb:	89 e5                	mov    %esp,%ebp
  80e1ed:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e1f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1f5:	85 d2                	test   %edx,%edx
  80e1f7:	74 02                	je     80e1fb <raw_connect+0x15>
  80e1f9:	8b 02                	mov    (%edx),%eax
  80e1fb:	8b 55 08             	mov    0x8(%ebp),%edx
  80e1fe:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80e201:	b8 00 00 00 00       	mov    $0x0,%eax
  80e206:	5d                   	pop    %ebp
  80e207:	c3                   	ret    

0080e208 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e208:	f3 0f 1e fb          	endbr32 
  80e20c:	55                   	push   %ebp
  80e20d:	89 e5                	mov    %esp,%ebp
  80e20f:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e212:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e215:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e218:	8b 55 10             	mov    0x10(%ebp),%edx
  80e21b:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e21e:	5d                   	pop    %ebp
  80e21f:	c3                   	ret    

0080e220 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80e220:	f3 0f 1e fb          	endbr32 
  80e224:	55                   	push   %ebp
  80e225:	89 e5                	mov    %esp,%ebp
  80e227:	57                   	push   %edi
  80e228:	56                   	push   %esi
  80e229:	53                   	push   %ebx
  80e22a:	83 ec 14             	sub    $0x14,%esp
  80e22d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e230:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80e233:	6a 14                	push   $0x14
  80e235:	57                   	push   %edi
  80e236:	e8 0d 67 ff ff       	call   804948 <pbuf_header>
  80e23b:	83 c4 10             	add    $0x10,%esp
  80e23e:	84 c0                	test   %al,%al
  80e240:	74 52                	je     80e294 <raw_sendto+0x74>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80e242:	83 ec 04             	sub    $0x4,%esp
  80e245:	6a 00                	push   $0x0
  80e247:	6a 00                	push   $0x0
  80e249:	6a 01                	push   $0x1
  80e24b:	e8 95 68 ff ff       	call   804ae5 <pbuf_alloc>
  80e250:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80e252:	83 c4 10             	add    $0x10,%esp
  80e255:	85 c0                	test   %eax,%eax
  80e257:	0f 84 be 00 00 00    	je     80e31b <raw_sendto+0xfb>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e25d:	83 ec 08             	sub    $0x8,%esp
  80e260:	57                   	push   %edi
  80e261:	50                   	push   %eax
  80e262:	e8 96 6c ff ff       	call   804efd <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e267:	83 c4 04             	add    $0x4,%esp
  80e26a:	ff 75 10             	pushl  0x10(%ebp)
  80e26d:	e8 ac 84 ff ff       	call   80671e <ip_route>
  80e272:	83 c4 10             	add    $0x10,%esp
  80e275:	85 c0                	test   %eax,%eax
  80e277:	75 41                	jne    80e2ba <raw_sendto+0x9a>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e279:	39 f7                	cmp    %esi,%edi
  80e27b:	0f 84 a1 00 00 00    	je     80e322 <raw_sendto+0x102>
      pbuf_free(q);
  80e281:	83 ec 0c             	sub    $0xc,%esp
  80e284:	56                   	push   %esi
  80e285:	e8 91 67 ff ff       	call   804a1b <pbuf_free>
  80e28a:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80e28d:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e292:	eb 66                	jmp    80e2fa <raw_sendto+0xda>
    if(pbuf_header(q, -IP_HLEN)) {
  80e294:	83 ec 08             	sub    $0x8,%esp
  80e297:	6a ec                	push   $0xffffffec
  80e299:	57                   	push   %edi
  80e29a:	e8 a9 66 ff ff       	call   804948 <pbuf_header>
  80e29f:	83 c4 10             	add    $0x10,%esp
  80e2a2:	84 c0                	test   %al,%al
  80e2a4:	75 5e                	jne    80e304 <raw_sendto+0xe4>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e2a6:	83 ec 0c             	sub    $0xc,%esp
  80e2a9:	ff 75 10             	pushl  0x10(%ebp)
  80e2ac:	e8 6d 84 ff ff       	call   80671e <ip_route>
  80e2b1:	83 c4 10             	add    $0x10,%esp
  80e2b4:	85 c0                	test   %eax,%eax
  80e2b6:	74 71                	je     80e329 <raw_sendto+0x109>
    q = p;
  80e2b8:	89 fe                	mov    %edi,%esi
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e2ba:	89 da                	mov    %ebx,%edx
  80e2bc:	85 db                	test   %ebx,%ebx
  80e2be:	74 05                	je     80e2c5 <raw_sendto+0xa5>
  80e2c0:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e2c3:	75 03                	jne    80e2c8 <raw_sendto+0xa8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e2c5:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e2c8:	83 ec 04             	sub    $0x4,%esp
  80e2cb:	50                   	push   %eax
  80e2cc:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e2d0:	50                   	push   %eax
  80e2d1:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e2d5:	50                   	push   %eax
  80e2d6:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e2da:	50                   	push   %eax
  80e2db:	ff 75 10             	pushl  0x10(%ebp)
  80e2de:	52                   	push   %edx
  80e2df:	56                   	push   %esi
  80e2e0:	e8 c0 87 ff ff       	call   806aa5 <ip_output_if>
  80e2e5:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e2e7:	83 c4 20             	add    $0x20,%esp
  80e2ea:	39 f7                	cmp    %esi,%edi
  80e2ec:	74 0c                	je     80e2fa <raw_sendto+0xda>
    /* free the header */
    pbuf_free(q);
  80e2ee:	83 ec 0c             	sub    $0xc,%esp
  80e2f1:	56                   	push   %esi
  80e2f2:	e8 24 67 ff ff       	call   804a1b <pbuf_free>
  80e2f7:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80e2fa:	89 d8                	mov    %ebx,%eax
  80e2fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e2ff:	5b                   	pop    %ebx
  80e300:	5e                   	pop    %esi
  80e301:	5f                   	pop    %edi
  80e302:	5d                   	pop    %ebp
  80e303:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e304:	83 ec 04             	sub    $0x4,%esp
  80e307:	68 00 36 81 00       	push   $0x813600
  80e30c:	68 e3 00 00 00       	push   $0xe3
  80e311:	68 26 36 81 00       	push   $0x813626
  80e316:	e8 1c 06 00 00       	call   80e937 <_panic>
      return ERR_MEM;
  80e31b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80e320:	eb d8                	jmp    80e2fa <raw_sendto+0xda>
    return ERR_RTE;
  80e322:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e327:	eb d1                	jmp    80e2fa <raw_sendto+0xda>
  80e329:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e32e:	eb ca                	jmp    80e2fa <raw_sendto+0xda>

0080e330 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e330:	f3 0f 1e fb          	endbr32 
  80e334:	55                   	push   %ebp
  80e335:	89 e5                	mov    %esp,%ebp
  80e337:	83 ec 0c             	sub    $0xc,%esp
  80e33a:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e33d:	8d 50 04             	lea    0x4(%eax),%edx
  80e340:	52                   	push   %edx
  80e341:	ff 75 0c             	pushl  0xc(%ebp)
  80e344:	50                   	push   %eax
  80e345:	e8 d6 fe ff ff       	call   80e220 <raw_sendto>
}
  80e34a:	c9                   	leave  
  80e34b:	c3                   	ret    

0080e34c <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e34c:	f3 0f 1e fb          	endbr32 
  80e350:	55                   	push   %ebp
  80e351:	89 e5                	mov    %esp,%ebp
  80e353:	83 ec 08             	sub    $0x8,%esp
  80e356:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e359:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e35e:	39 c8                	cmp    %ecx,%eax
  80e360:	75 1b                	jne    80e37d <raw_remove+0x31>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e362:	8b 41 0c             	mov    0xc(%ecx),%eax
  80e365:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e36a:	83 ec 08             	sub    $0x8,%esp
  80e36d:	51                   	push   %ecx
  80e36e:	6a 00                	push   $0x0
  80e370:	e8 23 63 ff ff       	call   804698 <memp_free>
}
  80e375:	83 c4 10             	add    $0x10,%esp
  80e378:	c9                   	leave  
  80e379:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e37a:	8b 40 0c             	mov    0xc(%eax),%eax
  80e37d:	85 c0                	test   %eax,%eax
  80e37f:	74 e9                	je     80e36a <raw_remove+0x1e>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e381:	8b 50 0c             	mov    0xc(%eax),%edx
  80e384:	39 ca                	cmp    %ecx,%edx
  80e386:	75 f2                	jne    80e37a <raw_remove+0x2e>
  80e388:	85 d2                	test   %edx,%edx
  80e38a:	74 ee                	je     80e37a <raw_remove+0x2e>
        pcb2->next = pcb->next;
  80e38c:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e38f:	89 50 0c             	mov    %edx,0xc(%eax)
  80e392:	eb e6                	jmp    80e37a <raw_remove+0x2e>

0080e394 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e394:	f3 0f 1e fb          	endbr32 
  80e398:	55                   	push   %ebp
  80e399:	89 e5                	mov    %esp,%ebp
  80e39b:	56                   	push   %esi
  80e39c:	53                   	push   %ebx
  80e39d:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e3a0:	83 ec 0c             	sub    $0xc,%esp
  80e3a3:	6a 00                	push   $0x0
  80e3a5:	e8 94 62 ff ff       	call   80463e <memp_malloc>
  80e3aa:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e3ac:	83 c4 10             	add    $0x10,%esp
  80e3af:	85 c0                	test   %eax,%eax
  80e3b1:	74 27                	je     80e3da <raw_new+0x46>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e3b3:	83 ec 04             	sub    $0x4,%esp
  80e3b6:	6a 1c                	push   $0x1c
  80e3b8:	6a 00                	push   $0x0
  80e3ba:	50                   	push   %eax
  80e3bb:	e8 1a 0e 00 00       	call   80f1da <memset>
    pcb->protocol = proto;
  80e3c0:	89 f0                	mov    %esi,%eax
  80e3c2:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e3c5:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e3c9:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e3ce:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e3d1:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80e3d7:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80e3da:	89 d8                	mov    %ebx,%eax
  80e3dc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e3df:	5b                   	pop    %ebx
  80e3e0:	5e                   	pop    %esi
  80e3e1:	5d                   	pop    %ebp
  80e3e2:	c3                   	ret    

0080e3e3 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e3e3:	f3 0f 1e fb          	endbr32 
  80e3e7:	55                   	push   %ebp
  80e3e8:	89 e5                	mov    %esp,%ebp
  80e3ea:	57                   	push   %edi
  80e3eb:	56                   	push   %esi
  80e3ec:	53                   	push   %ebx
  80e3ed:	83 ec 28             	sub    $0x28,%esp
  80e3f0:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e3f3:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80e3f6:	0f b7 07             	movzwl (%edi),%eax
  80e3f9:	50                   	push   %eax
  80e3fa:	e8 65 95 ff ff       	call   807964 <ntohs>
  80e3ff:	66 c1 e8 06          	shr    $0x6,%ax
  80e403:	83 e0 3c             	and    $0x3c,%eax
  80e406:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e40a:	89 c6                	mov    %eax,%esi
  80e40c:	f7 de                	neg    %esi
  80e40e:	0f bf f6             	movswl %si,%esi
  80e411:	83 c4 08             	add    $0x8,%esp
  80e414:	56                   	push   %esi
  80e415:	53                   	push   %ebx
  80e416:	e8 2d 65 ff ff       	call   804948 <pbuf_header>
  80e41b:	83 c4 10             	add    $0x10,%esp
  80e41e:	84 c0                	test   %al,%al
  80e420:	75 67                	jne    80e489 <icmp_input+0xa6>
  80e422:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80e427:	76 60                	jbe    80e489 <icmp_input+0xa6>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e429:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e42c:	80 38 08             	cmpb   $0x8,(%eax)
  80e42f:	74 0e                	je     80e43f <icmp_input+0x5c>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e431:	83 ec 0c             	sub    $0xc,%esp
  80e434:	53                   	push   %ebx
  80e435:	e8 e1 65 ff ff       	call   804a1b <pbuf_free>
  return;
  80e43a:	83 c4 10             	add    $0x10,%esp
  80e43d:	eb 56                	jmp    80e495 <icmp_input+0xb2>
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e43f:	83 ec 08             	sub    $0x8,%esp
  80e442:	ff 75 0c             	pushl  0xc(%ebp)
  80e445:	8d 47 10             	lea    0x10(%edi),%eax
  80e448:	50                   	push   %eax
  80e449:	e8 89 82 ff ff       	call   8066d7 <ip_addr_isbroadcast>
  80e44e:	83 c4 10             	add    $0x10,%esp
  80e451:	84 c0                	test   %al,%al
  80e453:	75 48                	jne    80e49d <icmp_input+0xba>
  80e455:	8b 47 10             	mov    0x10(%edi),%eax
  80e458:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e45b:	83 ec 0c             	sub    $0xc,%esp
  80e45e:	68 00 00 00 f0       	push   $0xf0000000
  80e463:	e8 3a 97 ff ff       	call   807ba2 <ntohl>
  80e468:	23 45 e0             	and    -0x20(%ebp),%eax
  80e46b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e46e:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e475:	e8 28 97 ff ff       	call   807ba2 <ntohl>
  80e47a:	83 c4 10             	add    $0x10,%esp
  80e47d:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e480:	74 1b                	je     80e49d <icmp_input+0xba>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e482:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e487:	77 22                	ja     80e4ab <icmp_input+0xc8>
lenerr:
  pbuf_free(p);
  80e489:	83 ec 0c             	sub    $0xc,%esp
  80e48c:	53                   	push   %ebx
  80e48d:	e8 89 65 ff ff       	call   804a1b <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e492:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e495:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e498:	5b                   	pop    %ebx
  80e499:	5e                   	pop    %esi
  80e49a:	5f                   	pop    %edi
  80e49b:	5d                   	pop    %ebp
  80e49c:	c3                   	ret    
      pbuf_free(p);
  80e49d:	83 ec 0c             	sub    $0xc,%esp
  80e4a0:	53                   	push   %ebx
  80e4a1:	e8 75 65 ff ff       	call   804a1b <pbuf_free>
      return;
  80e4a6:	83 c4 10             	add    $0x10,%esp
  80e4a9:	eb ea                	jmp    80e495 <icmp_input+0xb2>
    if (inet_chksum_pbuf(p) != 0) {
  80e4ab:	83 ec 0c             	sub    $0xc,%esp
  80e4ae:	53                   	push   %ebx
  80e4af:	e8 7f 93 ff ff       	call   807833 <inet_chksum_pbuf>
  80e4b4:	83 c4 10             	add    $0x10,%esp
  80e4b7:	66 85 c0             	test   %ax,%ax
  80e4ba:	0f 85 96 00 00 00    	jne    80e556 <icmp_input+0x173>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e4c0:	83 ec 08             	sub    $0x8,%esp
  80e4c3:	6a 22                	push   $0x22
  80e4c5:	53                   	push   %ebx
  80e4c6:	e8 7d 64 ff ff       	call   804948 <pbuf_header>
  80e4cb:	83 c4 10             	add    $0x10,%esp
  80e4ce:	84 c0                	test   %al,%al
  80e4d0:	0f 84 fb 00 00 00    	je     80e5d1 <icmp_input+0x1ee>
      if (pbuf_header(p, hlen)) {
  80e4d6:	83 ec 08             	sub    $0x8,%esp
  80e4d9:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e4dd:	50                   	push   %eax
  80e4de:	53                   	push   %ebx
  80e4df:	e8 64 64 ff ff       	call   804948 <pbuf_header>
  80e4e4:	83 c4 10             	add    $0x10,%esp
  80e4e7:	84 c0                	test   %al,%al
  80e4e9:	75 7c                	jne    80e567 <icmp_input+0x184>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e4eb:	83 ec 04             	sub    $0x4,%esp
  80e4ee:	6a 00                	push   $0x0
  80e4f0:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e4f4:	50                   	push   %eax
  80e4f5:	6a 02                	push   $0x2
  80e4f7:	e8 e9 65 ff ff       	call   804ae5 <pbuf_alloc>
  80e4fc:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e4ff:	83 c4 10             	add    $0x10,%esp
  80e502:	85 c0                	test   %eax,%eax
  80e504:	74 75                	je     80e57b <icmp_input+0x198>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e506:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e509:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e50d:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e511:	83 c0 08             	add    $0x8,%eax
  80e514:	39 c2                	cmp    %eax,%edx
  80e516:	72 74                	jb     80e58c <icmp_input+0x1a9>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e518:	83 ec 08             	sub    $0x8,%esp
  80e51b:	53                   	push   %ebx
  80e51c:	ff 75 e0             	pushl  -0x20(%ebp)
  80e51f:	e8 a8 6a ff ff       	call   804fcc <pbuf_copy>
  80e524:	83 c4 10             	add    $0x10,%esp
  80e527:	84 c0                	test   %al,%al
  80e529:	75 78                	jne    80e5a3 <icmp_input+0x1c0>
      iphdr = r->payload;
  80e52b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e52e:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e531:	83 ec 08             	sub    $0x8,%esp
  80e534:	56                   	push   %esi
  80e535:	50                   	push   %eax
  80e536:	e8 0d 64 ff ff       	call   804948 <pbuf_header>
  80e53b:	83 c4 10             	add    $0x10,%esp
  80e53e:	84 c0                	test   %al,%al
  80e540:	75 78                	jne    80e5ba <icmp_input+0x1d7>
      pbuf_free(p);
  80e542:	83 ec 0c             	sub    $0xc,%esp
  80e545:	53                   	push   %ebx
  80e546:	e8 d0 64 ff ff       	call   804a1b <pbuf_free>
  80e54b:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e54e:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e551:	e9 91 00 00 00       	jmp    80e5e7 <icmp_input+0x204>
      pbuf_free(p);
  80e556:	83 ec 0c             	sub    $0xc,%esp
  80e559:	53                   	push   %ebx
  80e55a:	e8 bc 64 ff ff       	call   804a1b <pbuf_free>
      return;
  80e55f:	83 c4 10             	add    $0x10,%esp
  80e562:	e9 2e ff ff ff       	jmp    80e495 <icmp_input+0xb2>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e567:	83 ec 04             	sub    $0x4,%esp
  80e56a:	68 3c 36 81 00       	push   $0x81363c
  80e56f:	6a 7b                	push   $0x7b
  80e571:	68 30 37 81 00       	push   $0x813730
  80e576:	e8 bc 03 00 00       	call   80e937 <_panic>
  pbuf_free(p);
  80e57b:	83 ec 0c             	sub    $0xc,%esp
  80e57e:	53                   	push   %ebx
  80e57f:	e8 97 64 ff ff       	call   804a1b <pbuf_free>
  return;
  80e584:	83 c4 10             	add    $0x10,%esp
  80e587:	e9 09 ff ff ff       	jmp    80e495 <icmp_input+0xb2>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e58c:	83 ec 04             	sub    $0x4,%esp
  80e58f:	68 70 36 81 00       	push   $0x813670
  80e594:	68 84 00 00 00       	push   $0x84
  80e599:	68 30 37 81 00       	push   $0x813730
  80e59e:	e8 94 03 00 00       	call   80e937 <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e5a3:	83 ec 04             	sub    $0x4,%esp
  80e5a6:	68 a8 36 81 00       	push   $0x8136a8
  80e5ab:	68 88 00 00 00       	push   $0x88
  80e5b0:	68 30 37 81 00       	push   $0x813730
  80e5b5:	e8 7d 03 00 00       	call   80e937 <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e5ba:	83 ec 04             	sub    $0x4,%esp
  80e5bd:	68 d0 36 81 00       	push   $0x8136d0
  80e5c2:	68 8e 00 00 00       	push   $0x8e
  80e5c7:	68 30 37 81 00       	push   $0x813730
  80e5cc:	e8 66 03 00 00       	call   80e937 <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e5d1:	83 ec 08             	sub    $0x8,%esp
  80e5d4:	6a de                	push   $0xffffffde
  80e5d6:	53                   	push   %ebx
  80e5d7:	e8 6c 63 ff ff       	call   804948 <pbuf_header>
  80e5dc:	83 c4 10             	add    $0x10,%esp
  80e5df:	84 c0                	test   %al,%al
  80e5e1:	0f 85 d3 00 00 00    	jne    80e6ba <icmp_input+0x2d7>
    iecho = p->payload;
  80e5e7:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e5ea:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e5ed:	8b 57 10             	mov    0x10(%edi),%edx
  80e5f0:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e5f3:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e5f6:	83 ec 0c             	sub    $0xc,%esp
  80e5f9:	0f b7 06             	movzwl (%esi),%eax
  80e5fc:	50                   	push   %eax
  80e5fd:	e8 62 93 ff ff       	call   807964 <ntohs>
  80e602:	0f b6 c0             	movzbl %al,%eax
  80e605:	89 04 24             	mov    %eax,(%esp)
  80e608:	e8 46 93 ff ff       	call   807953 <htons>
  80e60d:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e610:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e614:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e618:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e61f:	e8 2f 93 ff ff       	call   807953 <htons>
  80e624:	83 c4 10             	add    $0x10,%esp
  80e627:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e62b:	0f 82 a0 00 00 00    	jb     80e6d1 <icmp_input+0x2ee>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e631:	83 ec 0c             	sub    $0xc,%esp
  80e634:	68 00 08 00 00       	push   $0x800
  80e639:	e8 15 93 ff ff       	call   807953 <htons>
  80e63e:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e642:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80e646:	66 89 46 02          	mov    %ax,0x2(%esi)
  80e64a:	83 c4 10             	add    $0x10,%esp
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e64d:	83 ec 0c             	sub    $0xc,%esp
  80e650:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e654:	50                   	push   %eax
  80e655:	e8 0a 93 ff ff       	call   807964 <ntohs>
  80e65a:	66 0d 00 ff          	or     $0xff00,%ax
  80e65e:	0f b7 c0             	movzwl %ax,%eax
  80e661:	89 04 24             	mov    %eax,(%esp)
  80e664:	e8 ea 92 ff ff       	call   807953 <htons>
  80e669:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e66d:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e673:	83 c4 08             	add    $0x8,%esp
  80e676:	6a 14                	push   $0x14
  80e678:	57                   	push   %edi
  80e679:	e8 9b 91 ff ff       	call   807819 <inet_chksum>
  80e67e:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e682:	83 c4 08             	add    $0x8,%esp
  80e685:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e689:	50                   	push   %eax
  80e68a:	53                   	push   %ebx
  80e68b:	e8 b8 62 ff ff       	call   804948 <pbuf_header>
  80e690:	83 c4 10             	add    $0x10,%esp
  80e693:	84 c0                	test   %al,%al
  80e695:	75 53                	jne    80e6ea <icmp_input+0x307>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e697:	83 ec 04             	sub    $0x4,%esp
  80e69a:	ff 75 0c             	pushl  0xc(%ebp)
  80e69d:	6a 01                	push   $0x1
  80e69f:	6a 00                	push   $0x0
  80e6a1:	68 ff 00 00 00       	push   $0xff
  80e6a6:	6a 00                	push   $0x0
  80e6a8:	83 c7 0c             	add    $0xc,%edi
  80e6ab:	57                   	push   %edi
  80e6ac:	53                   	push   %ebx
  80e6ad:	e8 f3 83 ff ff       	call   806aa5 <ip_output_if>
  80e6b2:	83 c4 20             	add    $0x20,%esp
  80e6b5:	e9 77 fd ff ff       	jmp    80e431 <icmp_input+0x4e>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e6ba:	83 ec 04             	sub    $0x4,%esp
  80e6bd:	68 d0 36 81 00       	push   $0x8136d0
  80e6c2:	68 98 00 00 00       	push   $0x98
  80e6c7:	68 30 37 81 00       	push   $0x813730
  80e6cc:	e8 66 02 00 00       	call   80e937 <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e6d1:	83 ec 0c             	sub    $0xc,%esp
  80e6d4:	68 00 08 00 00       	push   $0x800
  80e6d9:	e8 75 92 ff ff       	call   807953 <htons>
  80e6de:	66 01 46 02          	add    %ax,0x2(%esi)
  80e6e2:	83 c4 10             	add    $0x10,%esp
  80e6e5:	e9 63 ff ff ff       	jmp    80e64d <icmp_input+0x26a>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e6ea:	83 ec 04             	sub    $0x4,%esp
  80e6ed:	68 98 27 81 00       	push   $0x812798
  80e6f2:	68 b9 00 00 00       	push   $0xb9
  80e6f7:	68 30 37 81 00       	push   $0x813730
  80e6fc:	e8 36 02 00 00       	call   80e937 <_panic>

0080e701 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e701:	f3 0f 1e fb          	endbr32 
  80e705:	55                   	push   %ebp
  80e706:	89 e5                	mov    %esp,%ebp
  80e708:	57                   	push   %edi
  80e709:	56                   	push   %esi
  80e70a:	53                   	push   %ebx
  80e70b:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e70e:	6a 00                	push   $0x0
  80e710:	6a 24                	push   $0x24
  80e712:	6a 01                	push   $0x1
  80e714:	e8 cc 63 ff ff       	call   804ae5 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e719:	83 c4 10             	add    $0x10,%esp
  80e71c:	85 c0                	test   %eax,%eax
  80e71e:	0f 84 a5 00 00 00    	je     80e7c9 <icmp_dest_unreach+0xc8>
  80e724:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e726:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e72b:	0f 86 a0 00 00 00    	jbe    80e7d1 <icmp_dest_unreach+0xd0>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e731:	8b 45 08             	mov    0x8(%ebp),%eax
  80e734:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e737:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e73a:	83 ec 0c             	sub    $0xc,%esp
  80e73d:	0f b7 06             	movzwl (%esi),%eax
  80e740:	50                   	push   %eax
  80e741:	e8 1e 92 ff ff       	call   807964 <ntohs>
  80e746:	0f b6 c0             	movzbl %al,%eax
  80e749:	80 cc 03             	or     $0x3,%ah
  80e74c:	89 04 24             	mov    %eax,(%esp)
  80e74f:	e8 ff 91 ff ff       	call   807953 <htons>
  80e754:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e757:	0f b7 c0             	movzwl %ax,%eax
  80e75a:	89 04 24             	mov    %eax,(%esp)
  80e75d:	e8 02 92 ff ff       	call   807964 <ntohs>
  80e762:	b0 00                	mov    $0x0,%al
  80e764:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e768:	0f b7 c0             	movzwl %ax,%eax
  80e76b:	89 04 24             	mov    %eax,(%esp)
  80e76e:	e8 e0 91 ff ff       	call   807953 <htons>
  80e773:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e776:	83 c4 0c             	add    $0xc,%esp
  80e779:	6a 1c                	push   $0x1c
  80e77b:	8b 45 08             	mov    0x8(%ebp),%eax
  80e77e:	ff 70 04             	pushl  0x4(%eax)
  80e781:	8b 43 04             	mov    0x4(%ebx),%eax
  80e784:	83 c0 08             	add    $0x8,%eax
  80e787:	50                   	push   %eax
  80e788:	e8 ff 0a 00 00       	call   80f28c <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e78d:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e793:	83 c4 08             	add    $0x8,%esp
  80e796:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e79a:	50                   	push   %eax
  80e79b:	56                   	push   %esi
  80e79c:	e8 78 90 ff ff       	call   807819 <inet_chksum>
  80e7a1:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e7a5:	83 c4 08             	add    $0x8,%esp
  80e7a8:	6a 01                	push   $0x1
  80e7aa:	6a 00                	push   $0x0
  80e7ac:	68 ff 00 00 00       	push   $0xff
  80e7b1:	83 c7 0c             	add    $0xc,%edi
  80e7b4:	57                   	push   %edi
  80e7b5:	6a 00                	push   $0x0
  80e7b7:	53                   	push   %ebx
  80e7b8:	e8 6e 84 ff ff       	call   806c2b <ip_output>
  pbuf_free(q);
  80e7bd:	83 c4 14             	add    $0x14,%esp
  80e7c0:	53                   	push   %ebx
  80e7c1:	e8 55 62 ff ff       	call   804a1b <pbuf_free>
  80e7c6:	83 c4 10             	add    $0x10,%esp
}
  80e7c9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e7cc:	5b                   	pop    %ebx
  80e7cd:	5e                   	pop    %esi
  80e7ce:	5f                   	pop    %edi
  80e7cf:	5d                   	pop    %ebp
  80e7d0:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e7d1:	83 ec 04             	sub    $0x4,%esp
  80e7d4:	68 04 37 81 00       	push   $0x813704
  80e7d9:	68 ee 00 00 00       	push   $0xee
  80e7de:	68 30 37 81 00       	push   $0x813730
  80e7e3:	e8 4f 01 00 00       	call   80e937 <_panic>

0080e7e8 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e7e8:	f3 0f 1e fb          	endbr32 
  80e7ec:	55                   	push   %ebp
  80e7ed:	89 e5                	mov    %esp,%ebp
  80e7ef:	57                   	push   %edi
  80e7f0:	56                   	push   %esi
  80e7f1:	53                   	push   %ebx
  80e7f2:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e7f5:	6a 00                	push   $0x0
  80e7f7:	6a 24                	push   $0x24
  80e7f9:	6a 01                	push   $0x1
  80e7fb:	e8 e5 62 ff ff       	call   804ae5 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e800:	83 c4 10             	add    $0x10,%esp
  80e803:	85 c0                	test   %eax,%eax
  80e805:	0f 84 a5 00 00 00    	je     80e8b0 <icmp_time_exceeded+0xc8>
  80e80b:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e80d:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e812:	0f 86 a0 00 00 00    	jbe    80e8b8 <icmp_time_exceeded+0xd0>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e818:	8b 45 08             	mov    0x8(%ebp),%eax
  80e81b:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e81e:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e821:	83 ec 0c             	sub    $0xc,%esp
  80e824:	0f b7 06             	movzwl (%esi),%eax
  80e827:	50                   	push   %eax
  80e828:	e8 37 91 ff ff       	call   807964 <ntohs>
  80e82d:	0f b6 c0             	movzbl %al,%eax
  80e830:	80 cc 0b             	or     $0xb,%ah
  80e833:	89 04 24             	mov    %eax,(%esp)
  80e836:	e8 18 91 ff ff       	call   807953 <htons>
  80e83b:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e83e:	0f b7 c0             	movzwl %ax,%eax
  80e841:	89 04 24             	mov    %eax,(%esp)
  80e844:	e8 1b 91 ff ff       	call   807964 <ntohs>
  80e849:	b0 00                	mov    $0x0,%al
  80e84b:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e84f:	0f b7 c0             	movzwl %ax,%eax
  80e852:	89 04 24             	mov    %eax,(%esp)
  80e855:	e8 f9 90 ff ff       	call   807953 <htons>
  80e85a:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e85d:	83 c4 0c             	add    $0xc,%esp
  80e860:	6a 1c                	push   $0x1c
  80e862:	8b 45 08             	mov    0x8(%ebp),%eax
  80e865:	ff 70 04             	pushl  0x4(%eax)
  80e868:	8b 43 04             	mov    0x4(%ebx),%eax
  80e86b:	83 c0 08             	add    $0x8,%eax
  80e86e:	50                   	push   %eax
  80e86f:	e8 18 0a 00 00       	call   80f28c <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e874:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e87a:	83 c4 08             	add    $0x8,%esp
  80e87d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e881:	50                   	push   %eax
  80e882:	56                   	push   %esi
  80e883:	e8 91 8f ff ff       	call   807819 <inet_chksum>
  80e888:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e88c:	83 c4 08             	add    $0x8,%esp
  80e88f:	6a 01                	push   $0x1
  80e891:	6a 00                	push   $0x0
  80e893:	68 ff 00 00 00       	push   $0xff
  80e898:	83 c7 0c             	add    $0xc,%edi
  80e89b:	57                   	push   %edi
  80e89c:	6a 00                	push   $0x0
  80e89e:	53                   	push   %ebx
  80e89f:	e8 87 83 ff ff       	call   806c2b <ip_output>
  pbuf_free(q);
  80e8a4:	83 c4 14             	add    $0x14,%esp
  80e8a7:	53                   	push   %ebx
  80e8a8:	e8 6e 61 ff ff       	call   804a1b <pbuf_free>
  80e8ad:	83 c4 10             	add    $0x10,%esp
}
  80e8b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e8b3:	5b                   	pop    %ebx
  80e8b4:	5e                   	pop    %esi
  80e8b5:	5f                   	pop    %edi
  80e8b6:	5d                   	pop    %ebp
  80e8b7:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e8b8:	83 ec 04             	sub    $0x4,%esp
  80e8bb:	68 04 37 81 00       	push   $0x813704
  80e8c0:	68 1d 01 00 00       	push   $0x11d
  80e8c5:	68 30 37 81 00       	push   $0x813730
  80e8ca:	e8 68 00 00 00       	call   80e937 <_panic>

0080e8cf <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e8cf:	f3 0f 1e fb          	endbr32 
  80e8d3:	55                   	push   %ebp
  80e8d4:	89 e5                	mov    %esp,%ebp
  80e8d6:	56                   	push   %esi
  80e8d7:	53                   	push   %ebx
  80e8d8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e8db:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80e8de:	e8 68 0b 00 00       	call   80f44b <sys_getenvid>
  80e8e3:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e8e8:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e8eb:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e8f0:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e8f5:	85 db                	test   %ebx,%ebx
  80e8f7:	7e 07                	jle    80e900 <libmain+0x31>
		binaryname = argv[0];
  80e8f9:	8b 06                	mov    (%esi),%eax
  80e8fb:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e900:	83 ec 08             	sub    $0x8,%esp
  80e903:	56                   	push   %esi
  80e904:	53                   	push   %ebx
  80e905:	e8 8c 1c ff ff       	call   800596 <umain>

	// exit gracefully
	exit();
  80e90a:	e8 0a 00 00 00       	call   80e919 <exit>
}
  80e90f:	83 c4 10             	add    $0x10,%esp
  80e912:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e915:	5b                   	pop    %ebx
  80e916:	5e                   	pop    %esi
  80e917:	5d                   	pop    %ebp
  80e918:	c3                   	ret    

0080e919 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e919:	f3 0f 1e fb          	endbr32 
  80e91d:	55                   	push   %ebp
  80e91e:	89 e5                	mov    %esp,%ebp
  80e920:	83 ec 08             	sub    $0x8,%esp
	// cprintf("[%08x] called exit\n", thisenv->env_id);
	close_all();
  80e923:	e8 83 12 00 00       	call   80fbab <close_all>
	sys_env_destroy(0);
  80e928:	83 ec 0c             	sub    $0xc,%esp
  80e92b:	6a 00                	push   $0x0
  80e92d:	e8 f5 0a 00 00       	call   80f427 <sys_env_destroy>
}
  80e932:	83 c4 10             	add    $0x10,%esp
  80e935:	c9                   	leave  
  80e936:	c3                   	ret    

0080e937 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e937:	f3 0f 1e fb          	endbr32 
  80e93b:	55                   	push   %ebp
  80e93c:	89 e5                	mov    %esp,%ebp
  80e93e:	56                   	push   %esi
  80e93f:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e940:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e943:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e949:	e8 fd 0a 00 00       	call   80f44b <sys_getenvid>
  80e94e:	83 ec 0c             	sub    $0xc,%esp
  80e951:	ff 75 0c             	pushl  0xc(%ebp)
  80e954:	ff 75 08             	pushl  0x8(%ebp)
  80e957:	56                   	push   %esi
  80e958:	50                   	push   %eax
  80e959:	68 54 37 81 00       	push   $0x813754
  80e95e:	e8 bb 00 00 00       	call   80ea1e <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e963:	83 c4 18             	add    $0x18,%esp
  80e966:	53                   	push   %ebx
  80e967:	ff 75 10             	pushl  0x10(%ebp)
  80e96a:	e8 5a 00 00 00       	call   80e9c9 <vcprintf>
	cprintf("\n");
  80e96f:	c7 04 24 28 13 81 00 	movl   $0x811328,(%esp)
  80e976:	e8 a3 00 00 00       	call   80ea1e <cprintf>
  80e97b:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e97e:	cc                   	int3   
  80e97f:	eb fd                	jmp    80e97e <_panic+0x47>

0080e981 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e981:	f3 0f 1e fb          	endbr32 
  80e985:	55                   	push   %ebp
  80e986:	89 e5                	mov    %esp,%ebp
  80e988:	53                   	push   %ebx
  80e989:	83 ec 04             	sub    $0x4,%esp
  80e98c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e98f:	8b 13                	mov    (%ebx),%edx
  80e991:	8d 42 01             	lea    0x1(%edx),%eax
  80e994:	89 03                	mov    %eax,(%ebx)
  80e996:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e999:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e99d:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e9a2:	74 09                	je     80e9ad <putch+0x2c>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e9a4:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e9a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e9ab:	c9                   	leave  
  80e9ac:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e9ad:	83 ec 08             	sub    $0x8,%esp
  80e9b0:	68 ff 00 00 00       	push   $0xff
  80e9b5:	8d 43 08             	lea    0x8(%ebx),%eax
  80e9b8:	50                   	push   %eax
  80e9b9:	e8 24 0a 00 00       	call   80f3e2 <sys_cputs>
		b->idx = 0;
  80e9be:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e9c4:	83 c4 10             	add    $0x10,%esp
  80e9c7:	eb db                	jmp    80e9a4 <putch+0x23>

0080e9c9 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e9c9:	f3 0f 1e fb          	endbr32 
  80e9cd:	55                   	push   %ebp
  80e9ce:	89 e5                	mov    %esp,%ebp
  80e9d0:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e9d6:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e9dd:	00 00 00 
	b.cnt = 0;
  80e9e0:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e9e7:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e9ea:	ff 75 0c             	pushl  0xc(%ebp)
  80e9ed:	ff 75 08             	pushl  0x8(%ebp)
  80e9f0:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e9f6:	50                   	push   %eax
  80e9f7:	68 81 e9 80 00       	push   $0x80e981
  80e9fc:	e8 20 01 00 00       	call   80eb21 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80ea01:	83 c4 08             	add    $0x8,%esp
  80ea04:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80ea0a:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80ea10:	50                   	push   %eax
  80ea11:	e8 cc 09 00 00       	call   80f3e2 <sys_cputs>

	return b.cnt;
}
  80ea16:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80ea1c:	c9                   	leave  
  80ea1d:	c3                   	ret    

0080ea1e <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80ea1e:	f3 0f 1e fb          	endbr32 
  80ea22:	55                   	push   %ebp
  80ea23:	89 e5                	mov    %esp,%ebp
  80ea25:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80ea28:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80ea2b:	50                   	push   %eax
  80ea2c:	ff 75 08             	pushl  0x8(%ebp)
  80ea2f:	e8 95 ff ff ff       	call   80e9c9 <vcprintf>
	va_end(ap);

	return cnt;
}
  80ea34:	c9                   	leave  
  80ea35:	c3                   	ret    

0080ea36 <printnum>:
// padc --pad char
// putdat --put digit at(??)
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80ea36:	55                   	push   %ebp
  80ea37:	89 e5                	mov    %esp,%ebp
  80ea39:	57                   	push   %edi
  80ea3a:	56                   	push   %esi
  80ea3b:	53                   	push   %ebx
  80ea3c:	83 ec 1c             	sub    $0x1c,%esp
  80ea3f:	89 c7                	mov    %eax,%edi
  80ea41:	89 d6                	mov    %edx,%esi
  80ea43:	8b 45 08             	mov    0x8(%ebp),%eax
  80ea46:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ea49:	89 d1                	mov    %edx,%ecx
  80ea4b:	89 c2                	mov    %eax,%edx
  80ea4d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ea50:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80ea53:	8b 45 10             	mov    0x10(%ebp),%eax
  80ea56:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {// 非个位数 即least significant digit
  80ea59:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ea5c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80ea63:	39 c2                	cmp    %eax,%edx
  80ea65:	1b 4d e4             	sbb    -0x1c(%ebp),%ecx
  80ea68:	72 3e                	jb     80eaa8 <printnum+0x72>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80ea6a:	83 ec 0c             	sub    $0xc,%esp
  80ea6d:	ff 75 18             	pushl  0x18(%ebp)
  80ea70:	83 eb 01             	sub    $0x1,%ebx
  80ea73:	53                   	push   %ebx
  80ea74:	50                   	push   %eax
  80ea75:	83 ec 08             	sub    $0x8,%esp
  80ea78:	ff 75 e4             	pushl  -0x1c(%ebp)
  80ea7b:	ff 75 e0             	pushl  -0x20(%ebp)
  80ea7e:	ff 75 dc             	pushl  -0x24(%ebp)
  80ea81:	ff 75 d8             	pushl  -0x28(%ebp)
  80ea84:	e8 b7 24 00 00       	call   810f40 <__udivdi3>
  80ea89:	83 c4 18             	add    $0x18,%esp
  80ea8c:	52                   	push   %edx
  80ea8d:	50                   	push   %eax
  80ea8e:	89 f2                	mov    %esi,%edx
  80ea90:	89 f8                	mov    %edi,%eax
  80ea92:	e8 9f ff ff ff       	call   80ea36 <printnum>
  80ea97:	83 c4 20             	add    $0x20,%esp
  80ea9a:	eb 13                	jmp    80eaaf <printnum+0x79>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80ea9c:	83 ec 08             	sub    $0x8,%esp
  80ea9f:	56                   	push   %esi
  80eaa0:	ff 75 18             	pushl  0x18(%ebp)
  80eaa3:	ff d7                	call   *%edi
  80eaa5:	83 c4 10             	add    $0x10,%esp
		while (--width > 0)
  80eaa8:	83 eb 01             	sub    $0x1,%ebx
  80eaab:	85 db                	test   %ebx,%ebx
  80eaad:	7f ed                	jg     80ea9c <printnum+0x66>
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80eaaf:	83 ec 08             	sub    $0x8,%esp
  80eab2:	56                   	push   %esi
  80eab3:	83 ec 04             	sub    $0x4,%esp
  80eab6:	ff 75 e4             	pushl  -0x1c(%ebp)
  80eab9:	ff 75 e0             	pushl  -0x20(%ebp)
  80eabc:	ff 75 dc             	pushl  -0x24(%ebp)
  80eabf:	ff 75 d8             	pushl  -0x28(%ebp)
  80eac2:	e8 89 25 00 00       	call   811050 <__umoddi3>
  80eac7:	83 c4 14             	add    $0x14,%esp
  80eaca:	0f be 80 77 37 81 00 	movsbl 0x813777(%eax),%eax
  80ead1:	50                   	push   %eax
  80ead2:	ff d7                	call   *%edi
}
  80ead4:	83 c4 10             	add    $0x10,%esp
  80ead7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eada:	5b                   	pop    %ebx
  80eadb:	5e                   	pop    %esi
  80eadc:	5f                   	pop    %edi
  80eadd:	5d                   	pop    %ebp
  80eade:	c3                   	ret    

0080eadf <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80eadf:	f3 0f 1e fb          	endbr32 
  80eae3:	55                   	push   %ebp
  80eae4:	89 e5                	mov    %esp,%ebp
  80eae6:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80eae9:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80eaed:	8b 10                	mov    (%eax),%edx
  80eaef:	3b 50 04             	cmp    0x4(%eax),%edx
  80eaf2:	73 0a                	jae    80eafe <sprintputch+0x1f>
		*b->buf++ = ch;
  80eaf4:	8d 4a 01             	lea    0x1(%edx),%ecx
  80eaf7:	89 08                	mov    %ecx,(%eax)
  80eaf9:	8b 45 08             	mov    0x8(%ebp),%eax
  80eafc:	88 02                	mov    %al,(%edx)
}
  80eafe:	5d                   	pop    %ebp
  80eaff:	c3                   	ret    

0080eb00 <printfmt>:
{
  80eb00:	f3 0f 1e fb          	endbr32 
  80eb04:	55                   	push   %ebp
  80eb05:	89 e5                	mov    %esp,%ebp
  80eb07:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80eb0a:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80eb0d:	50                   	push   %eax
  80eb0e:	ff 75 10             	pushl  0x10(%ebp)
  80eb11:	ff 75 0c             	pushl  0xc(%ebp)
  80eb14:	ff 75 08             	pushl  0x8(%ebp)
  80eb17:	e8 05 00 00 00       	call   80eb21 <vprintfmt>
}
  80eb1c:	83 c4 10             	add    $0x10,%esp
  80eb1f:	c9                   	leave  
  80eb20:	c3                   	ret    

0080eb21 <vprintfmt>:
{
  80eb21:	f3 0f 1e fb          	endbr32 
  80eb25:	55                   	push   %ebp
  80eb26:	89 e5                	mov    %esp,%ebp
  80eb28:	57                   	push   %edi
  80eb29:	56                   	push   %esi
  80eb2a:	53                   	push   %ebx
  80eb2b:	83 ec 3c             	sub    $0x3c,%esp
  80eb2e:	8b 75 08             	mov    0x8(%ebp),%esi
  80eb31:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80eb34:	8b 7d 10             	mov    0x10(%ebp),%edi
  80eb37:	e9 8e 03 00 00       	jmp    80eeca <vprintfmt+0x3a9>
		padc = ' ';
  80eb3c:	c6 45 d3 20          	movb   $0x20,-0x2d(%ebp)
		altflag = 0;
  80eb40:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		precision = -1;
  80eb47:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
  80eb4e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80eb55:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80eb5a:	8d 47 01             	lea    0x1(%edi),%eax
  80eb5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80eb60:	0f b6 17             	movzbl (%edi),%edx
  80eb63:	8d 42 dd             	lea    -0x23(%edx),%eax
  80eb66:	3c 55                	cmp    $0x55,%al
  80eb68:	0f 87 df 03 00 00    	ja     80ef4d <vprintfmt+0x42c>
  80eb6e:	0f b6 c0             	movzbl %al,%eax
  80eb71:	3e ff 24 85 c0 38 81 	notrack jmp *0x8138c0(,%eax,4)
  80eb78:	00 
  80eb79:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80eb7c:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%ebp)
  80eb80:	eb d8                	jmp    80eb5a <vprintfmt+0x39>
		switch (ch = *(unsigned char *) fmt++) {
  80eb82:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80eb85:	c6 45 d3 30          	movb   $0x30,-0x2d(%ebp)
  80eb89:	eb cf                	jmp    80eb5a <vprintfmt+0x39>
  80eb8b:	0f b6 d2             	movzbl %dl,%edx
  80eb8e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80eb91:	b8 00 00 00 00       	mov    $0x0,%eax
  80eb96:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
				precision = precision * 10 + ch - '0';// 支持超过10位的width
  80eb99:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80eb9c:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80eba0:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80eba3:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80eba6:	83 f9 09             	cmp    $0x9,%ecx
  80eba9:	77 55                	ja     80ec00 <vprintfmt+0xdf>
			for (precision = 0; ; ++fmt) {
  80ebab:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';// 支持超过10位的width
  80ebae:	eb e9                	jmp    80eb99 <vprintfmt+0x78>
			precision = va_arg(ap, int);
  80ebb0:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebb3:	8b 00                	mov    (%eax),%eax
  80ebb5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ebb8:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebbb:	8d 40 04             	lea    0x4(%eax),%eax
  80ebbe:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80ebc1:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80ebc4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80ebc8:	79 90                	jns    80eb5a <vprintfmt+0x39>
				width = precision, precision = -1;
  80ebca:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ebcd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ebd0:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  80ebd7:	eb 81                	jmp    80eb5a <vprintfmt+0x39>
  80ebd9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ebdc:	85 c0                	test   %eax,%eax
  80ebde:	ba 00 00 00 00       	mov    $0x0,%edx
  80ebe3:	0f 49 d0             	cmovns %eax,%edx
  80ebe6:	89 55 e0             	mov    %edx,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80ebe9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80ebec:	e9 69 ff ff ff       	jmp    80eb5a <vprintfmt+0x39>
		switch (ch = *(unsigned char *) fmt++) {
  80ebf1:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80ebf4:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
			goto reswitch;
  80ebfb:	e9 5a ff ff ff       	jmp    80eb5a <vprintfmt+0x39>
  80ec00:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80ec03:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec06:	eb bc                	jmp    80ebc4 <vprintfmt+0xa3>
			lflag++;
  80ec08:	83 c1 01             	add    $0x1,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80ec0b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80ec0e:	e9 47 ff ff ff       	jmp    80eb5a <vprintfmt+0x39>
			putch(va_arg(ap, int), putdat);
  80ec13:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec16:	8d 78 04             	lea    0x4(%eax),%edi
  80ec19:	83 ec 08             	sub    $0x8,%esp
  80ec1c:	53                   	push   %ebx
  80ec1d:	ff 30                	pushl  (%eax)
  80ec1f:	ff d6                	call   *%esi
			break;
  80ec21:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80ec24:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80ec27:	e9 9b 02 00 00       	jmp    80eec7 <vprintfmt+0x3a6>
			err = va_arg(ap, int);
  80ec2c:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec2f:	8d 78 04             	lea    0x4(%eax),%edi
  80ec32:	8b 00                	mov    (%eax),%eax
  80ec34:	99                   	cltd   
  80ec35:	31 d0                	xor    %edx,%eax
  80ec37:	29 d0                	sub    %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80ec39:	83 f8 0f             	cmp    $0xf,%eax
  80ec3c:	7f 23                	jg     80ec61 <vprintfmt+0x140>
  80ec3e:	8b 14 85 20 3a 81 00 	mov    0x813a20(,%eax,4),%edx
  80ec45:	85 d2                	test   %edx,%edx
  80ec47:	74 18                	je     80ec61 <vprintfmt+0x140>
				printfmt(putch, putdat, "%s", p);
  80ec49:	52                   	push   %edx
  80ec4a:	68 5d 29 81 00       	push   $0x81295d
  80ec4f:	53                   	push   %ebx
  80ec50:	56                   	push   %esi
  80ec51:	e8 aa fe ff ff       	call   80eb00 <printfmt>
  80ec56:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80ec59:	89 7d 14             	mov    %edi,0x14(%ebp)
  80ec5c:	e9 66 02 00 00       	jmp    80eec7 <vprintfmt+0x3a6>
				printfmt(putch, putdat, "error %d", err);
  80ec61:	50                   	push   %eax
  80ec62:	68 8f 37 81 00       	push   $0x81378f
  80ec67:	53                   	push   %ebx
  80ec68:	56                   	push   %esi
  80ec69:	e8 92 fe ff ff       	call   80eb00 <printfmt>
  80ec6e:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80ec71:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80ec74:	e9 4e 02 00 00       	jmp    80eec7 <vprintfmt+0x3a6>
			if ((p = va_arg(ap, char *)) == NULL)
  80ec79:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec7c:	83 c0 04             	add    $0x4,%eax
  80ec7f:	89 45 c8             	mov    %eax,-0x38(%ebp)
  80ec82:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec85:	8b 10                	mov    (%eax),%edx
				p = "(null)";
  80ec87:	85 d2                	test   %edx,%edx
  80ec89:	b8 88 37 81 00       	mov    $0x813788,%eax
  80ec8e:	0f 45 c2             	cmovne %edx,%eax
  80ec91:	89 45 cc             	mov    %eax,-0x34(%ebp)
			if (width > 0 && padc != '-')
  80ec94:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80ec98:	7e 06                	jle    80eca0 <vprintfmt+0x17f>
  80ec9a:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%ebp)
  80ec9e:	75 0d                	jne    80ecad <vprintfmt+0x18c>
				for (width -= strnlen(p, precision); width > 0; width--)
  80eca0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80eca3:	89 c7                	mov    %eax,%edi
  80eca5:	03 45 e0             	add    -0x20(%ebp),%eax
  80eca8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ecab:	eb 55                	jmp    80ed02 <vprintfmt+0x1e1>
  80ecad:	83 ec 08             	sub    $0x8,%esp
  80ecb0:	ff 75 d8             	pushl  -0x28(%ebp)
  80ecb3:	ff 75 cc             	pushl  -0x34(%ebp)
  80ecb6:	e8 46 03 00 00       	call   80f001 <strnlen>
  80ecbb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80ecbe:	29 c2                	sub    %eax,%edx
  80ecc0:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80ecc3:	83 c4 10             	add    $0x10,%esp
  80ecc6:	89 d7                	mov    %edx,%edi
					putch(padc, putdat);
  80ecc8:	0f be 45 d3          	movsbl -0x2d(%ebp),%eax
  80eccc:	89 45 e0             	mov    %eax,-0x20(%ebp)
				for (width -= strnlen(p, precision); width > 0; width--)
  80eccf:	85 ff                	test   %edi,%edi
  80ecd1:	7e 11                	jle    80ece4 <vprintfmt+0x1c3>
					putch(padc, putdat);
  80ecd3:	83 ec 08             	sub    $0x8,%esp
  80ecd6:	53                   	push   %ebx
  80ecd7:	ff 75 e0             	pushl  -0x20(%ebp)
  80ecda:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80ecdc:	83 ef 01             	sub    $0x1,%edi
  80ecdf:	83 c4 10             	add    $0x10,%esp
  80ece2:	eb eb                	jmp    80eccf <vprintfmt+0x1ae>
  80ece4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  80ece7:	85 d2                	test   %edx,%edx
  80ece9:	b8 00 00 00 00       	mov    $0x0,%eax
  80ecee:	0f 49 c2             	cmovns %edx,%eax
  80ecf1:	29 c2                	sub    %eax,%edx
  80ecf3:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80ecf6:	eb a8                	jmp    80eca0 <vprintfmt+0x17f>
					putch(ch, putdat);
  80ecf8:	83 ec 08             	sub    $0x8,%esp
  80ecfb:	53                   	push   %ebx
  80ecfc:	52                   	push   %edx
  80ecfd:	ff d6                	call   *%esi
  80ecff:	83 c4 10             	add    $0x10,%esp
  80ed02:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80ed05:	29 f9                	sub    %edi,%ecx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80ed07:	83 c7 01             	add    $0x1,%edi
  80ed0a:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ed0e:	0f be d0             	movsbl %al,%edx
  80ed11:	85 d2                	test   %edx,%edx
  80ed13:	74 4b                	je     80ed60 <vprintfmt+0x23f>
  80ed15:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80ed19:	78 06                	js     80ed21 <vprintfmt+0x200>
  80ed1b:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  80ed1f:	78 1e                	js     80ed3f <vprintfmt+0x21e>
				if (altflag && (ch < ' ' || ch > '~'))// 非法处理
  80ed21:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80ed25:	74 d1                	je     80ecf8 <vprintfmt+0x1d7>
  80ed27:	0f be c0             	movsbl %al,%eax
  80ed2a:	83 e8 20             	sub    $0x20,%eax
  80ed2d:	83 f8 5e             	cmp    $0x5e,%eax
  80ed30:	76 c6                	jbe    80ecf8 <vprintfmt+0x1d7>
					putch('?', putdat);
  80ed32:	83 ec 08             	sub    $0x8,%esp
  80ed35:	53                   	push   %ebx
  80ed36:	6a 3f                	push   $0x3f
  80ed38:	ff d6                	call   *%esi
  80ed3a:	83 c4 10             	add    $0x10,%esp
  80ed3d:	eb c3                	jmp    80ed02 <vprintfmt+0x1e1>
  80ed3f:	89 cf                	mov    %ecx,%edi
  80ed41:	eb 0e                	jmp    80ed51 <vprintfmt+0x230>
				putch(' ', putdat);
  80ed43:	83 ec 08             	sub    $0x8,%esp
  80ed46:	53                   	push   %ebx
  80ed47:	6a 20                	push   $0x20
  80ed49:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80ed4b:	83 ef 01             	sub    $0x1,%edi
  80ed4e:	83 c4 10             	add    $0x10,%esp
  80ed51:	85 ff                	test   %edi,%edi
  80ed53:	7f ee                	jg     80ed43 <vprintfmt+0x222>
			if ((p = va_arg(ap, char *)) == NULL)
  80ed55:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80ed58:	89 45 14             	mov    %eax,0x14(%ebp)
  80ed5b:	e9 67 01 00 00       	jmp    80eec7 <vprintfmt+0x3a6>
  80ed60:	89 cf                	mov    %ecx,%edi
  80ed62:	eb ed                	jmp    80ed51 <vprintfmt+0x230>
	if (lflag >= 2)
  80ed64:	83 f9 01             	cmp    $0x1,%ecx
  80ed67:	7f 1b                	jg     80ed84 <vprintfmt+0x263>
	else if (lflag)
  80ed69:	85 c9                	test   %ecx,%ecx
  80ed6b:	74 63                	je     80edd0 <vprintfmt+0x2af>
		return va_arg(*ap, long);
  80ed6d:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed70:	8b 00                	mov    (%eax),%eax
  80ed72:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed75:	99                   	cltd   
  80ed76:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed79:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed7c:	8d 40 04             	lea    0x4(%eax),%eax
  80ed7f:	89 45 14             	mov    %eax,0x14(%ebp)
  80ed82:	eb 17                	jmp    80ed9b <vprintfmt+0x27a>
		return va_arg(*ap, long long);
  80ed84:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed87:	8b 50 04             	mov    0x4(%eax),%edx
  80ed8a:	8b 00                	mov    (%eax),%eax
  80ed8c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed8f:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed92:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed95:	8d 40 08             	lea    0x8(%eax),%eax
  80ed98:	89 45 14             	mov    %eax,0x14(%ebp)
			if ((long long) num < 0) {
  80ed9b:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80ed9e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			base = 10;
  80eda1:	b8 0a 00 00 00       	mov    $0xa,%eax
			if ((long long) num < 0) {
  80eda6:	85 c9                	test   %ecx,%ecx
  80eda8:	0f 89 ff 00 00 00    	jns    80eead <vprintfmt+0x38c>
				putch('-', putdat);
  80edae:	83 ec 08             	sub    $0x8,%esp
  80edb1:	53                   	push   %ebx
  80edb2:	6a 2d                	push   $0x2d
  80edb4:	ff d6                	call   *%esi
				num = -(long long) num;
  80edb6:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80edb9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80edbc:	f7 da                	neg    %edx
  80edbe:	83 d1 00             	adc    $0x0,%ecx
  80edc1:	f7 d9                	neg    %ecx
  80edc3:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80edc6:	b8 0a 00 00 00       	mov    $0xa,%eax
  80edcb:	e9 dd 00 00 00       	jmp    80eead <vprintfmt+0x38c>
		return va_arg(*ap, int);
  80edd0:	8b 45 14             	mov    0x14(%ebp),%eax
  80edd3:	8b 00                	mov    (%eax),%eax
  80edd5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80edd8:	99                   	cltd   
  80edd9:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eddc:	8b 45 14             	mov    0x14(%ebp),%eax
  80eddf:	8d 40 04             	lea    0x4(%eax),%eax
  80ede2:	89 45 14             	mov    %eax,0x14(%ebp)
  80ede5:	eb b4                	jmp    80ed9b <vprintfmt+0x27a>
	if (lflag >= 2)
  80ede7:	83 f9 01             	cmp    $0x1,%ecx
  80edea:	7f 1e                	jg     80ee0a <vprintfmt+0x2e9>
	else if (lflag)
  80edec:	85 c9                	test   %ecx,%ecx
  80edee:	74 32                	je     80ee22 <vprintfmt+0x301>
		return va_arg(*ap, unsigned long);
  80edf0:	8b 45 14             	mov    0x14(%ebp),%eax
  80edf3:	8b 10                	mov    (%eax),%edx
  80edf5:	b9 00 00 00 00       	mov    $0x0,%ecx
  80edfa:	8d 40 04             	lea    0x4(%eax),%eax
  80edfd:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ee00:	b8 0a 00 00 00       	mov    $0xa,%eax
		return va_arg(*ap, unsigned long);
  80ee05:	e9 a3 00 00 00       	jmp    80eead <vprintfmt+0x38c>
		return va_arg(*ap, unsigned long long);
  80ee0a:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee0d:	8b 10                	mov    (%eax),%edx
  80ee0f:	8b 48 04             	mov    0x4(%eax),%ecx
  80ee12:	8d 40 08             	lea    0x8(%eax),%eax
  80ee15:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ee18:	b8 0a 00 00 00       	mov    $0xa,%eax
		return va_arg(*ap, unsigned long long);
  80ee1d:	e9 8b 00 00 00       	jmp    80eead <vprintfmt+0x38c>
		return va_arg(*ap, unsigned int);
  80ee22:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee25:	8b 10                	mov    (%eax),%edx
  80ee27:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee2c:	8d 40 04             	lea    0x4(%eax),%eax
  80ee2f:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ee32:	b8 0a 00 00 00       	mov    $0xa,%eax
		return va_arg(*ap, unsigned int);
  80ee37:	eb 74                	jmp    80eead <vprintfmt+0x38c>
	if (lflag >= 2)
  80ee39:	83 f9 01             	cmp    $0x1,%ecx
  80ee3c:	7f 1b                	jg     80ee59 <vprintfmt+0x338>
	else if (lflag)
  80ee3e:	85 c9                	test   %ecx,%ecx
  80ee40:	74 2c                	je     80ee6e <vprintfmt+0x34d>
		return va_arg(*ap, unsigned long);
  80ee42:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee45:	8b 10                	mov    (%eax),%edx
  80ee47:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee4c:	8d 40 04             	lea    0x4(%eax),%eax
  80ee4f:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ee52:	b8 08 00 00 00       	mov    $0x8,%eax
		return va_arg(*ap, unsigned long);
  80ee57:	eb 54                	jmp    80eead <vprintfmt+0x38c>
		return va_arg(*ap, unsigned long long);
  80ee59:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee5c:	8b 10                	mov    (%eax),%edx
  80ee5e:	8b 48 04             	mov    0x4(%eax),%ecx
  80ee61:	8d 40 08             	lea    0x8(%eax),%eax
  80ee64:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ee67:	b8 08 00 00 00       	mov    $0x8,%eax
		return va_arg(*ap, unsigned long long);
  80ee6c:	eb 3f                	jmp    80eead <vprintfmt+0x38c>
		return va_arg(*ap, unsigned int);
  80ee6e:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee71:	8b 10                	mov    (%eax),%edx
  80ee73:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee78:	8d 40 04             	lea    0x4(%eax),%eax
  80ee7b:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ee7e:	b8 08 00 00 00       	mov    $0x8,%eax
		return va_arg(*ap, unsigned int);
  80ee83:	eb 28                	jmp    80eead <vprintfmt+0x38c>
			putch('0', putdat);
  80ee85:	83 ec 08             	sub    $0x8,%esp
  80ee88:	53                   	push   %ebx
  80ee89:	6a 30                	push   $0x30
  80ee8b:	ff d6                	call   *%esi
			putch('x', putdat);
  80ee8d:	83 c4 08             	add    $0x8,%esp
  80ee90:	53                   	push   %ebx
  80ee91:	6a 78                	push   $0x78
  80ee93:	ff d6                	call   *%esi
			num = (unsigned long long)
  80ee95:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee98:	8b 10                	mov    (%eax),%edx
  80ee9a:	b9 00 00 00 00       	mov    $0x0,%ecx
			goto number;
  80ee9f:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80eea2:	8d 40 04             	lea    0x4(%eax),%eax
  80eea5:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eea8:	b8 10 00 00 00       	mov    $0x10,%eax
			printnum(putch, putdat, num, base, width, padc);
  80eead:	83 ec 0c             	sub    $0xc,%esp
  80eeb0:	0f be 7d d3          	movsbl -0x2d(%ebp),%edi
  80eeb4:	57                   	push   %edi
  80eeb5:	ff 75 e0             	pushl  -0x20(%ebp)
  80eeb8:	50                   	push   %eax
  80eeb9:	51                   	push   %ecx
  80eeba:	52                   	push   %edx
  80eebb:	89 da                	mov    %ebx,%edx
  80eebd:	89 f0                	mov    %esi,%eax
  80eebf:	e8 72 fb ff ff       	call   80ea36 <printnum>
			break;
  80eec4:	83 c4 20             	add    $0x20,%esp
			if ((p = va_arg(ap, char *)) == NULL)
  80eec7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {// 字符的一一比较
  80eeca:	83 c7 01             	add    $0x1,%edi
  80eecd:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80eed1:	83 f8 25             	cmp    $0x25,%eax
  80eed4:	0f 84 62 fc ff ff    	je     80eb3c <vprintfmt+0x1b>
			if (ch == '\0')// string读到末尾了 直接返回
  80eeda:	85 c0                	test   %eax,%eax
  80eedc:	0f 84 8b 00 00 00    	je     80ef6d <vprintfmt+0x44c>
			putch(ch, putdat);// 普通的要打印的字符串(既不是%escape seq也不是末尾) 直接调用putch()打印 不向下执行
  80eee2:	83 ec 08             	sub    $0x8,%esp
  80eee5:	53                   	push   %ebx
  80eee6:	50                   	push   %eax
  80eee7:	ff d6                	call   *%esi
  80eee9:	83 c4 10             	add    $0x10,%esp
  80eeec:	eb dc                	jmp    80eeca <vprintfmt+0x3a9>
	if (lflag >= 2)
  80eeee:	83 f9 01             	cmp    $0x1,%ecx
  80eef1:	7f 1b                	jg     80ef0e <vprintfmt+0x3ed>
	else if (lflag)
  80eef3:	85 c9                	test   %ecx,%ecx
  80eef5:	74 2c                	je     80ef23 <vprintfmt+0x402>
		return va_arg(*ap, unsigned long);
  80eef7:	8b 45 14             	mov    0x14(%ebp),%eax
  80eefa:	8b 10                	mov    (%eax),%edx
  80eefc:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ef01:	8d 40 04             	lea    0x4(%eax),%eax
  80ef04:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ef07:	b8 10 00 00 00       	mov    $0x10,%eax
		return va_arg(*ap, unsigned long);
  80ef0c:	eb 9f                	jmp    80eead <vprintfmt+0x38c>
		return va_arg(*ap, unsigned long long);
  80ef0e:	8b 45 14             	mov    0x14(%ebp),%eax
  80ef11:	8b 10                	mov    (%eax),%edx
  80ef13:	8b 48 04             	mov    0x4(%eax),%ecx
  80ef16:	8d 40 08             	lea    0x8(%eax),%eax
  80ef19:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ef1c:	b8 10 00 00 00       	mov    $0x10,%eax
		return va_arg(*ap, unsigned long long);
  80ef21:	eb 8a                	jmp    80eead <vprintfmt+0x38c>
		return va_arg(*ap, unsigned int);
  80ef23:	8b 45 14             	mov    0x14(%ebp),%eax
  80ef26:	8b 10                	mov    (%eax),%edx
  80ef28:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ef2d:	8d 40 04             	lea    0x4(%eax),%eax
  80ef30:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ef33:	b8 10 00 00 00       	mov    $0x10,%eax
		return va_arg(*ap, unsigned int);
  80ef38:	e9 70 ff ff ff       	jmp    80eead <vprintfmt+0x38c>
			putch(ch, putdat);
  80ef3d:	83 ec 08             	sub    $0x8,%esp
  80ef40:	53                   	push   %ebx
  80ef41:	6a 25                	push   $0x25
  80ef43:	ff d6                	call   *%esi
			break;
  80ef45:	83 c4 10             	add    $0x10,%esp
  80ef48:	e9 7a ff ff ff       	jmp    80eec7 <vprintfmt+0x3a6>
			putch('%', putdat);
  80ef4d:	83 ec 08             	sub    $0x8,%esp
  80ef50:	53                   	push   %ebx
  80ef51:	6a 25                	push   $0x25
  80ef53:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)// fmt[-1] == *(fmt - 1)
  80ef55:	83 c4 10             	add    $0x10,%esp
  80ef58:	89 f8                	mov    %edi,%eax
  80ef5a:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80ef5e:	74 05                	je     80ef65 <vprintfmt+0x444>
  80ef60:	83 e8 01             	sub    $0x1,%eax
  80ef63:	eb f5                	jmp    80ef5a <vprintfmt+0x439>
  80ef65:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ef68:	e9 5a ff ff ff       	jmp    80eec7 <vprintfmt+0x3a6>
}
  80ef6d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef70:	5b                   	pop    %ebx
  80ef71:	5e                   	pop    %esi
  80ef72:	5f                   	pop    %edi
  80ef73:	5d                   	pop    %ebp
  80ef74:	c3                   	ret    

0080ef75 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80ef75:	f3 0f 1e fb          	endbr32 
  80ef79:	55                   	push   %ebp
  80ef7a:	89 e5                	mov    %esp,%ebp
  80ef7c:	83 ec 18             	sub    $0x18,%esp
  80ef7f:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef82:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80ef85:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ef88:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80ef8c:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80ef8f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80ef96:	85 c0                	test   %eax,%eax
  80ef98:	74 26                	je     80efc0 <vsnprintf+0x4b>
  80ef9a:	85 d2                	test   %edx,%edx
  80ef9c:	7e 22                	jle    80efc0 <vsnprintf+0x4b>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80ef9e:	ff 75 14             	pushl  0x14(%ebp)
  80efa1:	ff 75 10             	pushl  0x10(%ebp)
  80efa4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80efa7:	50                   	push   %eax
  80efa8:	68 df ea 80 00       	push   $0x80eadf
  80efad:	e8 6f fb ff ff       	call   80eb21 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80efb2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80efb5:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80efb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80efbb:	83 c4 10             	add    $0x10,%esp
}
  80efbe:	c9                   	leave  
  80efbf:	c3                   	ret    
		return -E_INVAL;
  80efc0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80efc5:	eb f7                	jmp    80efbe <vsnprintf+0x49>

0080efc7 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80efc7:	f3 0f 1e fb          	endbr32 
  80efcb:	55                   	push   %ebp
  80efcc:	89 e5                	mov    %esp,%ebp
  80efce:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;
	va_start(ap, fmt);
  80efd1:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80efd4:	50                   	push   %eax
  80efd5:	ff 75 10             	pushl  0x10(%ebp)
  80efd8:	ff 75 0c             	pushl  0xc(%ebp)
  80efdb:	ff 75 08             	pushl  0x8(%ebp)
  80efde:	e8 92 ff ff ff       	call   80ef75 <vsnprintf>
	va_end(ap);

	return rc;
}
  80efe3:	c9                   	leave  
  80efe4:	c3                   	ret    

0080efe5 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80efe5:	f3 0f 1e fb          	endbr32 
  80efe9:	55                   	push   %ebp
  80efea:	89 e5                	mov    %esp,%ebp
  80efec:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80efef:	b8 00 00 00 00       	mov    $0x0,%eax
  80eff4:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80eff8:	74 05                	je     80efff <strlen+0x1a>
		n++;
  80effa:	83 c0 01             	add    $0x1,%eax
  80effd:	eb f5                	jmp    80eff4 <strlen+0xf>
	return n;
}
  80efff:	5d                   	pop    %ebp
  80f000:	c3                   	ret    

0080f001 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80f001:	f3 0f 1e fb          	endbr32 
  80f005:	55                   	push   %ebp
  80f006:	89 e5                	mov    %esp,%ebp
  80f008:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f00b:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f00e:	b8 00 00 00 00       	mov    $0x0,%eax
  80f013:	39 d0                	cmp    %edx,%eax
  80f015:	74 0d                	je     80f024 <strnlen+0x23>
  80f017:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80f01b:	74 05                	je     80f022 <strnlen+0x21>
		n++;
  80f01d:	83 c0 01             	add    $0x1,%eax
  80f020:	eb f1                	jmp    80f013 <strnlen+0x12>
  80f022:	89 c2                	mov    %eax,%edx
	return n;
}
  80f024:	89 d0                	mov    %edx,%eax
  80f026:	5d                   	pop    %ebp
  80f027:	c3                   	ret    

0080f028 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80f028:	f3 0f 1e fb          	endbr32 
  80f02c:	55                   	push   %ebp
  80f02d:	89 e5                	mov    %esp,%ebp
  80f02f:	53                   	push   %ebx
  80f030:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f033:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80f036:	b8 00 00 00 00       	mov    $0x0,%eax
  80f03b:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
  80f03f:	88 14 01             	mov    %dl,(%ecx,%eax,1)
  80f042:	83 c0 01             	add    $0x1,%eax
  80f045:	84 d2                	test   %dl,%dl
  80f047:	75 f2                	jne    80f03b <strcpy+0x13>
		/* do nothing */;
	return ret;
}
  80f049:	89 c8                	mov    %ecx,%eax
  80f04b:	5b                   	pop    %ebx
  80f04c:	5d                   	pop    %ebp
  80f04d:	c3                   	ret    

0080f04e <strcat>:

char *
strcat(char *dst, const char *src)
{
  80f04e:	f3 0f 1e fb          	endbr32 
  80f052:	55                   	push   %ebp
  80f053:	89 e5                	mov    %esp,%ebp
  80f055:	53                   	push   %ebx
  80f056:	83 ec 10             	sub    $0x10,%esp
  80f059:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80f05c:	53                   	push   %ebx
  80f05d:	e8 83 ff ff ff       	call   80efe5 <strlen>
  80f062:	83 c4 08             	add    $0x8,%esp
	strcpy(dst + len, src);
  80f065:	ff 75 0c             	pushl  0xc(%ebp)
  80f068:	01 d8                	add    %ebx,%eax
  80f06a:	50                   	push   %eax
  80f06b:	e8 b8 ff ff ff       	call   80f028 <strcpy>
	return dst;
}
  80f070:	89 d8                	mov    %ebx,%eax
  80f072:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f075:	c9                   	leave  
  80f076:	c3                   	ret    

0080f077 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f077:	f3 0f 1e fb          	endbr32 
  80f07b:	55                   	push   %ebp
  80f07c:	89 e5                	mov    %esp,%ebp
  80f07e:	56                   	push   %esi
  80f07f:	53                   	push   %ebx
  80f080:	8b 75 08             	mov    0x8(%ebp),%esi
  80f083:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f086:	89 f3                	mov    %esi,%ebx
  80f088:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f08b:	89 f0                	mov    %esi,%eax
  80f08d:	39 d8                	cmp    %ebx,%eax
  80f08f:	74 11                	je     80f0a2 <strncpy+0x2b>
		*dst++ = *src;
  80f091:	83 c0 01             	add    $0x1,%eax
  80f094:	0f b6 0a             	movzbl (%edx),%ecx
  80f097:	88 48 ff             	mov    %cl,-0x1(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f09a:	80 f9 01             	cmp    $0x1,%cl
  80f09d:	83 da ff             	sbb    $0xffffffff,%edx
  80f0a0:	eb eb                	jmp    80f08d <strncpy+0x16>
	}
	return ret;
}
  80f0a2:	89 f0                	mov    %esi,%eax
  80f0a4:	5b                   	pop    %ebx
  80f0a5:	5e                   	pop    %esi
  80f0a6:	5d                   	pop    %ebp
  80f0a7:	c3                   	ret    

0080f0a8 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f0a8:	f3 0f 1e fb          	endbr32 
  80f0ac:	55                   	push   %ebp
  80f0ad:	89 e5                	mov    %esp,%ebp
  80f0af:	56                   	push   %esi
  80f0b0:	53                   	push   %ebx
  80f0b1:	8b 75 08             	mov    0x8(%ebp),%esi
  80f0b4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0b7:	8b 55 10             	mov    0x10(%ebp),%edx
  80f0ba:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f0bc:	85 d2                	test   %edx,%edx
  80f0be:	74 21                	je     80f0e1 <strlcpy+0x39>
  80f0c0:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80f0c4:	89 f2                	mov    %esi,%edx
		while (--size > 0 && *src != '\0')
  80f0c6:	39 c2                	cmp    %eax,%edx
  80f0c8:	74 14                	je     80f0de <strlcpy+0x36>
  80f0ca:	0f b6 19             	movzbl (%ecx),%ebx
  80f0cd:	84 db                	test   %bl,%bl
  80f0cf:	74 0b                	je     80f0dc <strlcpy+0x34>
			*dst++ = *src++;
  80f0d1:	83 c1 01             	add    $0x1,%ecx
  80f0d4:	83 c2 01             	add    $0x1,%edx
  80f0d7:	88 5a ff             	mov    %bl,-0x1(%edx)
  80f0da:	eb ea                	jmp    80f0c6 <strlcpy+0x1e>
  80f0dc:	89 d0                	mov    %edx,%eax
		*dst = '\0';
  80f0de:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80f0e1:	29 f0                	sub    %esi,%eax
}
  80f0e3:	5b                   	pop    %ebx
  80f0e4:	5e                   	pop    %esi
  80f0e5:	5d                   	pop    %ebp
  80f0e6:	c3                   	ret    

0080f0e7 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f0e7:	f3 0f 1e fb          	endbr32 
  80f0eb:	55                   	push   %ebp
  80f0ec:	89 e5                	mov    %esp,%ebp
  80f0ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f0f1:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f0f4:	0f b6 01             	movzbl (%ecx),%eax
  80f0f7:	84 c0                	test   %al,%al
  80f0f9:	74 0c                	je     80f107 <strcmp+0x20>
  80f0fb:	3a 02                	cmp    (%edx),%al
  80f0fd:	75 08                	jne    80f107 <strcmp+0x20>
		p++, q++;
  80f0ff:	83 c1 01             	add    $0x1,%ecx
  80f102:	83 c2 01             	add    $0x1,%edx
  80f105:	eb ed                	jmp    80f0f4 <strcmp+0xd>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f107:	0f b6 c0             	movzbl %al,%eax
  80f10a:	0f b6 12             	movzbl (%edx),%edx
  80f10d:	29 d0                	sub    %edx,%eax
}
  80f10f:	5d                   	pop    %ebp
  80f110:	c3                   	ret    

0080f111 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f111:	f3 0f 1e fb          	endbr32 
  80f115:	55                   	push   %ebp
  80f116:	89 e5                	mov    %esp,%ebp
  80f118:	53                   	push   %ebx
  80f119:	8b 45 08             	mov    0x8(%ebp),%eax
  80f11c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f11f:	89 c3                	mov    %eax,%ebx
  80f121:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80f124:	eb 06                	jmp    80f12c <strncmp+0x1b>
		n--, p++, q++;
  80f126:	83 c0 01             	add    $0x1,%eax
  80f129:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80f12c:	39 d8                	cmp    %ebx,%eax
  80f12e:	74 16                	je     80f146 <strncmp+0x35>
  80f130:	0f b6 08             	movzbl (%eax),%ecx
  80f133:	84 c9                	test   %cl,%cl
  80f135:	74 04                	je     80f13b <strncmp+0x2a>
  80f137:	3a 0a                	cmp    (%edx),%cl
  80f139:	74 eb                	je     80f126 <strncmp+0x15>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f13b:	0f b6 00             	movzbl (%eax),%eax
  80f13e:	0f b6 12             	movzbl (%edx),%edx
  80f141:	29 d0                	sub    %edx,%eax
}
  80f143:	5b                   	pop    %ebx
  80f144:	5d                   	pop    %ebp
  80f145:	c3                   	ret    
		return 0;
  80f146:	b8 00 00 00 00       	mov    $0x0,%eax
  80f14b:	eb f6                	jmp    80f143 <strncmp+0x32>

0080f14d <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f14d:	f3 0f 1e fb          	endbr32 
  80f151:	55                   	push   %ebp
  80f152:	89 e5                	mov    %esp,%ebp
  80f154:	8b 45 08             	mov    0x8(%ebp),%eax
  80f157:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f15b:	0f b6 10             	movzbl (%eax),%edx
  80f15e:	84 d2                	test   %dl,%dl
  80f160:	74 09                	je     80f16b <strchr+0x1e>
		if (*s == c)
  80f162:	38 ca                	cmp    %cl,%dl
  80f164:	74 0a                	je     80f170 <strchr+0x23>
	for (; *s; s++)
  80f166:	83 c0 01             	add    $0x1,%eax
  80f169:	eb f0                	jmp    80f15b <strchr+0xe>
			return (char *) s;
	return 0;
  80f16b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f170:	5d                   	pop    %ebp
  80f171:	c3                   	ret    

0080f172 <atox>:

// Parse a string and turn it to hexidecimal value
uint32_t atox(const char* va)
{
  80f172:	f3 0f 1e fb          	endbr32 
  80f176:	55                   	push   %ebp
  80f177:	89 e5                	mov    %esp,%ebp
  80f179:	83 ec 10             	sub    $0x10,%esp
	uint32_t v=0x0;
	char* p = strchr(va, 'x') + 1;
  80f17c:	6a 78                	push   $0x78
  80f17e:	ff 75 08             	pushl  0x8(%ebp)
  80f181:	e8 c7 ff ff ff       	call   80f14d <strchr>
  80f186:	83 c4 10             	add    $0x10,%esp
  80f189:	8d 48 01             	lea    0x1(%eax),%ecx
	uint32_t v=0x0;
  80f18c:	b8 00 00 00 00       	mov    $0x0,%eax
	
	for (; *p!='\0'; p++){
  80f191:	eb 0d                	jmp    80f1a0 <atox+0x2e>
		if (*p>='a'){
			v = v*16 + *p - 'a' + 10;
		}
		else v = v*16 + *p -'0';
  80f193:	c1 e0 04             	shl    $0x4,%eax
  80f196:	0f be d2             	movsbl %dl,%edx
  80f199:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
	for (; *p!='\0'; p++){
  80f19d:	83 c1 01             	add    $0x1,%ecx
  80f1a0:	0f b6 11             	movzbl (%ecx),%edx
  80f1a3:	84 d2                	test   %dl,%dl
  80f1a5:	74 11                	je     80f1b8 <atox+0x46>
		if (*p>='a'){
  80f1a7:	80 fa 60             	cmp    $0x60,%dl
  80f1aa:	7e e7                	jle    80f193 <atox+0x21>
			v = v*16 + *p - 'a' + 10;
  80f1ac:	c1 e0 04             	shl    $0x4,%eax
  80f1af:	0f be d2             	movsbl %dl,%edx
  80f1b2:	8d 44 10 a9          	lea    -0x57(%eax,%edx,1),%eax
  80f1b6:	eb e5                	jmp    80f19d <atox+0x2b>
	}

	return v;

}
  80f1b8:	c9                   	leave  
  80f1b9:	c3                   	ret    

0080f1ba <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f1ba:	f3 0f 1e fb          	endbr32 
  80f1be:	55                   	push   %ebp
  80f1bf:	89 e5                	mov    %esp,%ebp
  80f1c1:	8b 45 08             	mov    0x8(%ebp),%eax
  80f1c4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f1c8:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80f1cb:	38 ca                	cmp    %cl,%dl
  80f1cd:	74 09                	je     80f1d8 <strfind+0x1e>
  80f1cf:	84 d2                	test   %dl,%dl
  80f1d1:	74 05                	je     80f1d8 <strfind+0x1e>
	for (; *s; s++)
  80f1d3:	83 c0 01             	add    $0x1,%eax
  80f1d6:	eb f0                	jmp    80f1c8 <strfind+0xe>
			break;
	return (char *) s;
}
  80f1d8:	5d                   	pop    %ebp
  80f1d9:	c3                   	ret    

0080f1da <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f1da:	f3 0f 1e fb          	endbr32 
  80f1de:	55                   	push   %ebp
  80f1df:	89 e5                	mov    %esp,%ebp
  80f1e1:	57                   	push   %edi
  80f1e2:	56                   	push   %esi
  80f1e3:	53                   	push   %ebx
  80f1e4:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f1e7:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f1ea:	85 c9                	test   %ecx,%ecx
  80f1ec:	74 31                	je     80f21f <memset+0x45>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f1ee:	89 f8                	mov    %edi,%eax
  80f1f0:	09 c8                	or     %ecx,%eax
  80f1f2:	a8 03                	test   $0x3,%al
  80f1f4:	75 23                	jne    80f219 <memset+0x3f>
		c &= 0xFF;
  80f1f6:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f1fa:	89 d3                	mov    %edx,%ebx
  80f1fc:	c1 e3 08             	shl    $0x8,%ebx
  80f1ff:	89 d0                	mov    %edx,%eax
  80f201:	c1 e0 18             	shl    $0x18,%eax
  80f204:	89 d6                	mov    %edx,%esi
  80f206:	c1 e6 10             	shl    $0x10,%esi
  80f209:	09 f0                	or     %esi,%eax
  80f20b:	09 c2                	or     %eax,%edx
  80f20d:	09 da                	or     %ebx,%edx
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f20f:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80f212:	89 d0                	mov    %edx,%eax
  80f214:	fc                   	cld    
  80f215:	f3 ab                	rep stos %eax,%es:(%edi)
  80f217:	eb 06                	jmp    80f21f <memset+0x45>
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f219:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f21c:	fc                   	cld    
  80f21d:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f21f:	89 f8                	mov    %edi,%eax
  80f221:	5b                   	pop    %ebx
  80f222:	5e                   	pop    %esi
  80f223:	5f                   	pop    %edi
  80f224:	5d                   	pop    %ebp
  80f225:	c3                   	ret    

0080f226 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f226:	f3 0f 1e fb          	endbr32 
  80f22a:	55                   	push   %ebp
  80f22b:	89 e5                	mov    %esp,%ebp
  80f22d:	57                   	push   %edi
  80f22e:	56                   	push   %esi
  80f22f:	8b 45 08             	mov    0x8(%ebp),%eax
  80f232:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f235:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f238:	39 c6                	cmp    %eax,%esi
  80f23a:	73 32                	jae    80f26e <memmove+0x48>
  80f23c:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f23f:	39 c2                	cmp    %eax,%edx
  80f241:	76 2b                	jbe    80f26e <memmove+0x48>
		s += n;
		d += n;
  80f243:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f246:	89 fe                	mov    %edi,%esi
  80f248:	09 ce                	or     %ecx,%esi
  80f24a:	09 d6                	or     %edx,%esi
  80f24c:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f252:	75 0e                	jne    80f262 <memmove+0x3c>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f254:	83 ef 04             	sub    $0x4,%edi
  80f257:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f25a:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80f25d:	fd                   	std    
  80f25e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f260:	eb 09                	jmp    80f26b <memmove+0x45>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f262:	83 ef 01             	sub    $0x1,%edi
  80f265:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80f268:	fd                   	std    
  80f269:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f26b:	fc                   	cld    
  80f26c:	eb 1a                	jmp    80f288 <memmove+0x62>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f26e:	89 c2                	mov    %eax,%edx
  80f270:	09 ca                	or     %ecx,%edx
  80f272:	09 f2                	or     %esi,%edx
  80f274:	f6 c2 03             	test   $0x3,%dl
  80f277:	75 0a                	jne    80f283 <memmove+0x5d>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f279:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80f27c:	89 c7                	mov    %eax,%edi
  80f27e:	fc                   	cld    
  80f27f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f281:	eb 05                	jmp    80f288 <memmove+0x62>
		else
			asm volatile("cld; rep movsb\n"
  80f283:	89 c7                	mov    %eax,%edi
  80f285:	fc                   	cld    
  80f286:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f288:	5e                   	pop    %esi
  80f289:	5f                   	pop    %edi
  80f28a:	5d                   	pop    %ebp
  80f28b:	c3                   	ret    

0080f28c <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f28c:	f3 0f 1e fb          	endbr32 
  80f290:	55                   	push   %ebp
  80f291:	89 e5                	mov    %esp,%ebp
  80f293:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f296:	ff 75 10             	pushl  0x10(%ebp)
  80f299:	ff 75 0c             	pushl  0xc(%ebp)
  80f29c:	ff 75 08             	pushl  0x8(%ebp)
  80f29f:	e8 82 ff ff ff       	call   80f226 <memmove>
}
  80f2a4:	c9                   	leave  
  80f2a5:	c3                   	ret    

0080f2a6 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f2a6:	f3 0f 1e fb          	endbr32 
  80f2aa:	55                   	push   %ebp
  80f2ab:	89 e5                	mov    %esp,%ebp
  80f2ad:	56                   	push   %esi
  80f2ae:	53                   	push   %ebx
  80f2af:	8b 45 08             	mov    0x8(%ebp),%eax
  80f2b2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f2b5:	89 c6                	mov    %eax,%esi
  80f2b7:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f2ba:	39 f0                	cmp    %esi,%eax
  80f2bc:	74 1c                	je     80f2da <memcmp+0x34>
		if (*s1 != *s2)
  80f2be:	0f b6 08             	movzbl (%eax),%ecx
  80f2c1:	0f b6 1a             	movzbl (%edx),%ebx
  80f2c4:	38 d9                	cmp    %bl,%cl
  80f2c6:	75 08                	jne    80f2d0 <memcmp+0x2a>
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80f2c8:	83 c0 01             	add    $0x1,%eax
  80f2cb:	83 c2 01             	add    $0x1,%edx
  80f2ce:	eb ea                	jmp    80f2ba <memcmp+0x14>
			return (int) *s1 - (int) *s2;
  80f2d0:	0f b6 c1             	movzbl %cl,%eax
  80f2d3:	0f b6 db             	movzbl %bl,%ebx
  80f2d6:	29 d8                	sub    %ebx,%eax
  80f2d8:	eb 05                	jmp    80f2df <memcmp+0x39>
	}

	return 0;
  80f2da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f2df:	5b                   	pop    %ebx
  80f2e0:	5e                   	pop    %esi
  80f2e1:	5d                   	pop    %ebp
  80f2e2:	c3                   	ret    

0080f2e3 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f2e3:	f3 0f 1e fb          	endbr32 
  80f2e7:	55                   	push   %ebp
  80f2e8:	89 e5                	mov    %esp,%ebp
  80f2ea:	8b 45 08             	mov    0x8(%ebp),%eax
  80f2ed:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f2f0:	89 c2                	mov    %eax,%edx
  80f2f2:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f2f5:	39 d0                	cmp    %edx,%eax
  80f2f7:	73 09                	jae    80f302 <memfind+0x1f>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f2f9:	38 08                	cmp    %cl,(%eax)
  80f2fb:	74 05                	je     80f302 <memfind+0x1f>
	for (; s < ends; s++)
  80f2fd:	83 c0 01             	add    $0x1,%eax
  80f300:	eb f3                	jmp    80f2f5 <memfind+0x12>
			break;
	return (void *) s;
}
  80f302:	5d                   	pop    %ebp
  80f303:	c3                   	ret    

0080f304 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f304:	f3 0f 1e fb          	endbr32 
  80f308:	55                   	push   %ebp
  80f309:	89 e5                	mov    %esp,%ebp
  80f30b:	57                   	push   %edi
  80f30c:	56                   	push   %esi
  80f30d:	53                   	push   %ebx
  80f30e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f311:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f314:	eb 03                	jmp    80f319 <strtol+0x15>
		s++;
  80f316:	83 c1 01             	add    $0x1,%ecx
	while (*s == ' ' || *s == '\t')
  80f319:	0f b6 01             	movzbl (%ecx),%eax
  80f31c:	3c 20                	cmp    $0x20,%al
  80f31e:	74 f6                	je     80f316 <strtol+0x12>
  80f320:	3c 09                	cmp    $0x9,%al
  80f322:	74 f2                	je     80f316 <strtol+0x12>

	// plus/minus sign
	if (*s == '+')
  80f324:	3c 2b                	cmp    $0x2b,%al
  80f326:	74 2a                	je     80f352 <strtol+0x4e>
	int neg = 0;
  80f328:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80f32d:	3c 2d                	cmp    $0x2d,%al
  80f32f:	74 2b                	je     80f35c <strtol+0x58>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f331:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80f337:	75 0f                	jne    80f348 <strtol+0x44>
  80f339:	80 39 30             	cmpb   $0x30,(%ecx)
  80f33c:	74 28                	je     80f366 <strtol+0x62>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80f33e:	85 db                	test   %ebx,%ebx
  80f340:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f345:	0f 44 d8             	cmove  %eax,%ebx
  80f348:	b8 00 00 00 00       	mov    $0x0,%eax
  80f34d:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f350:	eb 46                	jmp    80f398 <strtol+0x94>
		s++;
  80f352:	83 c1 01             	add    $0x1,%ecx
	int neg = 0;
  80f355:	bf 00 00 00 00       	mov    $0x0,%edi
  80f35a:	eb d5                	jmp    80f331 <strtol+0x2d>
		s++, neg = 1;
  80f35c:	83 c1 01             	add    $0x1,%ecx
  80f35f:	bf 01 00 00 00       	mov    $0x1,%edi
  80f364:	eb cb                	jmp    80f331 <strtol+0x2d>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f366:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80f36a:	74 0e                	je     80f37a <strtol+0x76>
	else if (base == 0 && s[0] == '0')
  80f36c:	85 db                	test   %ebx,%ebx
  80f36e:	75 d8                	jne    80f348 <strtol+0x44>
		s++, base = 8;
  80f370:	83 c1 01             	add    $0x1,%ecx
  80f373:	bb 08 00 00 00       	mov    $0x8,%ebx
  80f378:	eb ce                	jmp    80f348 <strtol+0x44>
		s += 2, base = 16;
  80f37a:	83 c1 02             	add    $0x2,%ecx
  80f37d:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f382:	eb c4                	jmp    80f348 <strtol+0x44>
	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
  80f384:	0f be d2             	movsbl %dl,%edx
  80f387:	83 ea 30             	sub    $0x30,%edx
			dig = *s - 'a' + 10;
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f38a:	3b 55 10             	cmp    0x10(%ebp),%edx
  80f38d:	7d 3a                	jge    80f3c9 <strtol+0xc5>
			break;
		s++, val = (val * base) + dig;
  80f38f:	83 c1 01             	add    $0x1,%ecx
  80f392:	0f af 45 10          	imul   0x10(%ebp),%eax
  80f396:	01 d0                	add    %edx,%eax
		if (*s >= '0' && *s <= '9')
  80f398:	0f b6 11             	movzbl (%ecx),%edx
  80f39b:	8d 72 d0             	lea    -0x30(%edx),%esi
  80f39e:	89 f3                	mov    %esi,%ebx
  80f3a0:	80 fb 09             	cmp    $0x9,%bl
  80f3a3:	76 df                	jbe    80f384 <strtol+0x80>
		else if (*s >= 'a' && *s <= 'z')
  80f3a5:	8d 72 9f             	lea    -0x61(%edx),%esi
  80f3a8:	89 f3                	mov    %esi,%ebx
  80f3aa:	80 fb 19             	cmp    $0x19,%bl
  80f3ad:	77 08                	ja     80f3b7 <strtol+0xb3>
			dig = *s - 'a' + 10;
  80f3af:	0f be d2             	movsbl %dl,%edx
  80f3b2:	83 ea 57             	sub    $0x57,%edx
  80f3b5:	eb d3                	jmp    80f38a <strtol+0x86>
		else if (*s >= 'A' && *s <= 'Z')
  80f3b7:	8d 72 bf             	lea    -0x41(%edx),%esi
  80f3ba:	89 f3                	mov    %esi,%ebx
  80f3bc:	80 fb 19             	cmp    $0x19,%bl
  80f3bf:	77 08                	ja     80f3c9 <strtol+0xc5>
			dig = *s - 'A' + 10;
  80f3c1:	0f be d2             	movsbl %dl,%edx
  80f3c4:	83 ea 37             	sub    $0x37,%edx
  80f3c7:	eb c1                	jmp    80f38a <strtol+0x86>
		// we don't properly detect overflow!
	}

	if (endptr)
  80f3c9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f3cd:	74 05                	je     80f3d4 <strtol+0xd0>
		*endptr = (char *) s;
  80f3cf:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f3d2:	89 0e                	mov    %ecx,(%esi)
	return (neg ? -val : val);
  80f3d4:	89 c2                	mov    %eax,%edx
  80f3d6:	f7 da                	neg    %edx
  80f3d8:	85 ff                	test   %edi,%edi
  80f3da:	0f 45 c2             	cmovne %edx,%eax
}
  80f3dd:	5b                   	pop    %ebx
  80f3de:	5e                   	pop    %esi
  80f3df:	5f                   	pop    %edi
  80f3e0:	5d                   	pop    %ebp
  80f3e1:	c3                   	ret    

0080f3e2 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f3e2:	f3 0f 1e fb          	endbr32 
  80f3e6:	55                   	push   %ebp
  80f3e7:	89 e5                	mov    %esp,%ebp
  80f3e9:	57                   	push   %edi
  80f3ea:	56                   	push   %esi
  80f3eb:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f3ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80f3f1:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f3f7:	89 c3                	mov    %eax,%ebx
  80f3f9:	89 c7                	mov    %eax,%edi
  80f3fb:	89 c6                	mov    %eax,%esi
  80f3fd:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f3ff:	5b                   	pop    %ebx
  80f400:	5e                   	pop    %esi
  80f401:	5f                   	pop    %edi
  80f402:	5d                   	pop    %ebp
  80f403:	c3                   	ret    

0080f404 <sys_cgetc>:

int
sys_cgetc(void)
{
  80f404:	f3 0f 1e fb          	endbr32 
  80f408:	55                   	push   %ebp
  80f409:	89 e5                	mov    %esp,%ebp
  80f40b:	57                   	push   %edi
  80f40c:	56                   	push   %esi
  80f40d:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f40e:	ba 00 00 00 00       	mov    $0x0,%edx
  80f413:	b8 01 00 00 00       	mov    $0x1,%eax
  80f418:	89 d1                	mov    %edx,%ecx
  80f41a:	89 d3                	mov    %edx,%ebx
  80f41c:	89 d7                	mov    %edx,%edi
  80f41e:	89 d6                	mov    %edx,%esi
  80f420:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f422:	5b                   	pop    %ebx
  80f423:	5e                   	pop    %esi
  80f424:	5f                   	pop    %edi
  80f425:	5d                   	pop    %ebp
  80f426:	c3                   	ret    

0080f427 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f427:	f3 0f 1e fb          	endbr32 
  80f42b:	55                   	push   %ebp
  80f42c:	89 e5                	mov    %esp,%ebp
  80f42e:	57                   	push   %edi
  80f42f:	56                   	push   %esi
  80f430:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f431:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f436:	8b 55 08             	mov    0x8(%ebp),%edx
  80f439:	b8 03 00 00 00       	mov    $0x3,%eax
  80f43e:	89 cb                	mov    %ecx,%ebx
  80f440:	89 cf                	mov    %ecx,%edi
  80f442:	89 ce                	mov    %ecx,%esi
  80f444:	cd 30                	int    $0x30
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f446:	5b                   	pop    %ebx
  80f447:	5e                   	pop    %esi
  80f448:	5f                   	pop    %edi
  80f449:	5d                   	pop    %ebp
  80f44a:	c3                   	ret    

0080f44b <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f44b:	f3 0f 1e fb          	endbr32 
  80f44f:	55                   	push   %ebp
  80f450:	89 e5                	mov    %esp,%ebp
  80f452:	57                   	push   %edi
  80f453:	56                   	push   %esi
  80f454:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f455:	ba 00 00 00 00       	mov    $0x0,%edx
  80f45a:	b8 02 00 00 00       	mov    $0x2,%eax
  80f45f:	89 d1                	mov    %edx,%ecx
  80f461:	89 d3                	mov    %edx,%ebx
  80f463:	89 d7                	mov    %edx,%edi
  80f465:	89 d6                	mov    %edx,%esi
  80f467:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f469:	5b                   	pop    %ebx
  80f46a:	5e                   	pop    %esi
  80f46b:	5f                   	pop    %edi
  80f46c:	5d                   	pop    %ebp
  80f46d:	c3                   	ret    

0080f46e <sys_yield>:

void
sys_yield(void)
{
  80f46e:	f3 0f 1e fb          	endbr32 
  80f472:	55                   	push   %ebp
  80f473:	89 e5                	mov    %esp,%ebp
  80f475:	57                   	push   %edi
  80f476:	56                   	push   %esi
  80f477:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f478:	ba 00 00 00 00       	mov    $0x0,%edx
  80f47d:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f482:	89 d1                	mov    %edx,%ecx
  80f484:	89 d3                	mov    %edx,%ebx
  80f486:	89 d7                	mov    %edx,%edi
  80f488:	89 d6                	mov    %edx,%esi
  80f48a:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f48c:	5b                   	pop    %ebx
  80f48d:	5e                   	pop    %esi
  80f48e:	5f                   	pop    %edi
  80f48f:	5d                   	pop    %ebp
  80f490:	c3                   	ret    

0080f491 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f491:	f3 0f 1e fb          	endbr32 
  80f495:	55                   	push   %ebp
  80f496:	89 e5                	mov    %esp,%ebp
  80f498:	57                   	push   %edi
  80f499:	56                   	push   %esi
  80f49a:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f49b:	be 00 00 00 00       	mov    $0x0,%esi
  80f4a0:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4a3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4a6:	b8 04 00 00 00       	mov    $0x4,%eax
  80f4ab:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f4ae:	89 f7                	mov    %esi,%edi
  80f4b0:	cd 30                	int    $0x30
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f4b2:	5b                   	pop    %ebx
  80f4b3:	5e                   	pop    %esi
  80f4b4:	5f                   	pop    %edi
  80f4b5:	5d                   	pop    %ebp
  80f4b6:	c3                   	ret    

0080f4b7 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f4b7:	f3 0f 1e fb          	endbr32 
  80f4bb:	55                   	push   %ebp
  80f4bc:	89 e5                	mov    %esp,%ebp
  80f4be:	57                   	push   %edi
  80f4bf:	56                   	push   %esi
  80f4c0:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f4c1:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4c4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4c7:	b8 05 00 00 00       	mov    $0x5,%eax
  80f4cc:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f4cf:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f4d2:	8b 75 18             	mov    0x18(%ebp),%esi
  80f4d5:	cd 30                	int    $0x30
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f4d7:	5b                   	pop    %ebx
  80f4d8:	5e                   	pop    %esi
  80f4d9:	5f                   	pop    %edi
  80f4da:	5d                   	pop    %ebp
  80f4db:	c3                   	ret    

0080f4dc <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f4dc:	f3 0f 1e fb          	endbr32 
  80f4e0:	55                   	push   %ebp
  80f4e1:	89 e5                	mov    %esp,%ebp
  80f4e3:	57                   	push   %edi
  80f4e4:	56                   	push   %esi
  80f4e5:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f4e6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f4eb:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4ee:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4f1:	b8 06 00 00 00       	mov    $0x6,%eax
  80f4f6:	89 df                	mov    %ebx,%edi
  80f4f8:	89 de                	mov    %ebx,%esi
  80f4fa:	cd 30                	int    $0x30
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f4fc:	5b                   	pop    %ebx
  80f4fd:	5e                   	pop    %esi
  80f4fe:	5f                   	pop    %edi
  80f4ff:	5d                   	pop    %ebp
  80f500:	c3                   	ret    

0080f501 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f501:	f3 0f 1e fb          	endbr32 
  80f505:	55                   	push   %ebp
  80f506:	89 e5                	mov    %esp,%ebp
  80f508:	57                   	push   %edi
  80f509:	56                   	push   %esi
  80f50a:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f50b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f510:	8b 55 08             	mov    0x8(%ebp),%edx
  80f513:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f516:	b8 08 00 00 00       	mov    $0x8,%eax
  80f51b:	89 df                	mov    %ebx,%edi
  80f51d:	89 de                	mov    %ebx,%esi
  80f51f:	cd 30                	int    $0x30
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f521:	5b                   	pop    %ebx
  80f522:	5e                   	pop    %esi
  80f523:	5f                   	pop    %edi
  80f524:	5d                   	pop    %ebp
  80f525:	c3                   	ret    

0080f526 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f526:	f3 0f 1e fb          	endbr32 
  80f52a:	55                   	push   %ebp
  80f52b:	89 e5                	mov    %esp,%ebp
  80f52d:	57                   	push   %edi
  80f52e:	56                   	push   %esi
  80f52f:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f530:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f535:	8b 55 08             	mov    0x8(%ebp),%edx
  80f538:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f53b:	b8 09 00 00 00       	mov    $0x9,%eax
  80f540:	89 df                	mov    %ebx,%edi
  80f542:	89 de                	mov    %ebx,%esi
  80f544:	cd 30                	int    $0x30
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f546:	5b                   	pop    %ebx
  80f547:	5e                   	pop    %esi
  80f548:	5f                   	pop    %edi
  80f549:	5d                   	pop    %ebp
  80f54a:	c3                   	ret    

0080f54b <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f54b:	f3 0f 1e fb          	endbr32 
  80f54f:	55                   	push   %ebp
  80f550:	89 e5                	mov    %esp,%ebp
  80f552:	57                   	push   %edi
  80f553:	56                   	push   %esi
  80f554:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f555:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f55a:	8b 55 08             	mov    0x8(%ebp),%edx
  80f55d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f560:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f565:	89 df                	mov    %ebx,%edi
  80f567:	89 de                	mov    %ebx,%esi
  80f569:	cd 30                	int    $0x30
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f56b:	5b                   	pop    %ebx
  80f56c:	5e                   	pop    %esi
  80f56d:	5f                   	pop    %edi
  80f56e:	5d                   	pop    %ebp
  80f56f:	c3                   	ret    

0080f570 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f570:	f3 0f 1e fb          	endbr32 
  80f574:	55                   	push   %ebp
  80f575:	89 e5                	mov    %esp,%ebp
  80f577:	57                   	push   %edi
  80f578:	56                   	push   %esi
  80f579:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f57a:	8b 55 08             	mov    0x8(%ebp),%edx
  80f57d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f580:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f585:	be 00 00 00 00       	mov    $0x0,%esi
  80f58a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f58d:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f590:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f592:	5b                   	pop    %ebx
  80f593:	5e                   	pop    %esi
  80f594:	5f                   	pop    %edi
  80f595:	5d                   	pop    %ebp
  80f596:	c3                   	ret    

0080f597 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f597:	f3 0f 1e fb          	endbr32 
  80f59b:	55                   	push   %ebp
  80f59c:	89 e5                	mov    %esp,%ebp
  80f59e:	57                   	push   %edi
  80f59f:	56                   	push   %esi
  80f5a0:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f5a1:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f5a6:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5a9:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f5ae:	89 cb                	mov    %ecx,%ebx
  80f5b0:	89 cf                	mov    %ecx,%edi
  80f5b2:	89 ce                	mov    %ecx,%esi
  80f5b4:	cd 30                	int    $0x30
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f5b6:	5b                   	pop    %ebx
  80f5b7:	5e                   	pop    %esi
  80f5b8:	5f                   	pop    %edi
  80f5b9:	5d                   	pop    %ebp
  80f5ba:	c3                   	ret    

0080f5bb <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f5bb:	f3 0f 1e fb          	endbr32 
  80f5bf:	55                   	push   %ebp
  80f5c0:	89 e5                	mov    %esp,%ebp
  80f5c2:	57                   	push   %edi
  80f5c3:	56                   	push   %esi
  80f5c4:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f5c5:	ba 00 00 00 00       	mov    $0x0,%edx
  80f5ca:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f5cf:	89 d1                	mov    %edx,%ecx
  80f5d1:	89 d3                	mov    %edx,%ebx
  80f5d3:	89 d7                	mov    %edx,%edi
  80f5d5:	89 d6                	mov    %edx,%esi
  80f5d7:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f5d9:	5b                   	pop    %ebx
  80f5da:	5e                   	pop    %esi
  80f5db:	5f                   	pop    %edi
  80f5dc:	5d                   	pop    %ebp
  80f5dd:	c3                   	ret    

0080f5de <sys_netpacket_try_send>:

int 
sys_netpacket_try_send(void* buf, size_t len)
{
  80f5de:	f3 0f 1e fb          	endbr32 
  80f5e2:	55                   	push   %ebp
  80f5e3:	89 e5                	mov    %esp,%ebp
  80f5e5:	57                   	push   %edi
  80f5e6:	56                   	push   %esi
  80f5e7:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f5e8:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f5ed:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5f0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5f3:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f5f8:	89 df                	mov    %ebx,%edi
  80f5fa:	89 de                	mov    %ebx,%esi
  80f5fc:	cd 30                	int    $0x30
	return syscall(SYS_netpacket_try_send, 1, (uint32_t)buf, len, 0, 0, 0);
}
  80f5fe:	5b                   	pop    %ebx
  80f5ff:	5e                   	pop    %esi
  80f600:	5f                   	pop    %edi
  80f601:	5d                   	pop    %ebp
  80f602:	c3                   	ret    

0080f603 <sys_netpacket_recv>:

int 
sys_netpacket_recv(void* buf, size_t buflen)
{
  80f603:	f3 0f 1e fb          	endbr32 
  80f607:	55                   	push   %ebp
  80f608:	89 e5                	mov    %esp,%ebp
  80f60a:	57                   	push   %edi
  80f60b:	56                   	push   %esi
  80f60c:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f60d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f612:	8b 55 08             	mov    0x8(%ebp),%edx
  80f615:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f618:	b8 10 00 00 00       	mov    $0x10,%eax
  80f61d:	89 df                	mov    %ebx,%edi
  80f61f:	89 de                	mov    %ebx,%esi
  80f621:	cd 30                	int    $0x30
	return syscall(SYS_netpacket_recv, 1, (uint32_t)buf, buflen, 0, 0, 0);
  80f623:	5b                   	pop    %ebx
  80f624:	5e                   	pop    %esi
  80f625:	5f                   	pop    %edi
  80f626:	5d                   	pop    %ebp
  80f627:	c3                   	ret    

0080f628 <pgfault>:
// map in our own private writable copy.
//
extern int cnt;
static void
pgfault(struct UTrapframe *utf)
{
  80f628:	f3 0f 1e fb          	endbr32 
  80f62c:	55                   	push   %ebp
  80f62d:	89 e5                	mov    %esp,%ebp
  80f62f:	53                   	push   %ebx
  80f630:	83 ec 04             	sub    $0x4,%esp
  80f633:	8b 45 08             	mov    0x8(%ebp),%eax
	// cprintf("[%08x] called pgfault\n", sys_getenvid());
	void *addr = (void *) utf->utf_fault_va;
  80f636:	8b 18                	mov    (%eax),%ebx
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	if (!((err&FEC_WR)&&(uvpd[PDX(addr)]&PTE_P)&&(uvpt[PGNUM(addr)]&PTE_P)&&(uvpt[PGNUM(addr)]&PTE_COW))){
  80f638:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80f63c:	0f 84 9a 00 00 00    	je     80f6dc <pgfault+0xb4>
  80f642:	89 d8                	mov    %ebx,%eax
  80f644:	c1 e8 16             	shr    $0x16,%eax
  80f647:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f64e:	a8 01                	test   $0x1,%al
  80f650:	0f 84 86 00 00 00    	je     80f6dc <pgfault+0xb4>
  80f656:	89 d8                	mov    %ebx,%eax
  80f658:	c1 e8 0c             	shr    $0xc,%eax
  80f65b:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f662:	f6 c2 01             	test   $0x1,%dl
  80f665:	74 75                	je     80f6dc <pgfault+0xb4>
  80f667:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f66e:	f6 c4 08             	test   $0x8,%ah
  80f671:	74 69                	je     80f6dc <pgfault+0xb4>
	// Hint:
	//   You should make three system calls.

	// LAB 4: Your code here.
	// 在PFTEMP这里给一个物理地址的mapping 相当于store一个物理地址
	if((r = sys_page_alloc(0, (void*)PFTEMP, PTE_P|PTE_U|PTE_W))<0){
  80f673:	83 ec 04             	sub    $0x4,%esp
  80f676:	6a 07                	push   $0x7
  80f678:	68 00 f0 7f 00       	push   $0x7ff000
  80f67d:	6a 00                	push   $0x0
  80f67f:	e8 0d fe ff ff       	call   80f491 <sys_page_alloc>
  80f684:	83 c4 10             	add    $0x10,%esp
  80f687:	85 c0                	test   %eax,%eax
  80f689:	78 63                	js     80f6ee <pgfault+0xc6>
		panic("pgfault: sys_page_alloc failed due to %e\n",r);
	}
	addr = ROUNDDOWN(addr, PGSIZE);
  80f68b:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	// 先复制addr里的content
	memcpy((void*)PFTEMP, addr, PGSIZE);
  80f691:	83 ec 04             	sub    $0x4,%esp
  80f694:	68 00 10 00 00       	push   $0x1000
  80f699:	53                   	push   %ebx
  80f69a:	68 00 f0 7f 00       	push   $0x7ff000
  80f69f:	e8 e8 fb ff ff       	call   80f28c <memcpy>
	// 在remap addr到PFTEMP位置 即addr与PFTEMP指向同一个物理内存
	if ((r = sys_page_map(0, (void*)PFTEMP, 0, addr, PTE_P|PTE_U|PTE_W))<0){
  80f6a4:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f6ab:	53                   	push   %ebx
  80f6ac:	6a 00                	push   $0x0
  80f6ae:	68 00 f0 7f 00       	push   $0x7ff000
  80f6b3:	6a 00                	push   $0x0
  80f6b5:	e8 fd fd ff ff       	call   80f4b7 <sys_page_map>
  80f6ba:	83 c4 20             	add    $0x20,%esp
  80f6bd:	85 c0                	test   %eax,%eax
  80f6bf:	78 3f                	js     80f700 <pgfault+0xd8>
		panic("pgfault: sys_page_map failed due to %e\n", r);
	}
	if ((r = sys_page_unmap(0, (void*)PFTEMP))<0){
  80f6c1:	83 ec 08             	sub    $0x8,%esp
  80f6c4:	68 00 f0 7f 00       	push   $0x7ff000
  80f6c9:	6a 00                	push   $0x0
  80f6cb:	e8 0c fe ff ff       	call   80f4dc <sys_page_unmap>
  80f6d0:	83 c4 10             	add    $0x10,%esp
  80f6d3:	85 c0                	test   %eax,%eax
  80f6d5:	78 3b                	js     80f712 <pgfault+0xea>
		panic("pgfault: sys_page_unmap failed due to %e\n", r);
	}
	
	
}
  80f6d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f6da:	c9                   	leave  
  80f6db:	c3                   	ret    
		panic("pgfault: page access at %08x is not a write to a copy-on-write\n", addr);
  80f6dc:	53                   	push   %ebx
  80f6dd:	68 80 3a 81 00       	push   $0x813a80
  80f6e2:	6a 20                	push   $0x20
  80f6e4:	68 3e 3b 81 00       	push   $0x813b3e
  80f6e9:	e8 49 f2 ff ff       	call   80e937 <_panic>
		panic("pgfault: sys_page_alloc failed due to %e\n",r);
  80f6ee:	50                   	push   %eax
  80f6ef:	68 c0 3a 81 00       	push   $0x813ac0
  80f6f4:	6a 2c                	push   $0x2c
  80f6f6:	68 3e 3b 81 00       	push   $0x813b3e
  80f6fb:	e8 37 f2 ff ff       	call   80e937 <_panic>
		panic("pgfault: sys_page_map failed due to %e\n", r);
  80f700:	50                   	push   %eax
  80f701:	68 ec 3a 81 00       	push   $0x813aec
  80f706:	6a 33                	push   $0x33
  80f708:	68 3e 3b 81 00       	push   $0x813b3e
  80f70d:	e8 25 f2 ff ff       	call   80e937 <_panic>
		panic("pgfault: sys_page_unmap failed due to %e\n", r);
  80f712:	50                   	push   %eax
  80f713:	68 14 3b 81 00       	push   $0x813b14
  80f718:	6a 36                	push   $0x36
  80f71a:	68 3e 3b 81 00       	push   $0x813b3e
  80f71f:	e8 13 f2 ff ff       	call   80e937 <_panic>

0080f724 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f724:	f3 0f 1e fb          	endbr32 
  80f728:	55                   	push   %ebp
  80f729:	89 e5                	mov    %esp,%ebp
  80f72b:	57                   	push   %edi
  80f72c:	56                   	push   %esi
  80f72d:	53                   	push   %ebx
  80f72e:	83 ec 28             	sub    $0x28,%esp
	// LAB 4: Your code here.
	// cprintf("[%08x] called fork\n", sys_getenvid());
	int r; uintptr_t addr;
	set_pgfault_handler(pgfault);
  80f731:	68 28 f6 80 00       	push   $0x80f628
  80f736:	e8 29 17 00 00       	call   810e64 <set_pgfault_handler>
*/
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f73b:	b8 07 00 00 00       	mov    $0x7,%eax
  80f740:	cd 30                	int    $0x30
  80f742:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	envid_t envid = sys_exofork();
		
	if (envid<0){
  80f745:	83 c4 10             	add    $0x10,%esp
  80f748:	85 c0                	test   %eax,%eax
  80f74a:	78 29                	js     80f775 <fork+0x51>
  80f74c:	89 c7                	mov    %eax,%edi
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	
	// duplicate parent address space
	for (addr = 0;addr<USTACKTOP; addr+=PGSIZE){
  80f74e:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (envid==0){
  80f753:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f757:	75 60                	jne    80f7b9 <fork+0x95>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f759:	e8 ed fc ff ff       	call   80f44b <sys_getenvid>
  80f75e:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f763:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f766:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f76b:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
		return 0;
  80f770:	e9 14 01 00 00       	jmp    80f889 <fork+0x165>
		panic("fork: sys_exofork error %e\n", envid);
  80f775:	50                   	push   %eax
  80f776:	68 49 3b 81 00       	push   $0x813b49
  80f77b:	68 90 00 00 00       	push   $0x90
  80f780:	68 3e 3b 81 00       	push   $0x813b3e
  80f785:	e8 ad f1 ff ff       	call   80e937 <_panic>
		r = sys_page_map(0, addr, envid, addr, (uvpt[pn]&PTE_SYSCALL));
  80f78a:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f791:	83 ec 0c             	sub    $0xc,%esp
  80f794:	25 07 0e 00 00       	and    $0xe07,%eax
  80f799:	50                   	push   %eax
  80f79a:	56                   	push   %esi
  80f79b:	57                   	push   %edi
  80f79c:	56                   	push   %esi
  80f79d:	6a 00                	push   $0x0
  80f79f:	e8 13 fd ff ff       	call   80f4b7 <sys_page_map>
  80f7a4:	83 c4 20             	add    $0x20,%esp
	for (addr = 0;addr<USTACKTOP; addr+=PGSIZE){
  80f7a7:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f7ad:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f7b3:	0f 84 95 00 00 00    	je     80f84e <fork+0x12a>
		if ((uvpd[PDX(addr)]&PTE_P)&&(uvpt[PGNUM(addr)]&PTE_P)){
  80f7b9:	89 d8                	mov    %ebx,%eax
  80f7bb:	c1 e8 16             	shr    $0x16,%eax
  80f7be:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f7c5:	a8 01                	test   $0x1,%al
  80f7c7:	74 de                	je     80f7a7 <fork+0x83>
  80f7c9:	89 d8                	mov    %ebx,%eax
  80f7cb:	c1 e8 0c             	shr    $0xc,%eax
  80f7ce:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f7d5:	f6 c2 01             	test   $0x1,%dl
  80f7d8:	74 cd                	je     80f7a7 <fork+0x83>
	void* addr = (void*)(pn*PGSIZE);
  80f7da:	89 c6                	mov    %eax,%esi
  80f7dc:	c1 e6 0c             	shl    $0xc,%esi
	if (uvpt[pn]&PTE_SHARE){
  80f7df:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f7e6:	f6 c6 04             	test   $0x4,%dh
  80f7e9:	75 9f                	jne    80f78a <fork+0x66>
		if (uvpt[pn]&PTE_W||uvpt[pn]&PTE_COW){
  80f7eb:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f7f2:	f6 c2 02             	test   $0x2,%dl
  80f7f5:	75 0c                	jne    80f803 <fork+0xdf>
  80f7f7:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f7fe:	f6 c4 08             	test   $0x8,%ah
  80f801:	74 34                	je     80f837 <fork+0x113>
			r = sys_page_map(0, addr, envid, addr, PTE_COW|PTE_U|PTE_P); // not writable
  80f803:	83 ec 0c             	sub    $0xc,%esp
  80f806:	68 05 08 00 00       	push   $0x805
  80f80b:	56                   	push   %esi
  80f80c:	57                   	push   %edi
  80f80d:	56                   	push   %esi
  80f80e:	6a 00                	push   $0x0
  80f810:	e8 a2 fc ff ff       	call   80f4b7 <sys_page_map>
			if (r<0) return r;
  80f815:	83 c4 20             	add    $0x20,%esp
  80f818:	85 c0                	test   %eax,%eax
  80f81a:	78 8b                	js     80f7a7 <fork+0x83>
			r = sys_page_map(0, addr, 0, addr, PTE_COW|PTE_U|PTE_P); // not writable
  80f81c:	83 ec 0c             	sub    $0xc,%esp
  80f81f:	68 05 08 00 00       	push   $0x805
  80f824:	56                   	push   %esi
  80f825:	6a 00                	push   $0x0
  80f827:	56                   	push   %esi
  80f828:	6a 00                	push   $0x0
  80f82a:	e8 88 fc ff ff       	call   80f4b7 <sys_page_map>
  80f82f:	83 c4 20             	add    $0x20,%esp
  80f832:	e9 70 ff ff ff       	jmp    80f7a7 <fork+0x83>
			if ((r=sys_page_map(0, addr, envid, addr, PTE_P|PTE_U)<0))// read only
  80f837:	83 ec 0c             	sub    $0xc,%esp
  80f83a:	6a 05                	push   $0x5
  80f83c:	56                   	push   %esi
  80f83d:	57                   	push   %edi
  80f83e:	56                   	push   %esi
  80f83f:	6a 00                	push   $0x0
  80f841:	e8 71 fc ff ff       	call   80f4b7 <sys_page_map>
  80f846:	83 c4 20             	add    $0x20,%esp
  80f849:	e9 59 ff ff ff       	jmp    80f7a7 <fork+0x83>
			duppage(envid, PGNUM(addr));
		}
	}
	// allocate user exception stack
	// cprintf("alloc user expection stack\n");
	if ((r = sys_page_alloc(envid, (void*)(UXSTACKTOP-PGSIZE),PTE_P|PTE_W|PTE_U))<0)
  80f84e:	83 ec 04             	sub    $0x4,%esp
  80f851:	6a 07                	push   $0x7
  80f853:	68 00 f0 bf ee       	push   $0xeebff000
  80f858:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80f85b:	56                   	push   %esi
  80f85c:	e8 30 fc ff ff       	call   80f491 <sys_page_alloc>
  80f861:	83 c4 10             	add    $0x10,%esp
  80f864:	85 c0                	test   %eax,%eax
  80f866:	78 2b                	js     80f893 <fork+0x16f>
		return r;
	
	extern void* _pgfault_upcall();
	sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  80f868:	83 ec 08             	sub    $0x8,%esp
  80f86b:	68 d7 0e 81 00       	push   $0x810ed7
  80f870:	56                   	push   %esi
  80f871:	e8 d5 fc ff ff       	call   80f54b <sys_env_set_pgfault_upcall>

	if ((r = sys_env_set_status(envid, ENV_RUNNABLE))<0)
  80f876:	83 c4 08             	add    $0x8,%esp
  80f879:	6a 02                	push   $0x2
  80f87b:	56                   	push   %esi
  80f87c:	e8 80 fc ff ff       	call   80f501 <sys_env_set_status>
  80f881:	83 c4 10             	add    $0x10,%esp
		return r;
  80f884:	85 c0                	test   %eax,%eax
  80f886:	0f 48 f8             	cmovs  %eax,%edi

	return envid;
	
}
  80f889:	89 f8                	mov    %edi,%eax
  80f88b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f88e:	5b                   	pop    %ebx
  80f88f:	5e                   	pop    %esi
  80f890:	5f                   	pop    %edi
  80f891:	5d                   	pop    %ebp
  80f892:	c3                   	ret    
		return r;
  80f893:	89 c7                	mov    %eax,%edi
  80f895:	eb f2                	jmp    80f889 <fork+0x165>

0080f897 <sfork>:

// Challenge(not sure yet)
int
sfork(void)
{
  80f897:	f3 0f 1e fb          	endbr32 
  80f89b:	55                   	push   %ebp
  80f89c:	89 e5                	mov    %esp,%ebp
  80f89e:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f8a1:	68 65 3b 81 00       	push   $0x813b65
  80f8a6:	68 b2 00 00 00       	push   $0xb2
  80f8ab:	68 3e 3b 81 00       	push   $0x813b3e
  80f8b0:	e8 82 f0 ff ff       	call   80e937 <_panic>

0080f8b5 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f8b5:	f3 0f 1e fb          	endbr32 
  80f8b9:	55                   	push   %ebp
  80f8ba:	89 e5                	mov    %esp,%ebp
  80f8bc:	56                   	push   %esi
  80f8bd:	53                   	push   %ebx
  80f8be:	8b 75 08             	mov    0x8(%ebp),%esi
  80f8c1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f8c4:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	int err;
	pg = (pg==NULL)?(void*)UTOP:pg;
  80f8c7:	85 c0                	test   %eax,%eax
  80f8c9:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80f8ce:	0f 44 c2             	cmove  %edx,%eax
	
	if ((err = sys_ipc_recv(pg))==0){
  80f8d1:	83 ec 0c             	sub    $0xc,%esp
  80f8d4:	50                   	push   %eax
  80f8d5:	e8 bd fc ff ff       	call   80f597 <sys_ipc_recv>
  80f8da:	83 c4 10             	add    $0x10,%esp
  80f8dd:	85 c0                	test   %eax,%eax
  80f8df:	75 2b                	jne    80f90c <ipc_recv+0x57>
		// syscall succeeded 
		if (from_env_store)
  80f8e1:	85 f6                	test   %esi,%esi
  80f8e3:	74 0a                	je     80f8ef <ipc_recv+0x3a>
			*from_env_store = thisenv->env_ipc_from;
  80f8e5:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f8ea:	8b 40 74             	mov    0x74(%eax),%eax
  80f8ed:	89 06                	mov    %eax,(%esi)
		if (perm_store)
  80f8ef:	85 db                	test   %ebx,%ebx
  80f8f1:	74 0a                	je     80f8fd <ipc_recv+0x48>
			*perm_store = thisenv->env_ipc_perm;
  80f8f3:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f8f8:	8b 40 78             	mov    0x78(%eax),%eax
  80f8fb:	89 03                	mov    %eax,(%ebx)
	else{
		if (from_env_store) *from_env_store = 0;
		if (perm_store) *perm_store = 0;
		return err;
	}
	return thisenv->env_ipc_value;
  80f8fd:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f902:	8b 40 70             	mov    0x70(%eax),%eax
}
  80f905:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f908:	5b                   	pop    %ebx
  80f909:	5e                   	pop    %esi
  80f90a:	5d                   	pop    %ebp
  80f90b:	c3                   	ret    
		if (from_env_store) *from_env_store = 0;
  80f90c:	85 f6                	test   %esi,%esi
  80f90e:	74 06                	je     80f916 <ipc_recv+0x61>
  80f910:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if (perm_store) *perm_store = 0;
  80f916:	85 db                	test   %ebx,%ebx
  80f918:	74 eb                	je     80f905 <ipc_recv+0x50>
  80f91a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80f920:	eb e3                	jmp    80f905 <ipc_recv+0x50>

0080f922 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f922:	f3 0f 1e fb          	endbr32 
  80f926:	55                   	push   %ebp
  80f927:	89 e5                	mov    %esp,%ebp
  80f929:	57                   	push   %edi
  80f92a:	56                   	push   %esi
  80f92b:	53                   	push   %ebx
  80f92c:	83 ec 0c             	sub    $0xc,%esp
  80f92f:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f932:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f935:	8b 5d 10             	mov    0x10(%ebp),%ebx
	 * C99:It says "An integer constant expression with the value 0, 
	 * or such an expression cast to type void *,
	 * is called a null pointer constant." 
	 * It also says that a character literal is an integer constant expression.
	*/
	pg = (pg==NULL)? (void*)UTOP:pg;
  80f938:	85 db                	test   %ebx,%ebx
  80f93a:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80f93f:	0f 44 d8             	cmove  %eax,%ebx
	while(1){
		ret = sys_ipc_try_send(to_env, val, pg, perm);
  80f942:	ff 75 14             	pushl  0x14(%ebp)
  80f945:	53                   	push   %ebx
  80f946:	56                   	push   %esi
  80f947:	57                   	push   %edi
  80f948:	e8 23 fc ff ff       	call   80f570 <sys_ipc_try_send>
		if (ret == -E_IPC_NOT_RECV){
  80f94d:	83 c4 10             	add    $0x10,%esp
  80f950:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80f953:	75 07                	jne    80f95c <ipc_send+0x3a>
			sys_yield();
  80f955:	e8 14 fb ff ff       	call   80f46e <sys_yield>
		ret = sys_ipc_try_send(to_env, val, pg, perm);
  80f95a:	eb e6                	jmp    80f942 <ipc_send+0x20>
		}
		else if (ret == 0)
  80f95c:	85 c0                	test   %eax,%eax
  80f95e:	75 08                	jne    80f968 <ipc_send+0x46>
			return; // succeeded
		else
			panic("ipc_send: %e\n", ret);
	}
		
}
  80f960:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f963:	5b                   	pop    %ebx
  80f964:	5e                   	pop    %esi
  80f965:	5f                   	pop    %edi
  80f966:	5d                   	pop    %ebp
  80f967:	c3                   	ret    
			panic("ipc_send: %e\n", ret);
  80f968:	50                   	push   %eax
  80f969:	68 7b 3b 81 00       	push   $0x813b7b
  80f96e:	6a 48                	push   $0x48
  80f970:	68 89 3b 81 00       	push   $0x813b89
  80f975:	e8 bd ef ff ff       	call   80e937 <_panic>

0080f97a <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f97a:	f3 0f 1e fb          	endbr32 
  80f97e:	55                   	push   %ebp
  80f97f:	89 e5                	mov    %esp,%ebp
  80f981:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f984:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f989:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f98c:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f992:	8b 52 50             	mov    0x50(%edx),%edx
  80f995:	39 ca                	cmp    %ecx,%edx
  80f997:	74 11                	je     80f9aa <ipc_find_env+0x30>
	for (i = 0; i < NENV; i++)
  80f999:	83 c0 01             	add    $0x1,%eax
  80f99c:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f9a1:	75 e6                	jne    80f989 <ipc_find_env+0xf>
			return envs[i].env_id;
	return 0;
  80f9a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80f9a8:	eb 0b                	jmp    80f9b5 <ipc_find_env+0x3b>
			return envs[i].env_id;
  80f9aa:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f9ad:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f9b2:	8b 40 48             	mov    0x48(%eax),%eax
}
  80f9b5:	5d                   	pop    %ebp
  80f9b6:	c3                   	ret    

0080f9b7 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f9b7:	f3 0f 1e fb          	endbr32 
  80f9bb:	55                   	push   %ebp
  80f9bc:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f9be:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9c1:	05 00 00 00 30       	add    $0x30000000,%eax
  80f9c6:	c1 e8 0c             	shr    $0xc,%eax
}
  80f9c9:	5d                   	pop    %ebp
  80f9ca:	c3                   	ret    

0080f9cb <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80f9cb:	f3 0f 1e fb          	endbr32 
  80f9cf:	55                   	push   %ebp
  80f9d0:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f9d2:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9d5:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80f9da:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f9df:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80f9e4:	5d                   	pop    %ebp
  80f9e5:	c3                   	ret    

0080f9e6 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80f9e6:	f3 0f 1e fb          	endbr32 
  80f9ea:	55                   	push   %ebp
  80f9eb:	89 e5                	mov    %esp,%ebp
  80f9ed:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80f9f2:	89 c2                	mov    %eax,%edx
  80f9f4:	c1 ea 16             	shr    $0x16,%edx
  80f9f7:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f9fe:	f6 c2 01             	test   $0x1,%dl
  80fa01:	74 2d                	je     80fa30 <fd_alloc+0x4a>
  80fa03:	89 c2                	mov    %eax,%edx
  80fa05:	c1 ea 0c             	shr    $0xc,%edx
  80fa08:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fa0f:	f6 c2 01             	test   $0x1,%dl
  80fa12:	74 1c                	je     80fa30 <fd_alloc+0x4a>
  80fa14:	05 00 10 00 00       	add    $0x1000,%eax
	for (i = 0; i < MAXFD; i++) {
  80fa19:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80fa1e:	75 d2                	jne    80f9f2 <fd_alloc+0xc>
			if (debug) 
				cprintf("[%08x] alloc fd %d\n", thisenv->env_id, i);
			return 0;
		}
	}
	*fd_store = 0;
  80fa20:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa23:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_MAX_OPEN;
  80fa29:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80fa2e:	eb 0a                	jmp    80fa3a <fd_alloc+0x54>
			*fd_store = fd;
  80fa30:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80fa33:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fa35:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fa3a:	5d                   	pop    %ebp
  80fa3b:	c3                   	ret    

0080fa3c <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80fa3c:	f3 0f 1e fb          	endbr32 
  80fa40:	55                   	push   %ebp
  80fa41:	89 e5                	mov    %esp,%ebp
  80fa43:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80fa46:	83 f8 1f             	cmp    $0x1f,%eax
  80fa49:	77 30                	ja     80fa7b <fd_lookup+0x3f>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80fa4b:	c1 e0 0c             	shl    $0xc,%eax
  80fa4e:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80fa53:	8b 15 00 dd 7b ef    	mov    0xef7bdd00,%edx
  80fa59:	f6 c2 01             	test   $0x1,%dl
  80fa5c:	74 24                	je     80fa82 <fd_lookup+0x46>
  80fa5e:	89 c2                	mov    %eax,%edx
  80fa60:	c1 ea 0c             	shr    $0xc,%edx
  80fa63:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fa6a:	f6 c2 01             	test   $0x1,%dl
  80fa6d:	74 1a                	je     80fa89 <fd_lookup+0x4d>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80fa6f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fa72:	89 02                	mov    %eax,(%edx)
	return 0;
  80fa74:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fa79:	5d                   	pop    %ebp
  80fa7a:	c3                   	ret    
		return -E_INVAL;
  80fa7b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fa80:	eb f7                	jmp    80fa79 <fd_lookup+0x3d>
		return -E_INVAL;
  80fa82:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fa87:	eb f0                	jmp    80fa79 <fd_lookup+0x3d>
  80fa89:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fa8e:	eb e9                	jmp    80fa79 <fd_lookup+0x3d>

0080fa90 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80fa90:	f3 0f 1e fb          	endbr32 
  80fa94:	55                   	push   %ebp
  80fa95:	89 e5                	mov    %esp,%ebp
  80fa97:	83 ec 08             	sub    $0x8,%esp
  80fa9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  80fa9d:	ba 00 00 00 00       	mov    $0x0,%edx
  80faa2:	b8 00 43 81 00       	mov    $0x814300,%eax
		if (devtab[i]->dev_id == dev_id) {
  80faa7:	39 08                	cmp    %ecx,(%eax)
  80faa9:	74 38                	je     80fae3 <dev_lookup+0x53>
	for (i = 0; devtab[i]; i++)
  80faab:	83 c2 01             	add    $0x1,%edx
  80faae:	8b 04 95 10 3c 81 00 	mov    0x813c10(,%edx,4),%eax
  80fab5:	85 c0                	test   %eax,%eax
  80fab7:	75 ee                	jne    80faa7 <dev_lookup+0x17>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80fab9:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fabe:	8b 40 48             	mov    0x48(%eax),%eax
  80fac1:	83 ec 04             	sub    $0x4,%esp
  80fac4:	51                   	push   %ecx
  80fac5:	50                   	push   %eax
  80fac6:	68 94 3b 81 00       	push   $0x813b94
  80facb:	e8 4e ef ff ff       	call   80ea1e <cprintf>
	*dev = 0;
  80fad0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fad3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80fad9:	83 c4 10             	add    $0x10,%esp
  80fadc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80fae1:	c9                   	leave  
  80fae2:	c3                   	ret    
			*dev = devtab[i];
  80fae3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fae6:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fae8:	b8 00 00 00 00       	mov    $0x0,%eax
  80faed:	eb f2                	jmp    80fae1 <dev_lookup+0x51>

0080faef <fd_close>:
{
  80faef:	f3 0f 1e fb          	endbr32 
  80faf3:	55                   	push   %ebp
  80faf4:	89 e5                	mov    %esp,%ebp
  80faf6:	57                   	push   %edi
  80faf7:	56                   	push   %esi
  80faf8:	53                   	push   %ebx
  80faf9:	83 ec 24             	sub    $0x24,%esp
  80fafc:	8b 75 08             	mov    0x8(%ebp),%esi
  80faff:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fb02:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fb05:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fb06:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80fb0c:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fb0f:	50                   	push   %eax
  80fb10:	e8 27 ff ff ff       	call   80fa3c <fd_lookup>
  80fb15:	89 c3                	mov    %eax,%ebx
  80fb17:	83 c4 10             	add    $0x10,%esp
  80fb1a:	85 c0                	test   %eax,%eax
  80fb1c:	78 05                	js     80fb23 <fd_close+0x34>
	    || fd != fd2)
  80fb1e:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80fb21:	74 16                	je     80fb39 <fd_close+0x4a>
		return (must_exist ? r : 0);
  80fb23:	89 f8                	mov    %edi,%eax
  80fb25:	84 c0                	test   %al,%al
  80fb27:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb2c:	0f 44 d8             	cmove  %eax,%ebx
}
  80fb2f:	89 d8                	mov    %ebx,%eax
  80fb31:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fb34:	5b                   	pop    %ebx
  80fb35:	5e                   	pop    %esi
  80fb36:	5f                   	pop    %edi
  80fb37:	5d                   	pop    %ebp
  80fb38:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80fb39:	83 ec 08             	sub    $0x8,%esp
  80fb3c:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80fb3f:	50                   	push   %eax
  80fb40:	ff 36                	pushl  (%esi)
  80fb42:	e8 49 ff ff ff       	call   80fa90 <dev_lookup>
  80fb47:	89 c3                	mov    %eax,%ebx
  80fb49:	83 c4 10             	add    $0x10,%esp
  80fb4c:	85 c0                	test   %eax,%eax
  80fb4e:	78 1a                	js     80fb6a <fd_close+0x7b>
		if (dev->dev_close)
  80fb50:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fb53:	8b 40 10             	mov    0x10(%eax),%eax
			r = 0;
  80fb56:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (dev->dev_close)
  80fb5b:	85 c0                	test   %eax,%eax
  80fb5d:	74 0b                	je     80fb6a <fd_close+0x7b>
			r = (*dev->dev_close)(fd);
  80fb5f:	83 ec 0c             	sub    $0xc,%esp
  80fb62:	56                   	push   %esi
  80fb63:	ff d0                	call   *%eax
  80fb65:	89 c3                	mov    %eax,%ebx
  80fb67:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80fb6a:	83 ec 08             	sub    $0x8,%esp
  80fb6d:	56                   	push   %esi
  80fb6e:	6a 00                	push   $0x0
  80fb70:	e8 67 f9 ff ff       	call   80f4dc <sys_page_unmap>
	return r;
  80fb75:	83 c4 10             	add    $0x10,%esp
  80fb78:	eb b5                	jmp    80fb2f <fd_close+0x40>

0080fb7a <close>:

int
close(int fdnum)
{
  80fb7a:	f3 0f 1e fb          	endbr32 
  80fb7e:	55                   	push   %ebp
  80fb7f:	89 e5                	mov    %esp,%ebp
  80fb81:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fb84:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fb87:	50                   	push   %eax
  80fb88:	ff 75 08             	pushl  0x8(%ebp)
  80fb8b:	e8 ac fe ff ff       	call   80fa3c <fd_lookup>
  80fb90:	83 c4 10             	add    $0x10,%esp
  80fb93:	85 c0                	test   %eax,%eax
  80fb95:	79 02                	jns    80fb99 <close+0x1f>
		return r;
	else
		return fd_close(fd, 1);
}
  80fb97:	c9                   	leave  
  80fb98:	c3                   	ret    
		return fd_close(fd, 1);
  80fb99:	83 ec 08             	sub    $0x8,%esp
  80fb9c:	6a 01                	push   $0x1
  80fb9e:	ff 75 f4             	pushl  -0xc(%ebp)
  80fba1:	e8 49 ff ff ff       	call   80faef <fd_close>
  80fba6:	83 c4 10             	add    $0x10,%esp
  80fba9:	eb ec                	jmp    80fb97 <close+0x1d>

0080fbab <close_all>:

void
close_all(void)
{
  80fbab:	f3 0f 1e fb          	endbr32 
  80fbaf:	55                   	push   %ebp
  80fbb0:	89 e5                	mov    %esp,%ebp
  80fbb2:	53                   	push   %ebx
  80fbb3:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80fbb6:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80fbbb:	83 ec 0c             	sub    $0xc,%esp
  80fbbe:	53                   	push   %ebx
  80fbbf:	e8 b6 ff ff ff       	call   80fb7a <close>
	for (i = 0; i < MAXFD; i++)
  80fbc4:	83 c3 01             	add    $0x1,%ebx
  80fbc7:	83 c4 10             	add    $0x10,%esp
  80fbca:	83 fb 20             	cmp    $0x20,%ebx
  80fbcd:	75 ec                	jne    80fbbb <close_all+0x10>
}
  80fbcf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fbd2:	c9                   	leave  
  80fbd3:	c3                   	ret    

0080fbd4 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80fbd4:	f3 0f 1e fb          	endbr32 
  80fbd8:	55                   	push   %ebp
  80fbd9:	89 e5                	mov    %esp,%ebp
  80fbdb:	57                   	push   %edi
  80fbdc:	56                   	push   %esi
  80fbdd:	53                   	push   %ebx
  80fbde:	83 ec 24             	sub    $0x24,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80fbe1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fbe4:	50                   	push   %eax
  80fbe5:	ff 75 08             	pushl  0x8(%ebp)
  80fbe8:	e8 4f fe ff ff       	call   80fa3c <fd_lookup>
  80fbed:	89 c3                	mov    %eax,%ebx
  80fbef:	83 c4 10             	add    $0x10,%esp
  80fbf2:	85 c0                	test   %eax,%eax
  80fbf4:	0f 88 81 00 00 00    	js     80fc7b <dup+0xa7>
		return r;
	close(newfdnum);
  80fbfa:	83 ec 0c             	sub    $0xc,%esp
  80fbfd:	ff 75 0c             	pushl  0xc(%ebp)
  80fc00:	e8 75 ff ff ff       	call   80fb7a <close>

	newfd = INDEX2FD(newfdnum);
  80fc05:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fc08:	c1 e6 0c             	shl    $0xc,%esi
  80fc0b:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80fc11:	83 c4 04             	add    $0x4,%esp
  80fc14:	ff 75 e4             	pushl  -0x1c(%ebp)
  80fc17:	e8 af fd ff ff       	call   80f9cb <fd2data>
  80fc1c:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80fc1e:	89 34 24             	mov    %esi,(%esp)
  80fc21:	e8 a5 fd ff ff       	call   80f9cb <fd2data>
  80fc26:	83 c4 10             	add    $0x10,%esp
  80fc29:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80fc2b:	89 d8                	mov    %ebx,%eax
  80fc2d:	c1 e8 16             	shr    $0x16,%eax
  80fc30:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fc37:	a8 01                	test   $0x1,%al
  80fc39:	74 11                	je     80fc4c <dup+0x78>
  80fc3b:	89 d8                	mov    %ebx,%eax
  80fc3d:	c1 e8 0c             	shr    $0xc,%eax
  80fc40:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fc47:	f6 c2 01             	test   $0x1,%dl
  80fc4a:	75 39                	jne    80fc85 <dup+0xb1>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80fc4c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80fc4f:	89 d0                	mov    %edx,%eax
  80fc51:	c1 e8 0c             	shr    $0xc,%eax
  80fc54:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fc5b:	83 ec 0c             	sub    $0xc,%esp
  80fc5e:	25 07 0e 00 00       	and    $0xe07,%eax
  80fc63:	50                   	push   %eax
  80fc64:	56                   	push   %esi
  80fc65:	6a 00                	push   $0x0
  80fc67:	52                   	push   %edx
  80fc68:	6a 00                	push   $0x0
  80fc6a:	e8 48 f8 ff ff       	call   80f4b7 <sys_page_map>
  80fc6f:	89 c3                	mov    %eax,%ebx
  80fc71:	83 c4 20             	add    $0x20,%esp
  80fc74:	85 c0                	test   %eax,%eax
  80fc76:	78 31                	js     80fca9 <dup+0xd5>
		goto err;

	return newfdnum;
  80fc78:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80fc7b:	89 d8                	mov    %ebx,%eax
  80fc7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fc80:	5b                   	pop    %ebx
  80fc81:	5e                   	pop    %esi
  80fc82:	5f                   	pop    %edi
  80fc83:	5d                   	pop    %ebp
  80fc84:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80fc85:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fc8c:	83 ec 0c             	sub    $0xc,%esp
  80fc8f:	25 07 0e 00 00       	and    $0xe07,%eax
  80fc94:	50                   	push   %eax
  80fc95:	57                   	push   %edi
  80fc96:	6a 00                	push   $0x0
  80fc98:	53                   	push   %ebx
  80fc99:	6a 00                	push   $0x0
  80fc9b:	e8 17 f8 ff ff       	call   80f4b7 <sys_page_map>
  80fca0:	89 c3                	mov    %eax,%ebx
  80fca2:	83 c4 20             	add    $0x20,%esp
  80fca5:	85 c0                	test   %eax,%eax
  80fca7:	79 a3                	jns    80fc4c <dup+0x78>
	sys_page_unmap(0, newfd);
  80fca9:	83 ec 08             	sub    $0x8,%esp
  80fcac:	56                   	push   %esi
  80fcad:	6a 00                	push   $0x0
  80fcaf:	e8 28 f8 ff ff       	call   80f4dc <sys_page_unmap>
	sys_page_unmap(0, nva);
  80fcb4:	83 c4 08             	add    $0x8,%esp
  80fcb7:	57                   	push   %edi
  80fcb8:	6a 00                	push   $0x0
  80fcba:	e8 1d f8 ff ff       	call   80f4dc <sys_page_unmap>
	return r;
  80fcbf:	83 c4 10             	add    $0x10,%esp
  80fcc2:	eb b7                	jmp    80fc7b <dup+0xa7>

0080fcc4 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80fcc4:	f3 0f 1e fb          	endbr32 
  80fcc8:	55                   	push   %ebp
  80fcc9:	89 e5                	mov    %esp,%ebp
  80fccb:	53                   	push   %ebx
  80fccc:	83 ec 1c             	sub    $0x1c,%esp
  80fccf:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fcd2:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fcd5:	50                   	push   %eax
  80fcd6:	53                   	push   %ebx
  80fcd7:	e8 60 fd ff ff       	call   80fa3c <fd_lookup>
  80fcdc:	83 c4 10             	add    $0x10,%esp
  80fcdf:	85 c0                	test   %eax,%eax
  80fce1:	78 3f                	js     80fd22 <read+0x5e>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fce3:	83 ec 08             	sub    $0x8,%esp
  80fce6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fce9:	50                   	push   %eax
  80fcea:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fced:	ff 30                	pushl  (%eax)
  80fcef:	e8 9c fd ff ff       	call   80fa90 <dev_lookup>
  80fcf4:	83 c4 10             	add    $0x10,%esp
  80fcf7:	85 c0                	test   %eax,%eax
  80fcf9:	78 27                	js     80fd22 <read+0x5e>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80fcfb:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80fcfe:	8b 42 08             	mov    0x8(%edx),%eax
  80fd01:	83 e0 03             	and    $0x3,%eax
  80fd04:	83 f8 01             	cmp    $0x1,%eax
  80fd07:	74 1e                	je     80fd27 <read+0x63>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80fd09:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fd0c:	8b 40 08             	mov    0x8(%eax),%eax
  80fd0f:	85 c0                	test   %eax,%eax
  80fd11:	74 35                	je     80fd48 <read+0x84>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80fd13:	83 ec 04             	sub    $0x4,%esp
  80fd16:	ff 75 10             	pushl  0x10(%ebp)
  80fd19:	ff 75 0c             	pushl  0xc(%ebp)
  80fd1c:	52                   	push   %edx
  80fd1d:	ff d0                	call   *%eax
  80fd1f:	83 c4 10             	add    $0x10,%esp
}
  80fd22:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd25:	c9                   	leave  
  80fd26:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80fd27:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fd2c:	8b 40 48             	mov    0x48(%eax),%eax
  80fd2f:	83 ec 04             	sub    $0x4,%esp
  80fd32:	53                   	push   %ebx
  80fd33:	50                   	push   %eax
  80fd34:	68 d5 3b 81 00       	push   $0x813bd5
  80fd39:	e8 e0 ec ff ff       	call   80ea1e <cprintf>
		return -E_INVAL;
  80fd3e:	83 c4 10             	add    $0x10,%esp
  80fd41:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fd46:	eb da                	jmp    80fd22 <read+0x5e>
		return -E_NOT_SUPP;
  80fd48:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fd4d:	eb d3                	jmp    80fd22 <read+0x5e>

0080fd4f <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80fd4f:	f3 0f 1e fb          	endbr32 
  80fd53:	55                   	push   %ebp
  80fd54:	89 e5                	mov    %esp,%ebp
  80fd56:	57                   	push   %edi
  80fd57:	56                   	push   %esi
  80fd58:	53                   	push   %ebx
  80fd59:	83 ec 0c             	sub    $0xc,%esp
  80fd5c:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fd5f:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80fd62:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fd67:	eb 02                	jmp    80fd6b <readn+0x1c>
  80fd69:	01 c3                	add    %eax,%ebx
  80fd6b:	39 f3                	cmp    %esi,%ebx
  80fd6d:	73 21                	jae    80fd90 <readn+0x41>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fd6f:	83 ec 04             	sub    $0x4,%esp
  80fd72:	89 f0                	mov    %esi,%eax
  80fd74:	29 d8                	sub    %ebx,%eax
  80fd76:	50                   	push   %eax
  80fd77:	89 d8                	mov    %ebx,%eax
  80fd79:	03 45 0c             	add    0xc(%ebp),%eax
  80fd7c:	50                   	push   %eax
  80fd7d:	57                   	push   %edi
  80fd7e:	e8 41 ff ff ff       	call   80fcc4 <read>
		if (m < 0)
  80fd83:	83 c4 10             	add    $0x10,%esp
  80fd86:	85 c0                	test   %eax,%eax
  80fd88:	78 04                	js     80fd8e <readn+0x3f>
			return m;
		if (m == 0)
  80fd8a:	75 dd                	jne    80fd69 <readn+0x1a>
  80fd8c:	eb 02                	jmp    80fd90 <readn+0x41>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fd8e:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  80fd90:	89 d8                	mov    %ebx,%eax
  80fd92:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fd95:	5b                   	pop    %ebx
  80fd96:	5e                   	pop    %esi
  80fd97:	5f                   	pop    %edi
  80fd98:	5d                   	pop    %ebp
  80fd99:	c3                   	ret    

0080fd9a <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80fd9a:	f3 0f 1e fb          	endbr32 
  80fd9e:	55                   	push   %ebp
  80fd9f:	89 e5                	mov    %esp,%ebp
  80fda1:	53                   	push   %ebx
  80fda2:	83 ec 1c             	sub    $0x1c,%esp
  80fda5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fda8:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fdab:	50                   	push   %eax
  80fdac:	53                   	push   %ebx
  80fdad:	e8 8a fc ff ff       	call   80fa3c <fd_lookup>
  80fdb2:	83 c4 10             	add    $0x10,%esp
  80fdb5:	85 c0                	test   %eax,%eax
  80fdb7:	78 3a                	js     80fdf3 <write+0x59>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fdb9:	83 ec 08             	sub    $0x8,%esp
  80fdbc:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fdbf:	50                   	push   %eax
  80fdc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fdc3:	ff 30                	pushl  (%eax)
  80fdc5:	e8 c6 fc ff ff       	call   80fa90 <dev_lookup>
  80fdca:	83 c4 10             	add    $0x10,%esp
  80fdcd:	85 c0                	test   %eax,%eax
  80fdcf:	78 22                	js     80fdf3 <write+0x59>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80fdd1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fdd4:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80fdd8:	74 1e                	je     80fdf8 <write+0x5e>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80fdda:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fddd:	8b 52 0c             	mov    0xc(%edx),%edx
  80fde0:	85 d2                	test   %edx,%edx
  80fde2:	74 35                	je     80fe19 <write+0x7f>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80fde4:	83 ec 04             	sub    $0x4,%esp
  80fde7:	ff 75 10             	pushl  0x10(%ebp)
  80fdea:	ff 75 0c             	pushl  0xc(%ebp)
  80fded:	50                   	push   %eax
  80fdee:	ff d2                	call   *%edx
  80fdf0:	83 c4 10             	add    $0x10,%esp
}
  80fdf3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fdf6:	c9                   	leave  
  80fdf7:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80fdf8:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fdfd:	8b 40 48             	mov    0x48(%eax),%eax
  80fe00:	83 ec 04             	sub    $0x4,%esp
  80fe03:	53                   	push   %ebx
  80fe04:	50                   	push   %eax
  80fe05:	68 f1 3b 81 00       	push   $0x813bf1
  80fe0a:	e8 0f ec ff ff       	call   80ea1e <cprintf>
		return -E_INVAL;
  80fe0f:	83 c4 10             	add    $0x10,%esp
  80fe12:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fe17:	eb da                	jmp    80fdf3 <write+0x59>
		return -E_NOT_SUPP;
  80fe19:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fe1e:	eb d3                	jmp    80fdf3 <write+0x59>

0080fe20 <seek>:

int
seek(int fdnum, off_t offset)
{
  80fe20:	f3 0f 1e fb          	endbr32 
  80fe24:	55                   	push   %ebp
  80fe25:	89 e5                	mov    %esp,%ebp
  80fe27:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fe2a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fe2d:	50                   	push   %eax
  80fe2e:	ff 75 08             	pushl  0x8(%ebp)
  80fe31:	e8 06 fc ff ff       	call   80fa3c <fd_lookup>
  80fe36:	83 c4 10             	add    $0x10,%esp
  80fe39:	85 c0                	test   %eax,%eax
  80fe3b:	78 0e                	js     80fe4b <seek+0x2b>
		return r;
	fd->fd_offset = offset;
  80fe3d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fe40:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fe43:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80fe46:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fe4b:	c9                   	leave  
  80fe4c:	c3                   	ret    

0080fe4d <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80fe4d:	f3 0f 1e fb          	endbr32 
  80fe51:	55                   	push   %ebp
  80fe52:	89 e5                	mov    %esp,%ebp
  80fe54:	53                   	push   %ebx
  80fe55:	83 ec 1c             	sub    $0x1c,%esp
  80fe58:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fe5b:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fe5e:	50                   	push   %eax
  80fe5f:	53                   	push   %ebx
  80fe60:	e8 d7 fb ff ff       	call   80fa3c <fd_lookup>
  80fe65:	83 c4 10             	add    $0x10,%esp
  80fe68:	85 c0                	test   %eax,%eax
  80fe6a:	78 37                	js     80fea3 <ftruncate+0x56>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fe6c:	83 ec 08             	sub    $0x8,%esp
  80fe6f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fe72:	50                   	push   %eax
  80fe73:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fe76:	ff 30                	pushl  (%eax)
  80fe78:	e8 13 fc ff ff       	call   80fa90 <dev_lookup>
  80fe7d:	83 c4 10             	add    $0x10,%esp
  80fe80:	85 c0                	test   %eax,%eax
  80fe82:	78 1f                	js     80fea3 <ftruncate+0x56>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80fe84:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fe87:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80fe8b:	74 1b                	je     80fea8 <ftruncate+0x5b>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  80fe8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fe90:	8b 52 18             	mov    0x18(%edx),%edx
  80fe93:	85 d2                	test   %edx,%edx
  80fe95:	74 32                	je     80fec9 <ftruncate+0x7c>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80fe97:	83 ec 08             	sub    $0x8,%esp
  80fe9a:	ff 75 0c             	pushl  0xc(%ebp)
  80fe9d:	50                   	push   %eax
  80fe9e:	ff d2                	call   *%edx
  80fea0:	83 c4 10             	add    $0x10,%esp
}
  80fea3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fea6:	c9                   	leave  
  80fea7:	c3                   	ret    
			thisenv->env_id, fdnum);
  80fea8:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80fead:	8b 40 48             	mov    0x48(%eax),%eax
  80feb0:	83 ec 04             	sub    $0x4,%esp
  80feb3:	53                   	push   %ebx
  80feb4:	50                   	push   %eax
  80feb5:	68 b4 3b 81 00       	push   $0x813bb4
  80feba:	e8 5f eb ff ff       	call   80ea1e <cprintf>
		return -E_INVAL;
  80febf:	83 c4 10             	add    $0x10,%esp
  80fec2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fec7:	eb da                	jmp    80fea3 <ftruncate+0x56>
		return -E_NOT_SUPP;
  80fec9:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fece:	eb d3                	jmp    80fea3 <ftruncate+0x56>

0080fed0 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80fed0:	f3 0f 1e fb          	endbr32 
  80fed4:	55                   	push   %ebp
  80fed5:	89 e5                	mov    %esp,%ebp
  80fed7:	53                   	push   %ebx
  80fed8:	83 ec 1c             	sub    $0x1c,%esp
  80fedb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fede:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fee1:	50                   	push   %eax
  80fee2:	ff 75 08             	pushl  0x8(%ebp)
  80fee5:	e8 52 fb ff ff       	call   80fa3c <fd_lookup>
  80feea:	83 c4 10             	add    $0x10,%esp
  80feed:	85 c0                	test   %eax,%eax
  80feef:	78 4b                	js     80ff3c <fstat+0x6c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fef1:	83 ec 08             	sub    $0x8,%esp
  80fef4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fef7:	50                   	push   %eax
  80fef8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fefb:	ff 30                	pushl  (%eax)
  80fefd:	e8 8e fb ff ff       	call   80fa90 <dev_lookup>
  80ff02:	83 c4 10             	add    $0x10,%esp
  80ff05:	85 c0                	test   %eax,%eax
  80ff07:	78 33                	js     80ff3c <fstat+0x6c>
		return r;
	if (!dev->dev_stat)
  80ff09:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ff0c:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80ff10:	74 2f                	je     80ff41 <fstat+0x71>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80ff12:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80ff15:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80ff1c:	00 00 00 
	stat->st_isdir = 0;
  80ff1f:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80ff26:	00 00 00 
	stat->st_dev = dev;
  80ff29:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80ff2f:	83 ec 08             	sub    $0x8,%esp
  80ff32:	53                   	push   %ebx
  80ff33:	ff 75 f0             	pushl  -0x10(%ebp)
  80ff36:	ff 50 14             	call   *0x14(%eax)
  80ff39:	83 c4 10             	add    $0x10,%esp
}
  80ff3c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff3f:	c9                   	leave  
  80ff40:	c3                   	ret    
		return -E_NOT_SUPP;
  80ff41:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80ff46:	eb f4                	jmp    80ff3c <fstat+0x6c>

0080ff48 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80ff48:	f3 0f 1e fb          	endbr32 
  80ff4c:	55                   	push   %ebp
  80ff4d:	89 e5                	mov    %esp,%ebp
  80ff4f:	56                   	push   %esi
  80ff50:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80ff51:	83 ec 08             	sub    $0x8,%esp
  80ff54:	6a 00                	push   $0x0
  80ff56:	ff 75 08             	pushl  0x8(%ebp)
  80ff59:	e8 01 02 00 00       	call   81015f <open>
  80ff5e:	89 c3                	mov    %eax,%ebx
  80ff60:	83 c4 10             	add    $0x10,%esp
  80ff63:	85 c0                	test   %eax,%eax
  80ff65:	78 1b                	js     80ff82 <stat+0x3a>
		return fd;
	r = fstat(fd, stat);
  80ff67:	83 ec 08             	sub    $0x8,%esp
  80ff6a:	ff 75 0c             	pushl  0xc(%ebp)
  80ff6d:	50                   	push   %eax
  80ff6e:	e8 5d ff ff ff       	call   80fed0 <fstat>
  80ff73:	89 c6                	mov    %eax,%esi
	close(fd);
  80ff75:	89 1c 24             	mov    %ebx,(%esp)
  80ff78:	e8 fd fb ff ff       	call   80fb7a <close>
	return r;
  80ff7d:	83 c4 10             	add    $0x10,%esp
  80ff80:	89 f3                	mov    %esi,%ebx
}
  80ff82:	89 d8                	mov    %ebx,%eax
  80ff84:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ff87:	5b                   	pop    %ebx
  80ff88:	5e                   	pop    %esi
  80ff89:	5d                   	pop    %ebp
  80ff8a:	c3                   	ret    

0080ff8b <fsipc>:
	"FSREQ_REMOVE",
	"FSREQ_SYNC",
};
static int
fsipc(unsigned type, void *dstva)
{
  80ff8b:	55                   	push   %ebp
  80ff8c:	89 e5                	mov    %esp,%ebp
  80ff8e:	56                   	push   %esi
  80ff8f:	53                   	push   %ebx
  80ff90:	89 c6                	mov    %eax,%esi
  80ff92:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80ff94:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  80ff9b:	74 27                	je     80ffc4 <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %s %08x\n", thisenv->env_id, fsipctype[type-1], *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80ff9d:	6a 07                	push   $0x7
  80ff9f:	68 00 c0 b3 00       	push   $0xb3c000
  80ffa4:	56                   	push   %esi
  80ffa5:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  80ffab:	e8 72 f9 ff ff       	call   80f922 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80ffb0:	83 c4 0c             	add    $0xc,%esp
  80ffb3:	6a 00                	push   $0x0
  80ffb5:	53                   	push   %ebx
  80ffb6:	6a 00                	push   $0x0
  80ffb8:	e8 f8 f8 ff ff       	call   80f8b5 <ipc_recv>
}
  80ffbd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ffc0:	5b                   	pop    %ebx
  80ffc1:	5e                   	pop    %esi
  80ffc2:	5d                   	pop    %ebp
  80ffc3:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  80ffc4:	83 ec 0c             	sub    $0xc,%esp
  80ffc7:	6a 01                	push   $0x1
  80ffc9:	e8 ac f9 ff ff       	call   80f97a <ipc_find_env>
  80ffce:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  80ffd3:	83 c4 10             	add    $0x10,%esp
  80ffd6:	eb c5                	jmp    80ff9d <fsipc+0x12>

0080ffd8 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80ffd8:	f3 0f 1e fb          	endbr32 
  80ffdc:	55                   	push   %ebp
  80ffdd:	89 e5                	mov    %esp,%ebp
  80ffdf:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80ffe2:	8b 45 08             	mov    0x8(%ebp),%eax
  80ffe5:	8b 40 0c             	mov    0xc(%eax),%eax
  80ffe8:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  80ffed:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fff0:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80fff5:	ba 00 00 00 00       	mov    $0x0,%edx
  80fffa:	b8 02 00 00 00       	mov    $0x2,%eax
  80ffff:	e8 87 ff ff ff       	call   80ff8b <fsipc>
}
  810004:	c9                   	leave  
  810005:	c3                   	ret    

00810006 <devfile_flush>:
{
  810006:	f3 0f 1e fb          	endbr32 
  81000a:	55                   	push   %ebp
  81000b:	89 e5                	mov    %esp,%ebp
  81000d:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  810010:	8b 45 08             	mov    0x8(%ebp),%eax
  810013:	8b 40 0c             	mov    0xc(%eax),%eax
  810016:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  81001b:	ba 00 00 00 00       	mov    $0x0,%edx
  810020:	b8 06 00 00 00       	mov    $0x6,%eax
  810025:	e8 61 ff ff ff       	call   80ff8b <fsipc>
}
  81002a:	c9                   	leave  
  81002b:	c3                   	ret    

0081002c <devfile_stat>:
{
  81002c:	f3 0f 1e fb          	endbr32 
  810030:	55                   	push   %ebp
  810031:	89 e5                	mov    %esp,%ebp
  810033:	53                   	push   %ebx
  810034:	83 ec 04             	sub    $0x4,%esp
  810037:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  81003a:	8b 45 08             	mov    0x8(%ebp),%eax
  81003d:	8b 40 0c             	mov    0xc(%eax),%eax
  810040:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  810045:	ba 00 00 00 00       	mov    $0x0,%edx
  81004a:	b8 05 00 00 00       	mov    $0x5,%eax
  81004f:	e8 37 ff ff ff       	call   80ff8b <fsipc>
  810054:	85 c0                	test   %eax,%eax
  810056:	78 2c                	js     810084 <devfile_stat+0x58>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  810058:	83 ec 08             	sub    $0x8,%esp
  81005b:	68 00 c0 b3 00       	push   $0xb3c000
  810060:	53                   	push   %ebx
  810061:	e8 c2 ef ff ff       	call   80f028 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  810066:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  81006b:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  810071:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  810076:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  81007c:	83 c4 10             	add    $0x10,%esp
  81007f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810084:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810087:	c9                   	leave  
  810088:	c3                   	ret    

00810089 <devfile_write>:
{
  810089:	f3 0f 1e fb          	endbr32 
  81008d:	55                   	push   %ebp
  81008e:	89 e5                	mov    %esp,%ebp
  810090:	83 ec 0c             	sub    $0xc,%esp
  810093:	8b 45 10             	mov    0x10(%ebp),%eax
  810096:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  81009b:	ba f8 0f 00 00       	mov    $0xff8,%edx
  8100a0:	0f 47 c2             	cmova  %edx,%eax
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  8100a3:	8b 55 08             	mov    0x8(%ebp),%edx
  8100a6:	8b 52 0c             	mov    0xc(%edx),%edx
  8100a9:	89 15 00 c0 b3 00    	mov    %edx,0xb3c000
	fsipcbuf.write.req_n = n;
  8100af:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	memmove(fsipcbuf.write.req_buf, buf, n);
  8100b4:	50                   	push   %eax
  8100b5:	ff 75 0c             	pushl  0xc(%ebp)
  8100b8:	68 08 c0 b3 00       	push   $0xb3c008
  8100bd:	e8 64 f1 ff ff       	call   80f226 <memmove>
	return fsipc(FSREQ_WRITE, NULL);
  8100c2:	ba 00 00 00 00       	mov    $0x0,%edx
  8100c7:	b8 04 00 00 00       	mov    $0x4,%eax
  8100cc:	e8 ba fe ff ff       	call   80ff8b <fsipc>
}
  8100d1:	c9                   	leave  
  8100d2:	c3                   	ret    

008100d3 <devfile_read>:
{
  8100d3:	f3 0f 1e fb          	endbr32 
  8100d7:	55                   	push   %ebp
  8100d8:	89 e5                	mov    %esp,%ebp
  8100da:	56                   	push   %esi
  8100db:	53                   	push   %ebx
  8100dc:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  8100df:	8b 45 08             	mov    0x8(%ebp),%eax
  8100e2:	8b 40 0c             	mov    0xc(%eax),%eax
  8100e5:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  8100ea:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  8100f0:	ba 00 00 00 00       	mov    $0x0,%edx
  8100f5:	b8 03 00 00 00       	mov    $0x3,%eax
  8100fa:	e8 8c fe ff ff       	call   80ff8b <fsipc>
  8100ff:	89 c3                	mov    %eax,%ebx
  810101:	85 c0                	test   %eax,%eax
  810103:	78 1f                	js     810124 <devfile_read+0x51>
	assert(r <= n);
  810105:	39 f0                	cmp    %esi,%eax
  810107:	77 24                	ja     81012d <devfile_read+0x5a>
	assert(r <= PGSIZE);
  810109:	3d 00 10 00 00       	cmp    $0x1000,%eax
  81010e:	7f 36                	jg     810146 <devfile_read+0x73>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  810110:	83 ec 04             	sub    $0x4,%esp
  810113:	50                   	push   %eax
  810114:	68 00 c0 b3 00       	push   $0xb3c000
  810119:	ff 75 0c             	pushl  0xc(%ebp)
  81011c:	e8 05 f1 ff ff       	call   80f226 <memmove>
	return r;
  810121:	83 c4 10             	add    $0x10,%esp
}
  810124:	89 d8                	mov    %ebx,%eax
  810126:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810129:	5b                   	pop    %ebx
  81012a:	5e                   	pop    %esi
  81012b:	5d                   	pop    %ebp
  81012c:	c3                   	ret    
	assert(r <= n);
  81012d:	68 24 3c 81 00       	push   $0x813c24
  810132:	68 4b 29 81 00       	push   $0x81294b
  810137:	68 8c 00 00 00       	push   $0x8c
  81013c:	68 2b 3c 81 00       	push   $0x813c2b
  810141:	e8 f1 e7 ff ff       	call   80e937 <_panic>
	assert(r <= PGSIZE);
  810146:	68 36 3c 81 00       	push   $0x813c36
  81014b:	68 4b 29 81 00       	push   $0x81294b
  810150:	68 8d 00 00 00       	push   $0x8d
  810155:	68 2b 3c 81 00       	push   $0x813c2b
  81015a:	e8 d8 e7 ff ff       	call   80e937 <_panic>

0081015f <open>:
{
  81015f:	f3 0f 1e fb          	endbr32 
  810163:	55                   	push   %ebp
  810164:	89 e5                	mov    %esp,%ebp
  810166:	56                   	push   %esi
  810167:	53                   	push   %ebx
  810168:	83 ec 1c             	sub    $0x1c,%esp
  81016b:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  81016e:	56                   	push   %esi
  81016f:	e8 71 ee ff ff       	call   80efe5 <strlen>
  810174:	83 c4 10             	add    $0x10,%esp
  810177:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  81017c:	7f 6c                	jg     8101ea <open+0x8b>
	if ((r = fd_alloc(&fd)) < 0)
  81017e:	83 ec 0c             	sub    $0xc,%esp
  810181:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810184:	50                   	push   %eax
  810185:	e8 5c f8 ff ff       	call   80f9e6 <fd_alloc>
  81018a:	89 c3                	mov    %eax,%ebx
  81018c:	83 c4 10             	add    $0x10,%esp
  81018f:	85 c0                	test   %eax,%eax
  810191:	78 3c                	js     8101cf <open+0x70>
	strcpy(fsipcbuf.open.req_path, path);
  810193:	83 ec 08             	sub    $0x8,%esp
  810196:	56                   	push   %esi
  810197:	68 00 c0 b3 00       	push   $0xb3c000
  81019c:	e8 87 ee ff ff       	call   80f028 <strcpy>
	fsipcbuf.open.req_omode = mode;
  8101a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8101a4:	a3 00 c4 b3 00       	mov    %eax,0xb3c400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  8101a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8101ac:	b8 01 00 00 00       	mov    $0x1,%eax
  8101b1:	e8 d5 fd ff ff       	call   80ff8b <fsipc>
  8101b6:	89 c3                	mov    %eax,%ebx
  8101b8:	83 c4 10             	add    $0x10,%esp
  8101bb:	85 c0                	test   %eax,%eax
  8101bd:	78 19                	js     8101d8 <open+0x79>
	return fd2num(fd);
  8101bf:	83 ec 0c             	sub    $0xc,%esp
  8101c2:	ff 75 f4             	pushl  -0xc(%ebp)
  8101c5:	e8 ed f7 ff ff       	call   80f9b7 <fd2num>
  8101ca:	89 c3                	mov    %eax,%ebx
  8101cc:	83 c4 10             	add    $0x10,%esp
}
  8101cf:	89 d8                	mov    %ebx,%eax
  8101d1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8101d4:	5b                   	pop    %ebx
  8101d5:	5e                   	pop    %esi
  8101d6:	5d                   	pop    %ebp
  8101d7:	c3                   	ret    
		fd_close(fd, 0);
  8101d8:	83 ec 08             	sub    $0x8,%esp
  8101db:	6a 00                	push   $0x0
  8101dd:	ff 75 f4             	pushl  -0xc(%ebp)
  8101e0:	e8 0a f9 ff ff       	call   80faef <fd_close>
		return r;
  8101e5:	83 c4 10             	add    $0x10,%esp
  8101e8:	eb e5                	jmp    8101cf <open+0x70>
		return -E_BAD_PATH;
  8101ea:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  8101ef:	eb de                	jmp    8101cf <open+0x70>

008101f1 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  8101f1:	f3 0f 1e fb          	endbr32 
  8101f5:	55                   	push   %ebp
  8101f6:	89 e5                	mov    %esp,%ebp
  8101f8:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  8101fb:	ba 00 00 00 00       	mov    $0x0,%edx
  810200:	b8 08 00 00 00       	mov    $0x8,%eax
  810205:	e8 81 fd ff ff       	call   80ff8b <fsipc>
}
  81020a:	c9                   	leave  
  81020b:	c3                   	ret    

0081020c <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  81020c:	f3 0f 1e fb          	endbr32 
  810210:	55                   	push   %ebp
  810211:	89 e5                	mov    %esp,%ebp
  810213:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  810216:	68 a2 3c 81 00       	push   $0x813ca2
  81021b:	ff 75 0c             	pushl  0xc(%ebp)
  81021e:	e8 05 ee ff ff       	call   80f028 <strcpy>
	return 0;
}
  810223:	b8 00 00 00 00       	mov    $0x0,%eax
  810228:	c9                   	leave  
  810229:	c3                   	ret    

0081022a <devsock_close>:
{
  81022a:	f3 0f 1e fb          	endbr32 
  81022e:	55                   	push   %ebp
  81022f:	89 e5                	mov    %esp,%ebp
  810231:	53                   	push   %ebx
  810232:	83 ec 10             	sub    $0x10,%esp
  810235:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  810238:	53                   	push   %ebx
  810239:	e8 bd 0c 00 00       	call   810efb <pageref>
  81023e:	89 c2                	mov    %eax,%edx
  810240:	83 c4 10             	add    $0x10,%esp
		return 0;
  810243:	b8 00 00 00 00       	mov    $0x0,%eax
	if (pageref(fd) == 1)
  810248:	83 fa 01             	cmp    $0x1,%edx
  81024b:	74 05                	je     810252 <devsock_close+0x28>
}
  81024d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810250:	c9                   	leave  
  810251:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  810252:	83 ec 0c             	sub    $0xc,%esp
  810255:	ff 73 0c             	pushl  0xc(%ebx)
  810258:	e8 e3 02 00 00       	call   810540 <nsipc_close>
  81025d:	83 c4 10             	add    $0x10,%esp
  810260:	eb eb                	jmp    81024d <devsock_close+0x23>

00810262 <devsock_write>:
{
  810262:	f3 0f 1e fb          	endbr32 
  810266:	55                   	push   %ebp
  810267:	89 e5                	mov    %esp,%ebp
  810269:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  81026c:	6a 00                	push   $0x0
  81026e:	ff 75 10             	pushl  0x10(%ebp)
  810271:	ff 75 0c             	pushl  0xc(%ebp)
  810274:	8b 45 08             	mov    0x8(%ebp),%eax
  810277:	ff 70 0c             	pushl  0xc(%eax)
  81027a:	e8 b5 03 00 00       	call   810634 <nsipc_send>
}
  81027f:	c9                   	leave  
  810280:	c3                   	ret    

00810281 <devsock_read>:
{
  810281:	f3 0f 1e fb          	endbr32 
  810285:	55                   	push   %ebp
  810286:	89 e5                	mov    %esp,%ebp
  810288:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  81028b:	6a 00                	push   $0x0
  81028d:	ff 75 10             	pushl  0x10(%ebp)
  810290:	ff 75 0c             	pushl  0xc(%ebp)
  810293:	8b 45 08             	mov    0x8(%ebp),%eax
  810296:	ff 70 0c             	pushl  0xc(%eax)
  810299:	e8 1f 03 00 00       	call   8105bd <nsipc_recv>
}
  81029e:	c9                   	leave  
  81029f:	c3                   	ret    

008102a0 <fd2sockid>:
{
  8102a0:	55                   	push   %ebp
  8102a1:	89 e5                	mov    %esp,%ebp
  8102a3:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  8102a6:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8102a9:	52                   	push   %edx
  8102aa:	50                   	push   %eax
  8102ab:	e8 8c f7 ff ff       	call   80fa3c <fd_lookup>
  8102b0:	83 c4 10             	add    $0x10,%esp
  8102b3:	85 c0                	test   %eax,%eax
  8102b5:	78 10                	js     8102c7 <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  8102b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8102ba:	8b 0d 40 43 81 00    	mov    0x814340,%ecx
  8102c0:	39 08                	cmp    %ecx,(%eax)
  8102c2:	75 05                	jne    8102c9 <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  8102c4:	8b 40 0c             	mov    0xc(%eax),%eax
}
  8102c7:	c9                   	leave  
  8102c8:	c3                   	ret    
		return -E_NOT_SUPP;
  8102c9:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8102ce:	eb f7                	jmp    8102c7 <fd2sockid+0x27>

008102d0 <alloc_sockfd>:
{
  8102d0:	55                   	push   %ebp
  8102d1:	89 e5                	mov    %esp,%ebp
  8102d3:	56                   	push   %esi
  8102d4:	53                   	push   %ebx
  8102d5:	83 ec 1c             	sub    $0x1c,%esp
  8102d8:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  8102da:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8102dd:	50                   	push   %eax
  8102de:	e8 03 f7 ff ff       	call   80f9e6 <fd_alloc>
  8102e3:	89 c3                	mov    %eax,%ebx
  8102e5:	83 c4 10             	add    $0x10,%esp
  8102e8:	85 c0                	test   %eax,%eax
  8102ea:	78 43                	js     81032f <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  8102ec:	83 ec 04             	sub    $0x4,%esp
  8102ef:	68 07 04 00 00       	push   $0x407
  8102f4:	ff 75 f4             	pushl  -0xc(%ebp)
  8102f7:	6a 00                	push   $0x0
  8102f9:	e8 93 f1 ff ff       	call   80f491 <sys_page_alloc>
  8102fe:	89 c3                	mov    %eax,%ebx
  810300:	83 c4 10             	add    $0x10,%esp
  810303:	85 c0                	test   %eax,%eax
  810305:	78 28                	js     81032f <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  810307:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81030a:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810310:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  810312:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810315:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  81031c:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  81031f:	83 ec 0c             	sub    $0xc,%esp
  810322:	50                   	push   %eax
  810323:	e8 8f f6 ff ff       	call   80f9b7 <fd2num>
  810328:	89 c3                	mov    %eax,%ebx
  81032a:	83 c4 10             	add    $0x10,%esp
  81032d:	eb 0c                	jmp    81033b <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  81032f:	83 ec 0c             	sub    $0xc,%esp
  810332:	56                   	push   %esi
  810333:	e8 08 02 00 00       	call   810540 <nsipc_close>
		return r;
  810338:	83 c4 10             	add    $0x10,%esp
}
  81033b:	89 d8                	mov    %ebx,%eax
  81033d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810340:	5b                   	pop    %ebx
  810341:	5e                   	pop    %esi
  810342:	5d                   	pop    %ebp
  810343:	c3                   	ret    

00810344 <accept>:
{
  810344:	f3 0f 1e fb          	endbr32 
  810348:	55                   	push   %ebp
  810349:	89 e5                	mov    %esp,%ebp
  81034b:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81034e:	8b 45 08             	mov    0x8(%ebp),%eax
  810351:	e8 4a ff ff ff       	call   8102a0 <fd2sockid>
  810356:	85 c0                	test   %eax,%eax
  810358:	78 1b                	js     810375 <accept+0x31>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  81035a:	83 ec 04             	sub    $0x4,%esp
  81035d:	ff 75 10             	pushl  0x10(%ebp)
  810360:	ff 75 0c             	pushl  0xc(%ebp)
  810363:	50                   	push   %eax
  810364:	e8 22 01 00 00       	call   81048b <nsipc_accept>
  810369:	83 c4 10             	add    $0x10,%esp
  81036c:	85 c0                	test   %eax,%eax
  81036e:	78 05                	js     810375 <accept+0x31>
	return alloc_sockfd(r);
  810370:	e8 5b ff ff ff       	call   8102d0 <alloc_sockfd>
}
  810375:	c9                   	leave  
  810376:	c3                   	ret    

00810377 <bind>:
{
  810377:	f3 0f 1e fb          	endbr32 
  81037b:	55                   	push   %ebp
  81037c:	89 e5                	mov    %esp,%ebp
  81037e:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810381:	8b 45 08             	mov    0x8(%ebp),%eax
  810384:	e8 17 ff ff ff       	call   8102a0 <fd2sockid>
  810389:	85 c0                	test   %eax,%eax
  81038b:	78 12                	js     81039f <bind+0x28>
	return nsipc_bind(r, name, namelen);
  81038d:	83 ec 04             	sub    $0x4,%esp
  810390:	ff 75 10             	pushl  0x10(%ebp)
  810393:	ff 75 0c             	pushl  0xc(%ebp)
  810396:	50                   	push   %eax
  810397:	e8 45 01 00 00       	call   8104e1 <nsipc_bind>
  81039c:	83 c4 10             	add    $0x10,%esp
}
  81039f:	c9                   	leave  
  8103a0:	c3                   	ret    

008103a1 <shutdown>:
{
  8103a1:	f3 0f 1e fb          	endbr32 
  8103a5:	55                   	push   %ebp
  8103a6:	89 e5                	mov    %esp,%ebp
  8103a8:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8103ab:	8b 45 08             	mov    0x8(%ebp),%eax
  8103ae:	e8 ed fe ff ff       	call   8102a0 <fd2sockid>
  8103b3:	85 c0                	test   %eax,%eax
  8103b5:	78 0f                	js     8103c6 <shutdown+0x25>
	return nsipc_shutdown(r, how);
  8103b7:	83 ec 08             	sub    $0x8,%esp
  8103ba:	ff 75 0c             	pushl  0xc(%ebp)
  8103bd:	50                   	push   %eax
  8103be:	e8 57 01 00 00       	call   81051a <nsipc_shutdown>
  8103c3:	83 c4 10             	add    $0x10,%esp
}
  8103c6:	c9                   	leave  
  8103c7:	c3                   	ret    

008103c8 <connect>:
{
  8103c8:	f3 0f 1e fb          	endbr32 
  8103cc:	55                   	push   %ebp
  8103cd:	89 e5                	mov    %esp,%ebp
  8103cf:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8103d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8103d5:	e8 c6 fe ff ff       	call   8102a0 <fd2sockid>
  8103da:	85 c0                	test   %eax,%eax
  8103dc:	78 12                	js     8103f0 <connect+0x28>
	return nsipc_connect(r, name, namelen);
  8103de:	83 ec 04             	sub    $0x4,%esp
  8103e1:	ff 75 10             	pushl  0x10(%ebp)
  8103e4:	ff 75 0c             	pushl  0xc(%ebp)
  8103e7:	50                   	push   %eax
  8103e8:	e8 71 01 00 00       	call   81055e <nsipc_connect>
  8103ed:	83 c4 10             	add    $0x10,%esp
}
  8103f0:	c9                   	leave  
  8103f1:	c3                   	ret    

008103f2 <listen>:
{
  8103f2:	f3 0f 1e fb          	endbr32 
  8103f6:	55                   	push   %ebp
  8103f7:	89 e5                	mov    %esp,%ebp
  8103f9:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8103fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8103ff:	e8 9c fe ff ff       	call   8102a0 <fd2sockid>
  810404:	85 c0                	test   %eax,%eax
  810406:	78 0f                	js     810417 <listen+0x25>
	return nsipc_listen(r, backlog);
  810408:	83 ec 08             	sub    $0x8,%esp
  81040b:	ff 75 0c             	pushl  0xc(%ebp)
  81040e:	50                   	push   %eax
  81040f:	e8 83 01 00 00       	call   810597 <nsipc_listen>
  810414:	83 c4 10             	add    $0x10,%esp
}
  810417:	c9                   	leave  
  810418:	c3                   	ret    

00810419 <socket>:

int
socket(int domain, int type, int protocol)
{
  810419:	f3 0f 1e fb          	endbr32 
  81041d:	55                   	push   %ebp
  81041e:	89 e5                	mov    %esp,%ebp
  810420:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  810423:	ff 75 10             	pushl  0x10(%ebp)
  810426:	ff 75 0c             	pushl  0xc(%ebp)
  810429:	ff 75 08             	pushl  0x8(%ebp)
  81042c:	e8 65 02 00 00       	call   810696 <nsipc_socket>
  810431:	83 c4 10             	add    $0x10,%esp
  810434:	85 c0                	test   %eax,%eax
  810436:	78 05                	js     81043d <socket+0x24>
		return r;
	return alloc_sockfd(r);
  810438:	e8 93 fe ff ff       	call   8102d0 <alloc_sockfd>
}
  81043d:	c9                   	leave  
  81043e:	c3                   	ret    

0081043f <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  81043f:	55                   	push   %ebp
  810440:	89 e5                	mov    %esp,%ebp
  810442:	53                   	push   %ebx
  810443:	83 ec 04             	sub    $0x4,%esp
  810446:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  810448:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  81044f:	74 26                	je     810477 <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  810451:	6a 07                	push   $0x7
  810453:	68 00 d0 b3 00       	push   $0xb3d000
  810458:	53                   	push   %ebx
  810459:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  81045f:	e8 be f4 ff ff       	call   80f922 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  810464:	83 c4 0c             	add    $0xc,%esp
  810467:	6a 00                	push   $0x0
  810469:	6a 00                	push   $0x0
  81046b:	6a 00                	push   $0x0
  81046d:	e8 43 f4 ff ff       	call   80f8b5 <ipc_recv>
}
  810472:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810475:	c9                   	leave  
  810476:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  810477:	83 ec 0c             	sub    $0xc,%esp
  81047a:	6a 02                	push   $0x2
  81047c:	e8 f9 f4 ff ff       	call   80f97a <ipc_find_env>
  810481:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  810486:	83 c4 10             	add    $0x10,%esp
  810489:	eb c6                	jmp    810451 <nsipc+0x12>

0081048b <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  81048b:	f3 0f 1e fb          	endbr32 
  81048f:	55                   	push   %ebp
  810490:	89 e5                	mov    %esp,%ebp
  810492:	56                   	push   %esi
  810493:	53                   	push   %ebx
  810494:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  810497:	8b 45 08             	mov    0x8(%ebp),%eax
  81049a:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  81049f:	8b 06                	mov    (%esi),%eax
  8104a1:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8104a6:	b8 01 00 00 00       	mov    $0x1,%eax
  8104ab:	e8 8f ff ff ff       	call   81043f <nsipc>
  8104b0:	89 c3                	mov    %eax,%ebx
  8104b2:	85 c0                	test   %eax,%eax
  8104b4:	79 09                	jns    8104bf <nsipc_accept+0x34>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
		*addrlen = ret->ret_addrlen;
	}
	return r;
}
  8104b6:	89 d8                	mov    %ebx,%eax
  8104b8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8104bb:	5b                   	pop    %ebx
  8104bc:	5e                   	pop    %esi
  8104bd:	5d                   	pop    %ebp
  8104be:	c3                   	ret    
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8104bf:	83 ec 04             	sub    $0x4,%esp
  8104c2:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  8104c8:	68 00 d0 b3 00       	push   $0xb3d000
  8104cd:	ff 75 0c             	pushl  0xc(%ebp)
  8104d0:	e8 51 ed ff ff       	call   80f226 <memmove>
		*addrlen = ret->ret_addrlen;
  8104d5:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  8104da:	89 06                	mov    %eax,(%esi)
  8104dc:	83 c4 10             	add    $0x10,%esp
	return r;
  8104df:	eb d5                	jmp    8104b6 <nsipc_accept+0x2b>

008104e1 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8104e1:	f3 0f 1e fb          	endbr32 
  8104e5:	55                   	push   %ebp
  8104e6:	89 e5                	mov    %esp,%ebp
  8104e8:	53                   	push   %ebx
  8104e9:	83 ec 08             	sub    $0x8,%esp
  8104ec:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  8104ef:	8b 45 08             	mov    0x8(%ebp),%eax
  8104f2:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  8104f7:	53                   	push   %ebx
  8104f8:	ff 75 0c             	pushl  0xc(%ebp)
  8104fb:	68 04 d0 b3 00       	push   $0xb3d004
  810500:	e8 21 ed ff ff       	call   80f226 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  810505:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  81050b:	b8 02 00 00 00       	mov    $0x2,%eax
  810510:	e8 2a ff ff ff       	call   81043f <nsipc>
}
  810515:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810518:	c9                   	leave  
  810519:	c3                   	ret    

0081051a <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  81051a:	f3 0f 1e fb          	endbr32 
  81051e:	55                   	push   %ebp
  81051f:	89 e5                	mov    %esp,%ebp
  810521:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  810524:	8b 45 08             	mov    0x8(%ebp),%eax
  810527:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  81052c:	8b 45 0c             	mov    0xc(%ebp),%eax
  81052f:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  810534:	b8 03 00 00 00       	mov    $0x3,%eax
  810539:	e8 01 ff ff ff       	call   81043f <nsipc>
}
  81053e:	c9                   	leave  
  81053f:	c3                   	ret    

00810540 <nsipc_close>:

int
nsipc_close(int s)
{
  810540:	f3 0f 1e fb          	endbr32 
  810544:	55                   	push   %ebp
  810545:	89 e5                	mov    %esp,%ebp
  810547:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  81054a:	8b 45 08             	mov    0x8(%ebp),%eax
  81054d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  810552:	b8 04 00 00 00       	mov    $0x4,%eax
  810557:	e8 e3 fe ff ff       	call   81043f <nsipc>
}
  81055c:	c9                   	leave  
  81055d:	c3                   	ret    

0081055e <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  81055e:	f3 0f 1e fb          	endbr32 
  810562:	55                   	push   %ebp
  810563:	89 e5                	mov    %esp,%ebp
  810565:	53                   	push   %ebx
  810566:	83 ec 08             	sub    $0x8,%esp
  810569:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  81056c:	8b 45 08             	mov    0x8(%ebp),%eax
  81056f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  810574:	53                   	push   %ebx
  810575:	ff 75 0c             	pushl  0xc(%ebp)
  810578:	68 04 d0 b3 00       	push   $0xb3d004
  81057d:	e8 a4 ec ff ff       	call   80f226 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810582:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  810588:	b8 05 00 00 00       	mov    $0x5,%eax
  81058d:	e8 ad fe ff ff       	call   81043f <nsipc>
}
  810592:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810595:	c9                   	leave  
  810596:	c3                   	ret    

00810597 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810597:	f3 0f 1e fb          	endbr32 
  81059b:	55                   	push   %ebp
  81059c:	89 e5                	mov    %esp,%ebp
  81059e:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  8105a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8105a4:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  8105a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8105ac:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  8105b1:	b8 06 00 00 00       	mov    $0x6,%eax
  8105b6:	e8 84 fe ff ff       	call   81043f <nsipc>
}
  8105bb:	c9                   	leave  
  8105bc:	c3                   	ret    

008105bd <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8105bd:	f3 0f 1e fb          	endbr32 
  8105c1:	55                   	push   %ebp
  8105c2:	89 e5                	mov    %esp,%ebp
  8105c4:	56                   	push   %esi
  8105c5:	53                   	push   %ebx
  8105c6:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  8105c9:	8b 45 08             	mov    0x8(%ebp),%eax
  8105cc:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  8105d1:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  8105d7:	8b 45 14             	mov    0x14(%ebp),%eax
  8105da:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8105df:	b8 07 00 00 00       	mov    $0x7,%eax
  8105e4:	e8 56 fe ff ff       	call   81043f <nsipc>
  8105e9:	89 c3                	mov    %eax,%ebx
  8105eb:	85 c0                	test   %eax,%eax
  8105ed:	78 26                	js     810615 <nsipc_recv+0x58>
		assert(r < 1600 && r <= len);
  8105ef:	81 fe 3f 06 00 00    	cmp    $0x63f,%esi
  8105f5:	b8 3f 06 00 00       	mov    $0x63f,%eax
  8105fa:	0f 4e c6             	cmovle %esi,%eax
  8105fd:	39 c3                	cmp    %eax,%ebx
  8105ff:	7f 1d                	jg     81061e <nsipc_recv+0x61>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810601:	83 ec 04             	sub    $0x4,%esp
  810604:	53                   	push   %ebx
  810605:	68 00 d0 b3 00       	push   $0xb3d000
  81060a:	ff 75 0c             	pushl  0xc(%ebp)
  81060d:	e8 14 ec ff ff       	call   80f226 <memmove>
  810612:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  810615:	89 d8                	mov    %ebx,%eax
  810617:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81061a:	5b                   	pop    %ebx
  81061b:	5e                   	pop    %esi
  81061c:	5d                   	pop    %ebp
  81061d:	c3                   	ret    
		assert(r < 1600 && r <= len);
  81061e:	68 ae 3c 81 00       	push   $0x813cae
  810623:	68 4b 29 81 00       	push   $0x81294b
  810628:	6a 62                	push   $0x62
  81062a:	68 c3 3c 81 00       	push   $0x813cc3
  81062f:	e8 03 e3 ff ff       	call   80e937 <_panic>

00810634 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  810634:	f3 0f 1e fb          	endbr32 
  810638:	55                   	push   %ebp
  810639:	89 e5                	mov    %esp,%ebp
  81063b:	53                   	push   %ebx
  81063c:	83 ec 04             	sub    $0x4,%esp
  81063f:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  810642:	8b 45 08             	mov    0x8(%ebp),%eax
  810645:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  81064a:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  810650:	7f 2e                	jg     810680 <nsipc_send+0x4c>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  810652:	83 ec 04             	sub    $0x4,%esp
  810655:	53                   	push   %ebx
  810656:	ff 75 0c             	pushl  0xc(%ebp)
  810659:	68 0c d0 b3 00       	push   $0xb3d00c
  81065e:	e8 c3 eb ff ff       	call   80f226 <memmove>
	nsipcbuf.send.req_size = size;
  810663:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  810669:	8b 45 14             	mov    0x14(%ebp),%eax
  81066c:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  810671:	b8 08 00 00 00       	mov    $0x8,%eax
  810676:	e8 c4 fd ff ff       	call   81043f <nsipc>
}
  81067b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81067e:	c9                   	leave  
  81067f:	c3                   	ret    
	assert(size < 1600);
  810680:	68 cf 3c 81 00       	push   $0x813ccf
  810685:	68 4b 29 81 00       	push   $0x81294b
  81068a:	6a 6d                	push   $0x6d
  81068c:	68 c3 3c 81 00       	push   $0x813cc3
  810691:	e8 a1 e2 ff ff       	call   80e937 <_panic>

00810696 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810696:	f3 0f 1e fb          	endbr32 
  81069a:	55                   	push   %ebp
  81069b:	89 e5                	mov    %esp,%ebp
  81069d:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  8106a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8106a3:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  8106a8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106ab:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  8106b0:	8b 45 10             	mov    0x10(%ebp),%eax
  8106b3:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  8106b8:	b8 09 00 00 00       	mov    $0x9,%eax
  8106bd:	e8 7d fd ff ff       	call   81043f <nsipc>
}
  8106c2:	c9                   	leave  
  8106c3:	c3                   	ret    

008106c4 <free>:
	return v;
}

void
free(void *v)
{
  8106c4:	f3 0f 1e fb          	endbr32 
  8106c8:	55                   	push   %ebp
  8106c9:	89 e5                	mov    %esp,%ebp
  8106cb:	53                   	push   %ebx
  8106cc:	83 ec 04             	sub    $0x4,%esp
  8106cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8106d2:	85 db                	test   %ebx,%ebx
  8106d4:	0f 84 85 00 00 00    	je     81075f <free+0x9b>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8106da:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8106e0:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8106e5:	77 51                	ja     810738 <free+0x74>

	c = ROUNDDOWN(v, PGSIZE);
  8106e7:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8106ed:	89 d8                	mov    %ebx,%eax
  8106ef:	c1 e8 0c             	shr    $0xc,%eax
  8106f2:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8106f9:	f6 c4 02             	test   $0x2,%ah
  8106fc:	74 50                	je     81074e <free+0x8a>
		sys_page_unmap(0, c);
  8106fe:	83 ec 08             	sub    $0x8,%esp
  810701:	53                   	push   %ebx
  810702:	6a 00                	push   $0x0
  810704:	e8 d3 ed ff ff       	call   80f4dc <sys_page_unmap>
		c += PGSIZE;
  810709:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  81070f:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810715:	83 c4 10             	add    $0x10,%esp
  810718:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  81071d:	76 ce                	jbe    8106ed <free+0x29>
  81071f:	68 17 3d 81 00       	push   $0x813d17
  810724:	68 4b 29 81 00       	push   $0x81294b
  810729:	68 81 00 00 00       	push   $0x81
  81072e:	68 0a 3d 81 00       	push   $0x813d0a
  810733:	e8 ff e1 ff ff       	call   80e937 <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  810738:	68 dc 3c 81 00       	push   $0x813cdc
  81073d:	68 4b 29 81 00       	push   $0x81294b
  810742:	6a 7a                	push   $0x7a
  810744:	68 0a 3d 81 00       	push   $0x813d0a
  810749:	e8 e9 e1 ff ff       	call   80e937 <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  81074e:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  810754:	83 e8 01             	sub    $0x1,%eax
  810757:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  81075d:	74 05                	je     810764 <free+0xa0>
		sys_page_unmap(0, c);
}
  81075f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810762:	c9                   	leave  
  810763:	c3                   	ret    
		sys_page_unmap(0, c);
  810764:	83 ec 08             	sub    $0x8,%esp
  810767:	53                   	push   %ebx
  810768:	6a 00                	push   $0x0
  81076a:	e8 6d ed ff ff       	call   80f4dc <sys_page_unmap>
  81076f:	83 c4 10             	add    $0x10,%esp
  810772:	eb eb                	jmp    81075f <free+0x9b>

00810774 <malloc>:
{
  810774:	f3 0f 1e fb          	endbr32 
  810778:	55                   	push   %ebp
  810779:	89 e5                	mov    %esp,%ebp
  81077b:	57                   	push   %edi
  81077c:	56                   	push   %esi
  81077d:	53                   	push   %ebx
  81077e:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  810781:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810786:	85 c0                	test   %eax,%eax
  810788:	74 74                	je     8107fe <malloc+0x8a>
	n = ROUNDUP(n, 4);
  81078a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81078d:	8d 51 03             	lea    0x3(%ecx),%edx
  810790:	83 e2 fc             	and    $0xfffffffc,%edx
  810793:	89 d6                	mov    %edx,%esi
  810795:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  810798:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  81079e:	0f 87 12 01 00 00    	ja     8108b6 <malloc+0x142>
	if ((uintptr_t) mptr % PGSIZE){
  8107a4:	89 c1                	mov    %eax,%ecx
  8107a6:	a9 ff 0f 00 00       	test   $0xfff,%eax
  8107ab:	74 30                	je     8107dd <malloc+0x69>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  8107ad:	89 c3                	mov    %eax,%ebx
  8107af:	c1 eb 0c             	shr    $0xc,%ebx
  8107b2:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  8107b6:	c1 ea 0c             	shr    $0xc,%edx
  8107b9:	39 d3                	cmp    %edx,%ebx
  8107bb:	74 64                	je     810821 <malloc+0xad>
		free(mptr);	/* drop reference to this page */
  8107bd:	83 ec 0c             	sub    $0xc,%esp
  8107c0:	50                   	push   %eax
  8107c1:	e8 fe fe ff ff       	call   8106c4 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8107c6:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  8107cb:	05 00 10 00 00       	add    $0x1000,%eax
  8107d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  8107d5:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  8107da:	83 c4 10             	add    $0x10,%esp
  8107dd:	8b 15 d4 b1 b3 00    	mov    0xb3b1d4,%edx
{
  8107e3:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  8107ea:	be 00 00 00 00       	mov    $0x0,%esi
		if (isfree(mptr, n + 4))
  8107ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8107f2:	8d 78 04             	lea    0x4(%eax),%edi
  8107f5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
  8107f9:	e9 86 00 00 00       	jmp    810884 <malloc+0x110>
		mptr = mbegin;
  8107fe:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810805:	00 00 08 
	n = ROUNDUP(n, 4);
  810808:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81080b:	8d 51 03             	lea    0x3(%ecx),%edx
  81080e:	83 e2 fc             	and    $0xfffffffc,%edx
  810811:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  810814:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  81081a:	76 c1                	jbe    8107dd <malloc+0x69>
  81081c:	e9 fb 00 00 00       	jmp    81091c <malloc+0x1a8>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  810821:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  810827:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
			(*ref)++;
  81082d:	83 41 fc 01          	addl   $0x1,-0x4(%ecx)
			mptr += n;
  810831:	89 f2                	mov    %esi,%edx
  810833:	01 c2                	add    %eax,%edx
  810835:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  81083b:	e9 dc 00 00 00       	jmp    81091c <malloc+0x1a8>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810840:	05 00 10 00 00       	add    $0x1000,%eax
  810845:	39 c1                	cmp    %eax,%ecx
  810847:	76 74                	jbe    8108bd <malloc+0x149>
		if (va >= (uintptr_t) mend
  810849:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  81084e:	77 22                	ja     810872 <malloc+0xfe>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810850:	89 c3                	mov    %eax,%ebx
  810852:	c1 eb 16             	shr    $0x16,%ebx
  810855:	8b 1c 9d 00 d0 7b ef 	mov    -0x10843000(,%ebx,4),%ebx
  81085c:	f6 c3 01             	test   $0x1,%bl
  81085f:	74 df                	je     810840 <malloc+0xcc>
  810861:	89 c3                	mov    %eax,%ebx
  810863:	c1 eb 0c             	shr    $0xc,%ebx
  810866:	8b 1c 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%ebx
  81086d:	f6 c3 01             	test   $0x1,%bl
  810870:	74 ce                	je     810840 <malloc+0xcc>
  810872:	81 c2 00 10 00 00    	add    $0x1000,%edx
  810878:	0f b6 75 e3          	movzbl -0x1d(%ebp),%esi
		if (mptr == mend) {
  81087c:	81 fa 00 00 00 10    	cmp    $0x10000000,%edx
  810882:	74 0a                	je     81088e <malloc+0x11a>
  810884:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810887:	89 d0                	mov    %edx,%eax
  810889:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
  81088c:	eb b7                	jmp    810845 <malloc+0xd1>
			mptr = mbegin;
  81088e:	ba 00 00 00 08       	mov    $0x8000000,%edx
  810893:	be 01 00 00 00       	mov    $0x1,%esi
			if (++nwrap == 2)
  810898:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  81089c:	75 e6                	jne    810884 <malloc+0x110>
  81089e:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  8108a5:	00 00 08 
				return 0;	/* out of address space */
  8108a8:	b8 00 00 00 00       	mov    $0x0,%eax
  8108ad:	eb 6d                	jmp    81091c <malloc+0x1a8>
			return 0;	/* out of physical memory */
  8108af:	b8 00 00 00 00       	mov    $0x0,%eax
  8108b4:	eb 66                	jmp    81091c <malloc+0x1a8>
		return 0;
  8108b6:	b8 00 00 00 00       	mov    $0x0,%eax
  8108bb:	eb 5f                	jmp    81091c <malloc+0x1a8>
  8108bd:	89 f0                	mov    %esi,%eax
  8108bf:	84 c0                	test   %al,%al
  8108c1:	74 08                	je     8108cb <malloc+0x157>
  8108c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8108c6:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
	for (i = 0; i < n + 4; i += PGSIZE){
  8108cb:	bb 00 00 00 00       	mov    $0x0,%ebx
  8108d0:	89 de                	mov    %ebx,%esi
  8108d2:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8108d5:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  8108db:	39 df                	cmp    %ebx,%edi
  8108dd:	76 45                	jbe    810924 <malloc+0x1b0>
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8108df:	83 ec 04             	sub    $0x4,%esp
  8108e2:	68 07 02 00 00       	push   $0x207
  8108e7:	03 35 d4 b1 b3 00    	add    0xb3b1d4,%esi
  8108ed:	56                   	push   %esi
  8108ee:	6a 00                	push   $0x0
  8108f0:	e8 9c eb ff ff       	call   80f491 <sys_page_alloc>
  8108f5:	83 c4 10             	add    $0x10,%esp
  8108f8:	85 c0                	test   %eax,%eax
  8108fa:	79 d4                	jns    8108d0 <malloc+0x15c>
  8108fc:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8108ff:	eb 42                	jmp    810943 <malloc+0x1cf>
	ref = (uint32_t*) (mptr + i - 4);
  810901:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810906:	c7 84 30 fc 0f 00 00 	movl   $0x2,0xffc(%eax,%esi,1)
  81090d:	02 00 00 00 
	mptr += n;
  810911:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810914:	01 c2                	add    %eax,%edx
  810916:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
}
  81091c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  81091f:	5b                   	pop    %ebx
  810920:	5e                   	pop    %esi
  810921:	5f                   	pop    %edi
  810922:	5d                   	pop    %ebp
  810923:	c3                   	ret    
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810924:	83 ec 04             	sub    $0x4,%esp
  810927:	6a 07                	push   $0x7
  810929:	89 f0                	mov    %esi,%eax
  81092b:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810931:	50                   	push   %eax
  810932:	6a 00                	push   $0x0
  810934:	e8 58 eb ff ff       	call   80f491 <sys_page_alloc>
  810939:	83 c4 10             	add    $0x10,%esp
  81093c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  81093f:	85 c0                	test   %eax,%eax
  810941:	79 be                	jns    810901 <malloc+0x18d>
			for (; i >= 0; i -= PGSIZE)
  810943:	85 db                	test   %ebx,%ebx
  810945:	0f 88 64 ff ff ff    	js     8108af <malloc+0x13b>
				sys_page_unmap(0, mptr + i);
  81094b:	83 ec 08             	sub    $0x8,%esp
  81094e:	89 d8                	mov    %ebx,%eax
  810950:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810956:	50                   	push   %eax
  810957:	6a 00                	push   $0x0
  810959:	e8 7e eb ff ff       	call   80f4dc <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  81095e:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  810964:	83 c4 10             	add    $0x10,%esp
  810967:	eb da                	jmp    810943 <malloc+0x1cf>

00810969 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  810969:	f3 0f 1e fb          	endbr32 
  81096d:	55                   	push   %ebp
  81096e:	89 e5                	mov    %esp,%ebp
  810970:	56                   	push   %esi
  810971:	53                   	push   %ebx
  810972:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  810975:	83 ec 0c             	sub    $0xc,%esp
  810978:	ff 75 08             	pushl  0x8(%ebp)
  81097b:	e8 4b f0 ff ff       	call   80f9cb <fd2data>
  810980:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  810982:	83 c4 08             	add    $0x8,%esp
  810985:	68 2f 3d 81 00       	push   $0x813d2f
  81098a:	53                   	push   %ebx
  81098b:	e8 98 e6 ff ff       	call   80f028 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  810990:	8b 46 04             	mov    0x4(%esi),%eax
  810993:	2b 06                	sub    (%esi),%eax
  810995:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  81099b:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8109a2:	00 00 00 
	stat->st_dev = &devpipe;
  8109a5:	c7 83 88 00 00 00 5c 	movl   $0x81435c,0x88(%ebx)
  8109ac:	43 81 00 
	return 0;
}
  8109af:	b8 00 00 00 00       	mov    $0x0,%eax
  8109b4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8109b7:	5b                   	pop    %ebx
  8109b8:	5e                   	pop    %esi
  8109b9:	5d                   	pop    %ebp
  8109ba:	c3                   	ret    

008109bb <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  8109bb:	f3 0f 1e fb          	endbr32 
  8109bf:	55                   	push   %ebp
  8109c0:	89 e5                	mov    %esp,%ebp
  8109c2:	53                   	push   %ebx
  8109c3:	83 ec 0c             	sub    $0xc,%esp
  8109c6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  8109c9:	53                   	push   %ebx
  8109ca:	6a 00                	push   $0x0
  8109cc:	e8 0b eb ff ff       	call   80f4dc <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  8109d1:	89 1c 24             	mov    %ebx,(%esp)
  8109d4:	e8 f2 ef ff ff       	call   80f9cb <fd2data>
  8109d9:	83 c4 08             	add    $0x8,%esp
  8109dc:	50                   	push   %eax
  8109dd:	6a 00                	push   $0x0
  8109df:	e8 f8 ea ff ff       	call   80f4dc <sys_page_unmap>
}
  8109e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8109e7:	c9                   	leave  
  8109e8:	c3                   	ret    

008109e9 <_pipeisclosed>:
{
  8109e9:	55                   	push   %ebp
  8109ea:	89 e5                	mov    %esp,%ebp
  8109ec:	57                   	push   %edi
  8109ed:	56                   	push   %esi
  8109ee:	53                   	push   %ebx
  8109ef:	83 ec 1c             	sub    $0x1c,%esp
  8109f2:	89 c7                	mov    %eax,%edi
  8109f4:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  8109f6:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  8109fb:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  8109fe:	83 ec 0c             	sub    $0xc,%esp
  810a01:	57                   	push   %edi
  810a02:	e8 f4 04 00 00       	call   810efb <pageref>
  810a07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  810a0a:	89 34 24             	mov    %esi,(%esp)
  810a0d:	e8 e9 04 00 00       	call   810efb <pageref>
		nn = thisenv->env_runs;
  810a12:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  810a18:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  810a1b:	83 c4 10             	add    $0x10,%esp
  810a1e:	39 cb                	cmp    %ecx,%ebx
  810a20:	74 1b                	je     810a3d <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  810a22:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810a25:	75 cf                	jne    8109f6 <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  810a27:	8b 42 58             	mov    0x58(%edx),%eax
  810a2a:	6a 01                	push   $0x1
  810a2c:	50                   	push   %eax
  810a2d:	53                   	push   %ebx
  810a2e:	68 36 3d 81 00       	push   $0x813d36
  810a33:	e8 e6 df ff ff       	call   80ea1e <cprintf>
  810a38:	83 c4 10             	add    $0x10,%esp
  810a3b:	eb b9                	jmp    8109f6 <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  810a3d:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810a40:	0f 94 c0             	sete   %al
  810a43:	0f b6 c0             	movzbl %al,%eax
}
  810a46:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810a49:	5b                   	pop    %ebx
  810a4a:	5e                   	pop    %esi
  810a4b:	5f                   	pop    %edi
  810a4c:	5d                   	pop    %ebp
  810a4d:	c3                   	ret    

00810a4e <devpipe_write>:
{
  810a4e:	f3 0f 1e fb          	endbr32 
  810a52:	55                   	push   %ebp
  810a53:	89 e5                	mov    %esp,%ebp
  810a55:	57                   	push   %edi
  810a56:	56                   	push   %esi
  810a57:	53                   	push   %ebx
  810a58:	83 ec 28             	sub    $0x28,%esp
  810a5b:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810a5e:	56                   	push   %esi
  810a5f:	e8 67 ef ff ff       	call   80f9cb <fd2data>
  810a64:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810a66:	83 c4 10             	add    $0x10,%esp
  810a69:	bf 00 00 00 00       	mov    $0x0,%edi
  810a6e:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810a71:	74 4f                	je     810ac2 <devpipe_write+0x74>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  810a73:	8b 43 04             	mov    0x4(%ebx),%eax
  810a76:	8b 0b                	mov    (%ebx),%ecx
  810a78:	8d 51 20             	lea    0x20(%ecx),%edx
  810a7b:	39 d0                	cmp    %edx,%eax
  810a7d:	72 14                	jb     810a93 <devpipe_write+0x45>
			if (_pipeisclosed(fd, p))
  810a7f:	89 da                	mov    %ebx,%edx
  810a81:	89 f0                	mov    %esi,%eax
  810a83:	e8 61 ff ff ff       	call   8109e9 <_pipeisclosed>
  810a88:	85 c0                	test   %eax,%eax
  810a8a:	75 3b                	jne    810ac7 <devpipe_write+0x79>
			sys_yield();
  810a8c:	e8 dd e9 ff ff       	call   80f46e <sys_yield>
  810a91:	eb e0                	jmp    810a73 <devpipe_write+0x25>
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810a93:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810a96:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  810a9a:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810a9d:	89 c2                	mov    %eax,%edx
  810a9f:	c1 fa 1f             	sar    $0x1f,%edx
  810aa2:	89 d1                	mov    %edx,%ecx
  810aa4:	c1 e9 1b             	shr    $0x1b,%ecx
  810aa7:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  810aaa:	83 e2 1f             	and    $0x1f,%edx
  810aad:	29 ca                	sub    %ecx,%edx
  810aaf:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810ab3:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810ab7:	83 c0 01             	add    $0x1,%eax
  810aba:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  810abd:	83 c7 01             	add    $0x1,%edi
  810ac0:	eb ac                	jmp    810a6e <devpipe_write+0x20>
	return i;
  810ac2:	8b 45 10             	mov    0x10(%ebp),%eax
  810ac5:	eb 05                	jmp    810acc <devpipe_write+0x7e>
				return 0;
  810ac7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810acc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810acf:	5b                   	pop    %ebx
  810ad0:	5e                   	pop    %esi
  810ad1:	5f                   	pop    %edi
  810ad2:	5d                   	pop    %ebp
  810ad3:	c3                   	ret    

00810ad4 <devpipe_read>:
{
  810ad4:	f3 0f 1e fb          	endbr32 
  810ad8:	55                   	push   %ebp
  810ad9:	89 e5                	mov    %esp,%ebp
  810adb:	57                   	push   %edi
  810adc:	56                   	push   %esi
  810add:	53                   	push   %ebx
  810ade:	83 ec 18             	sub    $0x18,%esp
  810ae1:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  810ae4:	57                   	push   %edi
  810ae5:	e8 e1 ee ff ff       	call   80f9cb <fd2data>
  810aea:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810aec:	83 c4 10             	add    $0x10,%esp
  810aef:	be 00 00 00 00       	mov    $0x0,%esi
  810af4:	3b 75 10             	cmp    0x10(%ebp),%esi
  810af7:	75 14                	jne    810b0d <devpipe_read+0x39>
	return i;
  810af9:	8b 45 10             	mov    0x10(%ebp),%eax
  810afc:	eb 02                	jmp    810b00 <devpipe_read+0x2c>
				return i;
  810afe:	89 f0                	mov    %esi,%eax
}
  810b00:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810b03:	5b                   	pop    %ebx
  810b04:	5e                   	pop    %esi
  810b05:	5f                   	pop    %edi
  810b06:	5d                   	pop    %ebp
  810b07:	c3                   	ret    
			sys_yield();
  810b08:	e8 61 e9 ff ff       	call   80f46e <sys_yield>
		while (p->p_rpos == p->p_wpos) {
  810b0d:	8b 03                	mov    (%ebx),%eax
  810b0f:	3b 43 04             	cmp    0x4(%ebx),%eax
  810b12:	75 18                	jne    810b2c <devpipe_read+0x58>
			if (i > 0)
  810b14:	85 f6                	test   %esi,%esi
  810b16:	75 e6                	jne    810afe <devpipe_read+0x2a>
			if (_pipeisclosed(fd, p))
  810b18:	89 da                	mov    %ebx,%edx
  810b1a:	89 f8                	mov    %edi,%eax
  810b1c:	e8 c8 fe ff ff       	call   8109e9 <_pipeisclosed>
  810b21:	85 c0                	test   %eax,%eax
  810b23:	74 e3                	je     810b08 <devpipe_read+0x34>
				return 0;
  810b25:	b8 00 00 00 00       	mov    $0x0,%eax
  810b2a:	eb d4                	jmp    810b00 <devpipe_read+0x2c>
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  810b2c:	99                   	cltd   
  810b2d:	c1 ea 1b             	shr    $0x1b,%edx
  810b30:	01 d0                	add    %edx,%eax
  810b32:	83 e0 1f             	and    $0x1f,%eax
  810b35:	29 d0                	sub    %edx,%eax
  810b37:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  810b3c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810b3f:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  810b42:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  810b45:	83 c6 01             	add    $0x1,%esi
  810b48:	eb aa                	jmp    810af4 <devpipe_read+0x20>

00810b4a <pipe>:
{
  810b4a:	f3 0f 1e fb          	endbr32 
  810b4e:	55                   	push   %ebp
  810b4f:	89 e5                	mov    %esp,%ebp
  810b51:	56                   	push   %esi
  810b52:	53                   	push   %ebx
  810b53:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  810b56:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810b59:	50                   	push   %eax
  810b5a:	e8 87 ee ff ff       	call   80f9e6 <fd_alloc>
  810b5f:	89 c3                	mov    %eax,%ebx
  810b61:	83 c4 10             	add    $0x10,%esp
  810b64:	85 c0                	test   %eax,%eax
  810b66:	0f 88 23 01 00 00    	js     810c8f <pipe+0x145>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810b6c:	83 ec 04             	sub    $0x4,%esp
  810b6f:	68 07 04 00 00       	push   $0x407
  810b74:	ff 75 f4             	pushl  -0xc(%ebp)
  810b77:	6a 00                	push   $0x0
  810b79:	e8 13 e9 ff ff       	call   80f491 <sys_page_alloc>
  810b7e:	89 c3                	mov    %eax,%ebx
  810b80:	83 c4 10             	add    $0x10,%esp
  810b83:	85 c0                	test   %eax,%eax
  810b85:	0f 88 04 01 00 00    	js     810c8f <pipe+0x145>
	if ((r = fd_alloc(&fd1)) < 0
  810b8b:	83 ec 0c             	sub    $0xc,%esp
  810b8e:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810b91:	50                   	push   %eax
  810b92:	e8 4f ee ff ff       	call   80f9e6 <fd_alloc>
  810b97:	89 c3                	mov    %eax,%ebx
  810b99:	83 c4 10             	add    $0x10,%esp
  810b9c:	85 c0                	test   %eax,%eax
  810b9e:	0f 88 db 00 00 00    	js     810c7f <pipe+0x135>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810ba4:	83 ec 04             	sub    $0x4,%esp
  810ba7:	68 07 04 00 00       	push   $0x407
  810bac:	ff 75 f0             	pushl  -0x10(%ebp)
  810baf:	6a 00                	push   $0x0
  810bb1:	e8 db e8 ff ff       	call   80f491 <sys_page_alloc>
  810bb6:	89 c3                	mov    %eax,%ebx
  810bb8:	83 c4 10             	add    $0x10,%esp
  810bbb:	85 c0                	test   %eax,%eax
  810bbd:	0f 88 bc 00 00 00    	js     810c7f <pipe+0x135>
	va = fd2data(fd0);
  810bc3:	83 ec 0c             	sub    $0xc,%esp
  810bc6:	ff 75 f4             	pushl  -0xc(%ebp)
  810bc9:	e8 fd ed ff ff       	call   80f9cb <fd2data>
  810bce:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810bd0:	83 c4 0c             	add    $0xc,%esp
  810bd3:	68 07 04 00 00       	push   $0x407
  810bd8:	50                   	push   %eax
  810bd9:	6a 00                	push   $0x0
  810bdb:	e8 b1 e8 ff ff       	call   80f491 <sys_page_alloc>
  810be0:	89 c3                	mov    %eax,%ebx
  810be2:	83 c4 10             	add    $0x10,%esp
  810be5:	85 c0                	test   %eax,%eax
  810be7:	0f 88 82 00 00 00    	js     810c6f <pipe+0x125>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810bed:	83 ec 0c             	sub    $0xc,%esp
  810bf0:	ff 75 f0             	pushl  -0x10(%ebp)
  810bf3:	e8 d3 ed ff ff       	call   80f9cb <fd2data>
  810bf8:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  810bff:	50                   	push   %eax
  810c00:	6a 00                	push   $0x0
  810c02:	56                   	push   %esi
  810c03:	6a 00                	push   $0x0
  810c05:	e8 ad e8 ff ff       	call   80f4b7 <sys_page_map>
  810c0a:	89 c3                	mov    %eax,%ebx
  810c0c:	83 c4 20             	add    $0x20,%esp
  810c0f:	85 c0                	test   %eax,%eax
  810c11:	78 4e                	js     810c61 <pipe+0x117>
	fd0->fd_dev_id = devpipe.dev_id;
  810c13:	a1 5c 43 81 00       	mov    0x81435c,%eax
  810c18:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810c1b:	89 02                	mov    %eax,(%edx)
	fd0->fd_omode = O_RDONLY;
  810c1d:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810c20:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	fd1->fd_dev_id = devpipe.dev_id;
  810c27:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810c2a:	89 02                	mov    %eax,(%edx)
	fd1->fd_omode = O_WRONLY;
  810c2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810c2f:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  810c36:	83 ec 0c             	sub    $0xc,%esp
  810c39:	ff 75 f4             	pushl  -0xc(%ebp)
  810c3c:	e8 76 ed ff ff       	call   80f9b7 <fd2num>
  810c41:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810c44:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  810c46:	83 c4 04             	add    $0x4,%esp
  810c49:	ff 75 f0             	pushl  -0x10(%ebp)
  810c4c:	e8 66 ed ff ff       	call   80f9b7 <fd2num>
  810c51:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810c54:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  810c57:	83 c4 10             	add    $0x10,%esp
  810c5a:	bb 00 00 00 00       	mov    $0x0,%ebx
  810c5f:	eb 2e                	jmp    810c8f <pipe+0x145>
	sys_page_unmap(0, va);
  810c61:	83 ec 08             	sub    $0x8,%esp
  810c64:	56                   	push   %esi
  810c65:	6a 00                	push   $0x0
  810c67:	e8 70 e8 ff ff       	call   80f4dc <sys_page_unmap>
  810c6c:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810c6f:	83 ec 08             	sub    $0x8,%esp
  810c72:	ff 75 f0             	pushl  -0x10(%ebp)
  810c75:	6a 00                	push   $0x0
  810c77:	e8 60 e8 ff ff       	call   80f4dc <sys_page_unmap>
  810c7c:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd0);
  810c7f:	83 ec 08             	sub    $0x8,%esp
  810c82:	ff 75 f4             	pushl  -0xc(%ebp)
  810c85:	6a 00                	push   $0x0
  810c87:	e8 50 e8 ff ff       	call   80f4dc <sys_page_unmap>
  810c8c:	83 c4 10             	add    $0x10,%esp
}
  810c8f:	89 d8                	mov    %ebx,%eax
  810c91:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810c94:	5b                   	pop    %ebx
  810c95:	5e                   	pop    %esi
  810c96:	5d                   	pop    %ebp
  810c97:	c3                   	ret    

00810c98 <pipeisclosed>:
{
  810c98:	f3 0f 1e fb          	endbr32 
  810c9c:	55                   	push   %ebp
  810c9d:	89 e5                	mov    %esp,%ebp
  810c9f:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810ca2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810ca5:	50                   	push   %eax
  810ca6:	ff 75 08             	pushl  0x8(%ebp)
  810ca9:	e8 8e ed ff ff       	call   80fa3c <fd_lookup>
  810cae:	83 c4 10             	add    $0x10,%esp
  810cb1:	85 c0                	test   %eax,%eax
  810cb3:	78 18                	js     810ccd <pipeisclosed+0x35>
	p = (struct Pipe*) fd2data(fd);
  810cb5:	83 ec 0c             	sub    $0xc,%esp
  810cb8:	ff 75 f4             	pushl  -0xc(%ebp)
  810cbb:	e8 0b ed ff ff       	call   80f9cb <fd2data>
  810cc0:	89 c2                	mov    %eax,%edx
	return _pipeisclosed(fd, p);
  810cc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810cc5:	e8 1f fd ff ff       	call   8109e9 <_pipeisclosed>
  810cca:	83 c4 10             	add    $0x10,%esp
}
  810ccd:	c9                   	leave  
  810cce:	c3                   	ret    

00810ccf <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  810ccf:	f3 0f 1e fb          	endbr32 
	USED(fd);

	return 0;
}
  810cd3:	b8 00 00 00 00       	mov    $0x0,%eax
  810cd8:	c3                   	ret    

00810cd9 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810cd9:	f3 0f 1e fb          	endbr32 
  810cdd:	55                   	push   %ebp
  810cde:	89 e5                	mov    %esp,%ebp
  810ce0:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810ce3:	68 4e 3d 81 00       	push   $0x813d4e
  810ce8:	ff 75 0c             	pushl  0xc(%ebp)
  810ceb:	e8 38 e3 ff ff       	call   80f028 <strcpy>
	return 0;
}
  810cf0:	b8 00 00 00 00       	mov    $0x0,%eax
  810cf5:	c9                   	leave  
  810cf6:	c3                   	ret    

00810cf7 <devcons_write>:
{
  810cf7:	f3 0f 1e fb          	endbr32 
  810cfb:	55                   	push   %ebp
  810cfc:	89 e5                	mov    %esp,%ebp
  810cfe:	57                   	push   %edi
  810cff:	56                   	push   %esi
  810d00:	53                   	push   %ebx
  810d01:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  810d07:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  810d0c:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  810d12:	3b 75 10             	cmp    0x10(%ebp),%esi
  810d15:	73 31                	jae    810d48 <devcons_write+0x51>
		m = n - tot;
  810d17:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810d1a:	29 f3                	sub    %esi,%ebx
  810d1c:	83 fb 7f             	cmp    $0x7f,%ebx
  810d1f:	b8 7f 00 00 00       	mov    $0x7f,%eax
  810d24:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  810d27:	83 ec 04             	sub    $0x4,%esp
  810d2a:	53                   	push   %ebx
  810d2b:	89 f0                	mov    %esi,%eax
  810d2d:	03 45 0c             	add    0xc(%ebp),%eax
  810d30:	50                   	push   %eax
  810d31:	57                   	push   %edi
  810d32:	e8 ef e4 ff ff       	call   80f226 <memmove>
		sys_cputs(buf, m);
  810d37:	83 c4 08             	add    $0x8,%esp
  810d3a:	53                   	push   %ebx
  810d3b:	57                   	push   %edi
  810d3c:	e8 a1 e6 ff ff       	call   80f3e2 <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  810d41:	01 de                	add    %ebx,%esi
  810d43:	83 c4 10             	add    $0x10,%esp
  810d46:	eb ca                	jmp    810d12 <devcons_write+0x1b>
}
  810d48:	89 f0                	mov    %esi,%eax
  810d4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810d4d:	5b                   	pop    %ebx
  810d4e:	5e                   	pop    %esi
  810d4f:	5f                   	pop    %edi
  810d50:	5d                   	pop    %ebp
  810d51:	c3                   	ret    

00810d52 <devcons_read>:
{
  810d52:	f3 0f 1e fb          	endbr32 
  810d56:	55                   	push   %ebp
  810d57:	89 e5                	mov    %esp,%ebp
  810d59:	83 ec 08             	sub    $0x8,%esp
  810d5c:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  810d61:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  810d65:	74 21                	je     810d88 <devcons_read+0x36>
	while ((c = sys_cgetc()) == 0)
  810d67:	e8 98 e6 ff ff       	call   80f404 <sys_cgetc>
  810d6c:	85 c0                	test   %eax,%eax
  810d6e:	75 07                	jne    810d77 <devcons_read+0x25>
		sys_yield();
  810d70:	e8 f9 e6 ff ff       	call   80f46e <sys_yield>
  810d75:	eb f0                	jmp    810d67 <devcons_read+0x15>
	if (c < 0)
  810d77:	78 0f                	js     810d88 <devcons_read+0x36>
	if (c == 0x04)	// ctl-d is eof
  810d79:	83 f8 04             	cmp    $0x4,%eax
  810d7c:	74 0c                	je     810d8a <devcons_read+0x38>
	*(char*)vbuf = c;
  810d7e:	8b 55 0c             	mov    0xc(%ebp),%edx
  810d81:	88 02                	mov    %al,(%edx)
	return 1;
  810d83:	b8 01 00 00 00       	mov    $0x1,%eax
}
  810d88:	c9                   	leave  
  810d89:	c3                   	ret    
		return 0;
  810d8a:	b8 00 00 00 00       	mov    $0x0,%eax
  810d8f:	eb f7                	jmp    810d88 <devcons_read+0x36>

00810d91 <cputchar>:
{
  810d91:	f3 0f 1e fb          	endbr32 
  810d95:	55                   	push   %ebp
  810d96:	89 e5                	mov    %esp,%ebp
  810d98:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  810d9b:	8b 45 08             	mov    0x8(%ebp),%eax
  810d9e:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  810da1:	6a 01                	push   $0x1
  810da3:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810da6:	50                   	push   %eax
  810da7:	e8 36 e6 ff ff       	call   80f3e2 <sys_cputs>
}
  810dac:	83 c4 10             	add    $0x10,%esp
  810daf:	c9                   	leave  
  810db0:	c3                   	ret    

00810db1 <getchar>:
{
  810db1:	f3 0f 1e fb          	endbr32 
  810db5:	55                   	push   %ebp
  810db6:	89 e5                	mov    %esp,%ebp
  810db8:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  810dbb:	6a 01                	push   $0x1
  810dbd:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810dc0:	50                   	push   %eax
  810dc1:	6a 00                	push   $0x0
  810dc3:	e8 fc ee ff ff       	call   80fcc4 <read>
	if (r < 0)
  810dc8:	83 c4 10             	add    $0x10,%esp
  810dcb:	85 c0                	test   %eax,%eax
  810dcd:	78 06                	js     810dd5 <getchar+0x24>
	if (r < 1)
  810dcf:	74 06                	je     810dd7 <getchar+0x26>
	return c;
  810dd1:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  810dd5:	c9                   	leave  
  810dd6:	c3                   	ret    
		return -E_EOF;
  810dd7:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  810ddc:	eb f7                	jmp    810dd5 <getchar+0x24>

00810dde <iscons>:
{
  810dde:	f3 0f 1e fb          	endbr32 
  810de2:	55                   	push   %ebp
  810de3:	89 e5                	mov    %esp,%ebp
  810de5:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810de8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810deb:	50                   	push   %eax
  810dec:	ff 75 08             	pushl  0x8(%ebp)
  810def:	e8 48 ec ff ff       	call   80fa3c <fd_lookup>
  810df4:	83 c4 10             	add    $0x10,%esp
  810df7:	85 c0                	test   %eax,%eax
  810df9:	78 11                	js     810e0c <iscons+0x2e>
	return fd->fd_dev_id == devcons.dev_id;
  810dfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810dfe:	8b 15 78 43 81 00    	mov    0x814378,%edx
  810e04:	39 10                	cmp    %edx,(%eax)
  810e06:	0f 94 c0             	sete   %al
  810e09:	0f b6 c0             	movzbl %al,%eax
}
  810e0c:	c9                   	leave  
  810e0d:	c3                   	ret    

00810e0e <opencons>:
{
  810e0e:	f3 0f 1e fb          	endbr32 
  810e12:	55                   	push   %ebp
  810e13:	89 e5                	mov    %esp,%ebp
  810e15:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  810e18:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810e1b:	50                   	push   %eax
  810e1c:	e8 c5 eb ff ff       	call   80f9e6 <fd_alloc>
  810e21:	83 c4 10             	add    $0x10,%esp
  810e24:	85 c0                	test   %eax,%eax
  810e26:	78 3a                	js     810e62 <opencons+0x54>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810e28:	83 ec 04             	sub    $0x4,%esp
  810e2b:	68 07 04 00 00       	push   $0x407
  810e30:	ff 75 f4             	pushl  -0xc(%ebp)
  810e33:	6a 00                	push   $0x0
  810e35:	e8 57 e6 ff ff       	call   80f491 <sys_page_alloc>
  810e3a:	83 c4 10             	add    $0x10,%esp
  810e3d:	85 c0                	test   %eax,%eax
  810e3f:	78 21                	js     810e62 <opencons+0x54>
	fd->fd_dev_id = devcons.dev_id;
  810e41:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e44:	8b 15 78 43 81 00    	mov    0x814378,%edx
  810e4a:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  810e4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e4f:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810e56:	83 ec 0c             	sub    $0xc,%esp
  810e59:	50                   	push   %eax
  810e5a:	e8 58 eb ff ff       	call   80f9b7 <fd2num>
  810e5f:	83 c4 10             	add    $0x10,%esp
}
  810e62:	c9                   	leave  
  810e63:	c3                   	ret    

00810e64 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810e64:	f3 0f 1e fb          	endbr32 
  810e68:	55                   	push   %ebp
  810e69:	89 e5                	mov    %esp,%ebp
  810e6b:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  810e6e:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  810e75:	74 0a                	je     810e81 <set_pgfault_handler+0x1d>
			panic("set_pgfault_handler: sys_env_set_pgfault_upcall fail\n");
		}
		
	}
	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  810e77:	8b 45 08             	mov    0x8(%ebp),%eax
  810e7a:	a3 00 e0 b3 00       	mov    %eax,0xb3e000

}
  810e7f:	c9                   	leave  
  810e80:	c3                   	ret    
		if((r = sys_page_alloc(0, (void*)(UXSTACKTOP-PGSIZE),PTE_U|PTE_W|PTE_P))<0){
  810e81:	83 ec 04             	sub    $0x4,%esp
  810e84:	6a 07                	push   $0x7
  810e86:	68 00 f0 bf ee       	push   $0xeebff000
  810e8b:	6a 00                	push   $0x0
  810e8d:	e8 ff e5 ff ff       	call   80f491 <sys_page_alloc>
  810e92:	83 c4 10             	add    $0x10,%esp
  810e95:	85 c0                	test   %eax,%eax
  810e97:	78 2a                	js     810ec3 <set_pgfault_handler+0x5f>
		if (sys_env_set_pgfault_upcall(0, _pgfault_upcall)<0){ 
  810e99:	83 ec 08             	sub    $0x8,%esp
  810e9c:	68 d7 0e 81 00       	push   $0x810ed7
  810ea1:	6a 00                	push   $0x0
  810ea3:	e8 a3 e6 ff ff       	call   80f54b <sys_env_set_pgfault_upcall>
  810ea8:	83 c4 10             	add    $0x10,%esp
  810eab:	85 c0                	test   %eax,%eax
  810ead:	79 c8                	jns    810e77 <set_pgfault_handler+0x13>
			panic("set_pgfault_handler: sys_env_set_pgfault_upcall fail\n");
  810eaf:	83 ec 04             	sub    $0x4,%esp
  810eb2:	68 88 3d 81 00       	push   $0x813d88
  810eb7:	6a 2c                	push   $0x2c
  810eb9:	68 be 3d 81 00       	push   $0x813dbe
  810ebe:	e8 74 da ff ff       	call   80e937 <_panic>
			panic("set_pgfault_handler: sys_page_alloc fail\n");
  810ec3:	83 ec 04             	sub    $0x4,%esp
  810ec6:	68 5c 3d 81 00       	push   $0x813d5c
  810ecb:	6a 22                	push   $0x22
  810ecd:	68 be 3d 81 00       	push   $0x813dbe
  810ed2:	e8 60 da ff ff       	call   80e937 <_panic>

00810ed7 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  810ed7:	54                   	push   %esp
	movl _pgfault_handler, %eax
  810ed8:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax   			// 间接寻址
  810edd:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  810edf:	83 c4 04             	add    $0x4,%esp
	/* 
	 * return address 即trap time eip的值
	 * 我们要做的就是将trap time eip的值写入trap time esp所指向的上一个trapframe
	 * 其实就是在模拟stack调用过程
	*/
	movl 0x28(%esp), %eax;	// 获取trap time eip的值并存在%eax中
  810ee2:	8b 44 24 28          	mov    0x28(%esp),%eax
	subl $0x4, 0x30(%esp);  // trap-time esp = trap-time esp - 4
  810ee6:	83 6c 24 30 04       	subl   $0x4,0x30(%esp)
	movl 0x30(%esp), %edx;    // 将trap time esp的地址放入当前esp中
  810eeb:	8b 54 24 30          	mov    0x30(%esp),%edx
	movl %eax, (%edx);   // 将trap time eip的值写入trap time esp所指向的位置的地址 
  810eef:	89 02                	mov    %eax,(%edx)
	// 思考：为什么可以写入呢？
	// 此时return address就已经设置好了 最后ret时可以找到目标地址了
	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $0x8, %esp;  // remove掉utf_err和utf_fault_va	
  810ef1:	83 c4 08             	add    $0x8,%esp
	popal;			// pop掉general registers
  810ef4:	61                   	popa   

	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $0x4, %esp; // remove掉trap time eip 因为我们已经设置好了
  810ef5:	83 c4 04             	add    $0x4,%esp
	popfl;		 // restore eflags
  810ef8:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl	%esp; // %esp获取到了trap time esp的值
  810ef9:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret;	// ret instruction 做了两件事
  810efa:	c3                   	ret    

00810efb <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810efb:	f3 0f 1e fb          	endbr32 
  810eff:	55                   	push   %ebp
  810f00:	89 e5                	mov    %esp,%ebp
  810f02:	8b 45 08             	mov    0x8(%ebp),%eax
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  810f05:	89 c2                	mov    %eax,%edx
  810f07:	c1 ea 16             	shr    $0x16,%edx
  810f0a:	8b 0c 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%ecx
		return 0;
  810f11:	ba 00 00 00 00       	mov    $0x0,%edx
	if (!(uvpd[PDX(v)] & PTE_P))
  810f16:	f6 c1 01             	test   $0x1,%cl
  810f19:	74 1c                	je     810f37 <pageref+0x3c>
	pte = uvpt[PGNUM(v)];
  810f1b:	c1 e8 0c             	shr    $0xc,%eax
  810f1e:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  810f25:	a8 01                	test   $0x1,%al
  810f27:	74 0e                	je     810f37 <pageref+0x3c>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  810f29:	c1 e8 0c             	shr    $0xc,%eax
  810f2c:	0f b7 14 c5 04 00 00 	movzwl -0x10fffffc(,%eax,8),%edx
  810f33:	ef 
  810f34:	0f b7 d2             	movzwl %dx,%edx
}
  810f37:	89 d0                	mov    %edx,%eax
  810f39:	5d                   	pop    %ebp
  810f3a:	c3                   	ret    
  810f3b:	66 90                	xchg   %ax,%ax
  810f3d:	66 90                	xchg   %ax,%ax
  810f3f:	90                   	nop

00810f40 <__udivdi3>:
  810f40:	f3 0f 1e fb          	endbr32 
  810f44:	55                   	push   %ebp
  810f45:	57                   	push   %edi
  810f46:	56                   	push   %esi
  810f47:	53                   	push   %ebx
  810f48:	83 ec 1c             	sub    $0x1c,%esp
  810f4b:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  810f4f:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  810f53:	8b 74 24 34          	mov    0x34(%esp),%esi
  810f57:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  810f5b:	85 d2                	test   %edx,%edx
  810f5d:	75 19                	jne    810f78 <__udivdi3+0x38>
  810f5f:	39 f3                	cmp    %esi,%ebx
  810f61:	76 4d                	jbe    810fb0 <__udivdi3+0x70>
  810f63:	31 ff                	xor    %edi,%edi
  810f65:	89 e8                	mov    %ebp,%eax
  810f67:	89 f2                	mov    %esi,%edx
  810f69:	f7 f3                	div    %ebx
  810f6b:	89 fa                	mov    %edi,%edx
  810f6d:	83 c4 1c             	add    $0x1c,%esp
  810f70:	5b                   	pop    %ebx
  810f71:	5e                   	pop    %esi
  810f72:	5f                   	pop    %edi
  810f73:	5d                   	pop    %ebp
  810f74:	c3                   	ret    
  810f75:	8d 76 00             	lea    0x0(%esi),%esi
  810f78:	39 f2                	cmp    %esi,%edx
  810f7a:	76 14                	jbe    810f90 <__udivdi3+0x50>
  810f7c:	31 ff                	xor    %edi,%edi
  810f7e:	31 c0                	xor    %eax,%eax
  810f80:	89 fa                	mov    %edi,%edx
  810f82:	83 c4 1c             	add    $0x1c,%esp
  810f85:	5b                   	pop    %ebx
  810f86:	5e                   	pop    %esi
  810f87:	5f                   	pop    %edi
  810f88:	5d                   	pop    %ebp
  810f89:	c3                   	ret    
  810f8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810f90:	0f bd fa             	bsr    %edx,%edi
  810f93:	83 f7 1f             	xor    $0x1f,%edi
  810f96:	75 48                	jne    810fe0 <__udivdi3+0xa0>
  810f98:	39 f2                	cmp    %esi,%edx
  810f9a:	72 06                	jb     810fa2 <__udivdi3+0x62>
  810f9c:	31 c0                	xor    %eax,%eax
  810f9e:	39 eb                	cmp    %ebp,%ebx
  810fa0:	77 de                	ja     810f80 <__udivdi3+0x40>
  810fa2:	b8 01 00 00 00       	mov    $0x1,%eax
  810fa7:	eb d7                	jmp    810f80 <__udivdi3+0x40>
  810fa9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810fb0:	89 d9                	mov    %ebx,%ecx
  810fb2:	85 db                	test   %ebx,%ebx
  810fb4:	75 0b                	jne    810fc1 <__udivdi3+0x81>
  810fb6:	b8 01 00 00 00       	mov    $0x1,%eax
  810fbb:	31 d2                	xor    %edx,%edx
  810fbd:	f7 f3                	div    %ebx
  810fbf:	89 c1                	mov    %eax,%ecx
  810fc1:	31 d2                	xor    %edx,%edx
  810fc3:	89 f0                	mov    %esi,%eax
  810fc5:	f7 f1                	div    %ecx
  810fc7:	89 c6                	mov    %eax,%esi
  810fc9:	89 e8                	mov    %ebp,%eax
  810fcb:	89 f7                	mov    %esi,%edi
  810fcd:	f7 f1                	div    %ecx
  810fcf:	89 fa                	mov    %edi,%edx
  810fd1:	83 c4 1c             	add    $0x1c,%esp
  810fd4:	5b                   	pop    %ebx
  810fd5:	5e                   	pop    %esi
  810fd6:	5f                   	pop    %edi
  810fd7:	5d                   	pop    %ebp
  810fd8:	c3                   	ret    
  810fd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810fe0:	89 f9                	mov    %edi,%ecx
  810fe2:	b8 20 00 00 00       	mov    $0x20,%eax
  810fe7:	29 f8                	sub    %edi,%eax
  810fe9:	d3 e2                	shl    %cl,%edx
  810feb:	89 54 24 08          	mov    %edx,0x8(%esp)
  810fef:	89 c1                	mov    %eax,%ecx
  810ff1:	89 da                	mov    %ebx,%edx
  810ff3:	d3 ea                	shr    %cl,%edx
  810ff5:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  810ff9:	09 d1                	or     %edx,%ecx
  810ffb:	89 f2                	mov    %esi,%edx
  810ffd:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811001:	89 f9                	mov    %edi,%ecx
  811003:	d3 e3                	shl    %cl,%ebx
  811005:	89 c1                	mov    %eax,%ecx
  811007:	d3 ea                	shr    %cl,%edx
  811009:	89 f9                	mov    %edi,%ecx
  81100b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  81100f:	89 eb                	mov    %ebp,%ebx
  811011:	d3 e6                	shl    %cl,%esi
  811013:	89 c1                	mov    %eax,%ecx
  811015:	d3 eb                	shr    %cl,%ebx
  811017:	09 de                	or     %ebx,%esi
  811019:	89 f0                	mov    %esi,%eax
  81101b:	f7 74 24 08          	divl   0x8(%esp)
  81101f:	89 d6                	mov    %edx,%esi
  811021:	89 c3                	mov    %eax,%ebx
  811023:	f7 64 24 0c          	mull   0xc(%esp)
  811027:	39 d6                	cmp    %edx,%esi
  811029:	72 15                	jb     811040 <__udivdi3+0x100>
  81102b:	89 f9                	mov    %edi,%ecx
  81102d:	d3 e5                	shl    %cl,%ebp
  81102f:	39 c5                	cmp    %eax,%ebp
  811031:	73 04                	jae    811037 <__udivdi3+0xf7>
  811033:	39 d6                	cmp    %edx,%esi
  811035:	74 09                	je     811040 <__udivdi3+0x100>
  811037:	89 d8                	mov    %ebx,%eax
  811039:	31 ff                	xor    %edi,%edi
  81103b:	e9 40 ff ff ff       	jmp    810f80 <__udivdi3+0x40>
  811040:	8d 43 ff             	lea    -0x1(%ebx),%eax
  811043:	31 ff                	xor    %edi,%edi
  811045:	e9 36 ff ff ff       	jmp    810f80 <__udivdi3+0x40>
  81104a:	66 90                	xchg   %ax,%ax
  81104c:	66 90                	xchg   %ax,%ax
  81104e:	66 90                	xchg   %ax,%ax

00811050 <__umoddi3>:
  811050:	f3 0f 1e fb          	endbr32 
  811054:	55                   	push   %ebp
  811055:	57                   	push   %edi
  811056:	56                   	push   %esi
  811057:	53                   	push   %ebx
  811058:	83 ec 1c             	sub    $0x1c,%esp
  81105b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  81105f:	8b 74 24 30          	mov    0x30(%esp),%esi
  811063:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  811067:	8b 7c 24 38          	mov    0x38(%esp),%edi
  81106b:	85 c0                	test   %eax,%eax
  81106d:	75 19                	jne    811088 <__umoddi3+0x38>
  81106f:	39 df                	cmp    %ebx,%edi
  811071:	76 5d                	jbe    8110d0 <__umoddi3+0x80>
  811073:	89 f0                	mov    %esi,%eax
  811075:	89 da                	mov    %ebx,%edx
  811077:	f7 f7                	div    %edi
  811079:	89 d0                	mov    %edx,%eax
  81107b:	31 d2                	xor    %edx,%edx
  81107d:	83 c4 1c             	add    $0x1c,%esp
  811080:	5b                   	pop    %ebx
  811081:	5e                   	pop    %esi
  811082:	5f                   	pop    %edi
  811083:	5d                   	pop    %ebp
  811084:	c3                   	ret    
  811085:	8d 76 00             	lea    0x0(%esi),%esi
  811088:	89 f2                	mov    %esi,%edx
  81108a:	39 d8                	cmp    %ebx,%eax
  81108c:	76 12                	jbe    8110a0 <__umoddi3+0x50>
  81108e:	89 f0                	mov    %esi,%eax
  811090:	89 da                	mov    %ebx,%edx
  811092:	83 c4 1c             	add    $0x1c,%esp
  811095:	5b                   	pop    %ebx
  811096:	5e                   	pop    %esi
  811097:	5f                   	pop    %edi
  811098:	5d                   	pop    %ebp
  811099:	c3                   	ret    
  81109a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8110a0:	0f bd e8             	bsr    %eax,%ebp
  8110a3:	83 f5 1f             	xor    $0x1f,%ebp
  8110a6:	75 50                	jne    8110f8 <__umoddi3+0xa8>
  8110a8:	39 d8                	cmp    %ebx,%eax
  8110aa:	0f 82 e0 00 00 00    	jb     811190 <__umoddi3+0x140>
  8110b0:	89 d9                	mov    %ebx,%ecx
  8110b2:	39 f7                	cmp    %esi,%edi
  8110b4:	0f 86 d6 00 00 00    	jbe    811190 <__umoddi3+0x140>
  8110ba:	89 d0                	mov    %edx,%eax
  8110bc:	89 ca                	mov    %ecx,%edx
  8110be:	83 c4 1c             	add    $0x1c,%esp
  8110c1:	5b                   	pop    %ebx
  8110c2:	5e                   	pop    %esi
  8110c3:	5f                   	pop    %edi
  8110c4:	5d                   	pop    %ebp
  8110c5:	c3                   	ret    
  8110c6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8110cd:	8d 76 00             	lea    0x0(%esi),%esi
  8110d0:	89 fd                	mov    %edi,%ebp
  8110d2:	85 ff                	test   %edi,%edi
  8110d4:	75 0b                	jne    8110e1 <__umoddi3+0x91>
  8110d6:	b8 01 00 00 00       	mov    $0x1,%eax
  8110db:	31 d2                	xor    %edx,%edx
  8110dd:	f7 f7                	div    %edi
  8110df:	89 c5                	mov    %eax,%ebp
  8110e1:	89 d8                	mov    %ebx,%eax
  8110e3:	31 d2                	xor    %edx,%edx
  8110e5:	f7 f5                	div    %ebp
  8110e7:	89 f0                	mov    %esi,%eax
  8110e9:	f7 f5                	div    %ebp
  8110eb:	89 d0                	mov    %edx,%eax
  8110ed:	31 d2                	xor    %edx,%edx
  8110ef:	eb 8c                	jmp    81107d <__umoddi3+0x2d>
  8110f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8110f8:	89 e9                	mov    %ebp,%ecx
  8110fa:	ba 20 00 00 00       	mov    $0x20,%edx
  8110ff:	29 ea                	sub    %ebp,%edx
  811101:	d3 e0                	shl    %cl,%eax
  811103:	89 44 24 08          	mov    %eax,0x8(%esp)
  811107:	89 d1                	mov    %edx,%ecx
  811109:	89 f8                	mov    %edi,%eax
  81110b:	d3 e8                	shr    %cl,%eax
  81110d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811111:	89 54 24 04          	mov    %edx,0x4(%esp)
  811115:	8b 54 24 04          	mov    0x4(%esp),%edx
  811119:	09 c1                	or     %eax,%ecx
  81111b:	89 d8                	mov    %ebx,%eax
  81111d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811121:	89 e9                	mov    %ebp,%ecx
  811123:	d3 e7                	shl    %cl,%edi
  811125:	89 d1                	mov    %edx,%ecx
  811127:	d3 e8                	shr    %cl,%eax
  811129:	89 e9                	mov    %ebp,%ecx
  81112b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  81112f:	d3 e3                	shl    %cl,%ebx
  811131:	89 c7                	mov    %eax,%edi
  811133:	89 d1                	mov    %edx,%ecx
  811135:	89 f0                	mov    %esi,%eax
  811137:	d3 e8                	shr    %cl,%eax
  811139:	89 e9                	mov    %ebp,%ecx
  81113b:	89 fa                	mov    %edi,%edx
  81113d:	d3 e6                	shl    %cl,%esi
  81113f:	09 d8                	or     %ebx,%eax
  811141:	f7 74 24 08          	divl   0x8(%esp)
  811145:	89 d1                	mov    %edx,%ecx
  811147:	89 f3                	mov    %esi,%ebx
  811149:	f7 64 24 0c          	mull   0xc(%esp)
  81114d:	89 c6                	mov    %eax,%esi
  81114f:	89 d7                	mov    %edx,%edi
  811151:	39 d1                	cmp    %edx,%ecx
  811153:	72 06                	jb     81115b <__umoddi3+0x10b>
  811155:	75 10                	jne    811167 <__umoddi3+0x117>
  811157:	39 c3                	cmp    %eax,%ebx
  811159:	73 0c                	jae    811167 <__umoddi3+0x117>
  81115b:	2b 44 24 0c          	sub    0xc(%esp),%eax
  81115f:	1b 54 24 08          	sbb    0x8(%esp),%edx
  811163:	89 d7                	mov    %edx,%edi
  811165:	89 c6                	mov    %eax,%esi
  811167:	89 ca                	mov    %ecx,%edx
  811169:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  81116e:	29 f3                	sub    %esi,%ebx
  811170:	19 fa                	sbb    %edi,%edx
  811172:	89 d0                	mov    %edx,%eax
  811174:	d3 e0                	shl    %cl,%eax
  811176:	89 e9                	mov    %ebp,%ecx
  811178:	d3 eb                	shr    %cl,%ebx
  81117a:	d3 ea                	shr    %cl,%edx
  81117c:	09 d8                	or     %ebx,%eax
  81117e:	83 c4 1c             	add    $0x1c,%esp
  811181:	5b                   	pop    %ebx
  811182:	5e                   	pop    %esi
  811183:	5f                   	pop    %edi
  811184:	5d                   	pop    %ebp
  811185:	c3                   	ret    
  811186:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81118d:	8d 76 00             	lea    0x0(%esi),%esi
  811190:	29 fe                	sub    %edi,%esi
  811192:	19 c3                	sbb    %eax,%ebx
  811194:	89 f2                	mov    %esi,%edx
  811196:	89 d9                	mov    %ebx,%ecx
  811198:	e9 1d ff ff ff       	jmp    8110ba <__umoddi3+0x6a>
